"```json\n{\n  \"Coding Problem\": \"We have N points numbered 1 to N arranged in a line in this order.\\n\\nTakahashi decides to make an undirected graph, using these points as the vertices. In the beginning, the graph has no edge. Takahashi will do M operations to add edges in this graph. The i-th operation is as follows:\\n\\n* The operation uses integers L_i and R_i between 1 and N (inclusive), and a positive integer C_i. For every pair of integers (s, t) such that L_i \\\\leq s < t \\\\leq R_i, add an edge of length C_i between Vertex s and Vertex t.\\n\\n\\nThe integers L_1, ..., L_M, R_1, ..., R_M, C_1, ..., C_M are all given as input.\\n\\nTakahashi wants to solve the shortest path problem in the final graph obtained. Find the length of the shortest path from Vertex 1 to Vertex N in the final graph.\\n\\nConstraints\\n\\n* 2 \\\\leq N \\\\leq 10^5\\n* 1 \\\\leq M \\\\leq 10^5\\n* 1 \\\\leq L_i < R_i \\\\leq N\\n* 1 \\\\leq C_i \\\\leq 10^9\\n\\nInput\\n\\nInput is given from Standard Input in the following format:\\n\\n\\nN M\\nL_1 R_1 C_1\\n:\\nL_M R_M C_M\\n\\n\\nOutput\\n\\nPrint the length of the shortest path from Vertex 1 to Vertex N in the final graph. If there is no shortest path, print `-1` instead.\\n\\nExamples\\n\\nInput\\n\\n4 3\\n1 3 2\\n2 4 3\\n1 4 6\\n\\n\\nOutput\\n\\n5\\n\\n\\nInput\\n\\n4 2\\n1 2 1\\n3 4 2\\n\\n\\nOutput\\n\\n-1\\n\\n\\nInput\\n\\n10 7\\n1 5 18\\n3 4 8\\n1 3 5\\n4 7 10\\n5 9 8\\n6 10 5\\n8 10 3\\n\\n\\nOutput\\n\\n28\",\n  \"Ground Truth Solution\": \"from heapq import heappush, heappop\\n(N, M) = map(int, input().split())\\nLRC = [list(map(int, input().split())) for i in range(M)]\\ndata = [[], []] + [[[i - 1, 0]] for i in range(2, N + 1)]\\nfor (L, R, C) in LRC:\\n\\tdata[L].append([R, C])\\ndist = [[0, 1]]\\ninf = float('inf')\\nflag = [inf] * (N + 1)\\nwhile dist:\\n\\t(y, x) = heappop(dist)\\n\\tif flag[x] != inf:\\n\\t\\tcontinue\\n\\tflag[x] = y\\n\\tfor u in data[x]:\\n\\t\\tif flag[u[0]] == inf:\\n\\t\\t\\theappush(dist, [y + u[1], u[0]])\\n\\tif flag[N] != inf:\\n\\t\\tbreak\\nif flag[N] == inf:\\n\\tprint(-1)\\nelse:\\n\\tprint(flag[N])\",\n  \"LLM CoT Steps Breakdown\": \"- Problem Description Understanding: The problem involves constructing a graph from a set of points and edges, where the edges are added based on given operations. Each operation specifies a range of vertices and a cost, adding an edge of that cost between every pair of vertices within the range. The goal is to find the shortest path from Vertex 1 to Vertex N.\\n- Graph Construction Considerations: The graph is initially empty. Edges are added based on the given operations. A key challenge is to represent this graph efficiently to allow for shortest path computation.\\n- Shortest Path Algorithm Selection: The shortest path from vertex 1 to vertex N must be computed. Dijkstra's algorithm is well-suited for finding the shortest path in a weighted graph. Need to consider that since edge weights are positive, Dijkstra's can be applied directly.\\n- Optimization Techniques:  Since the graph can be dense, optimization techniques might be necessary. The use of a priority queue (heap) in Dijkstra's algorithm is standard for efficiency.\\n- Edge Case Handling: If there is no path between vertices 1 and N, return -1. This needs to be checked after running the shortest path algorithm. Initialize distances to infinity and update only if a path exists.\",\n  \"LLM Questions\": [\n    \"How would you represent the graph given the large constraints on N?\",\n    \"What shortest path algorithm is most appropriate for this problem, and why?\",\n    \"How do you handle the edge case where there is no path from vertex 1 to vertex N?\",\n    \"How can you efficiently implement Dijkstra's algorithm given the large input size and potential density of the graph?\",\n    \"How do you translate the given operations into actual edges in the graph?\",\n    \"Can you describe the time complexity of your approach?\",\n    \"How will you initialize the distance array and priority queue?\",\n    \"How can the efficiency of adding adjacent nodes to the heap be increased?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"An adjacency list is preferred over an adjacency matrix because the graph might be sparse. This representation uses less memory and improves efficiency.\",\n    \"Dijkstra's algorithm is well-suited because it can find the shortest path from a single source to all other vertices in a weighted graph with non-negative edge weights. The weights in the problem will always be positive.\",\n    \"If, after running Dijkstra's algorithm, the distance to vertex N is still infinity, it implies that there is no path. In this case, return -1.\",\n    \"Use a priority queue (heap) to efficiently find the vertex with the smallest current distance. Maintain visited flags to avoid revisiting processed vertices.\",\n    \"Iterate through each operation and, for the given L_i and R_i, add an edge of weight C_i between every pair of vertices (s, t) such that L_i <= s < t <= R_i.\",\n    \"With an efficient implementation of Dijkstra's using a priority queue, the time complexity is O(E log V) where E is the number of edges and V is the number of vertices. In the worst case, where the graph is very dense, this could approach O(V^2 log V).\",\n    \"The distance array will be initialized with infinity for all nodes except the starting node (node 1), which will be initialized with 0. The priority queue will be initialized with the starting node and its distance.\",\n    \"The efficiency of adding adjacent nodes can be optimized by only adding nodes that have not yet been visited or have a distance value greater than the current shortest path to the node. Use an array of booleans for tracking visited status and an array of distances for tracking path lengths. This prevents unnecessary re-evaluation of paths.\"\n  ]\n}\n```"