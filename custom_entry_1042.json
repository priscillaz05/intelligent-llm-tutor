"```json\n{\n  \"Coding Problem\": \"Ashish has a tree consisting of $n$ nodes numbered $1$ to $n$ rooted at node $1$. The $i$-th node in the tree has a cost $a_i$, and binary digit $b_i$ is written in it. He wants to have binary digit $c_i$ written in the $i$-th node in the end.\\n\\nTo achieve this, he can perform the following operation any number of times:   Select any $k$ nodes from the subtree of any node $u$, and shuffle the digits in these nodes as he wishes, incurring a cost of $k \\cdot a_u$. Here, he can choose $k$ ranging from $1$ to the size of the subtree of $u$. \\n\\nHe wants to perform the operations in such a way that every node finally has the digit corresponding to its target.\\n\\nHelp him find the minimum total cost he needs to spend so that after all the operations, every node $u$ has digit $c_u$ written in it, or determine that it is impossible.\\n\\n\\n-----Input-----\\n\\nFirst line contains a single integer $n$ $(1 \\le n \\le 2 \\cdot 10^5)$ denoting the number of nodes in the tree.\\n\\n$i$-th line of the next $n$ lines contains 3 space-separated integers $a_i$, $b_i$, $c_i$ $(1 \\leq a_i \\leq 10^9, 0 \\leq b_i, c_i \\leq 1)$ \\u00a0\\u2014 the cost of the $i$-th node, its initial digit and its goal digit.\\n\\nEach of the next $n - 1$ lines contain two integers $u$, $v$ $(1 \\leq u, v \\leq n, \\\\text{ } u \\\\ne v)$, meaning that there is an edge between nodes $u$ and $v$ in the tree.\\n\\n\\n-----Output-----\\n\\nPrint the minimum total cost to make every node reach its target digit, and $-1$ if it is impossible.\\n\\n\\n-----Examples-----\\nInput\\n5\\n1 0 1\\n20 1 0\\n300 0 1\\n4000 0 0\\n50000 1 0\\n1 2\\n2 3\\n2 4\\n1 5\\n\\nOutput\\n4\\nInput\\n5\\n10000 0 1\\n2000 1 0\\n300 0 1\\n40 0 0\\n1 1 0\\n1 2\\n2 3\\n2 4\\n1 5\\n\\nOutput\\n24000\\nInput\\n2\\n109 0 1\\n205 0 1\\n1 2\\n\\nOutput\\n-1\\n\\n\\n-----Note-----\\n\\nThe tree corresponding to samples $1$ and $2$ are: [Image]\\n\\nIn sample $1$, we can choose node $1$ and $k = 4$ for a cost of $4 \\\\cdot 1$ = $4$ and select nodes ${1, 2, 3, 5}$, shuffle their digits and get the desired digits in every node.\\n\\nIn sample $2$, we can choose node $1$ and $k = 2$ for a cost of $10000 \\\\cdot 2$, select nodes ${1, 5}$ and exchange their digits, and similarly, choose node $2$ and $k = 2$ for a cost of $2000 \\\\cdot 2$, select nodes ${2, 3}$ and exchange their digits to get the desired digits in every node.\\n\\nIn sample $3$, it is impossible to get the desired digits, because there is no node with digit $1$ initially.\",\n  \"Ground Truth Solution\": \"import io, os\\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nimport sys\\nfrom collections import deque\\n\\ndef main():\\n\\tn = int(input())\\n\\t(Cost, Fr, To) = ([], [], [])\\n\\tfor _ in range(n):\\n\\t\\t(cost, fr, to) = map(int, input().split())\\n\\t\\tCost.append(cost)\\n\\t\\tFr.append(fr)\\n\\t\\tTo.append(to)\\n\\tif sum(Fr) != sum(To):\\n\\t\\treturn -1\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\tEdges = [[] for _ in range(n)]\\n\\tfor _ in range(n - 1):\\n\\t\\t(u, v) = map(lambda x: int(x) - 1, input().split())\\n\\t\\tEdges[u].append(v)\\n\\t\\tEdges[v].append(u)\\n\\tChi = [[] for _ in range(n)]\\n\\tPar = [-1] * n\\n\\tDepth = [0] * n\\n\\tq = deque()\\n\\tq.append(0)\\n\\twhile q:\\n\\t\\tfr = q.popleft()\\n\\t\\tfor to in Edges[fr]:\\n\\t\\t\\tif to == Par[fr]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tChi[fr].append(to)\\n\\t\\t\\tPar[to] = fr\\n\\t\\t\\tCost[to] = min(Cost[to], Cost[fr])\\n\\t\\t\\tDepth[to] = Depth[fr] + 1\\n\\t\\t\\tq.append(to)\\n\\td = max(Depth)\\n\\tD = [[] for _ in range(d + 1)]\\n\\tfor i in range(n):\\n\\t\\tdepth = Depth[i]\\n\\t\\tD[depth].append(i)\\n\\t(ToOne, ToZero) = ([0] * n, [0] * n)\\n\\tans = 0\\n\\tfor i in range(d + 1)[::-1]:\\n\\t\\tfor par in D[i]:\\n\\t\\t\\t(a, b, cost) = (Fr[par], To[par], Cost[par])\\n\\t\\t\\tif a == 0 and b == 1:\\n\\t\\t\\t\\tToOne[par] += 1\\n\\t\\t\\telif a == 1 and b == 0:\\n\\t\\t\\t\\tToZero[par] += 1\\n\\t\\t\\tfor chi in Edges[par]:\\n\\t\\t\\t\\tif chi == Par[par]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tToOne[par] += ToOne[chi]\\n\\t\\t\\t\\tToZero[par] += ToZero[chi]\\n\\t\\t\\tchange = min(ToOne[par], ToZero[par])\\n\\t\\t\\tans += change * cost * 2\\n\\t\\t\\tToOne[par] -= change\\n\\t\\t\\tToZero[par] -= change\\n\\t\\t\\tv = Par[par]\\n\\treturn ans\\nprint(main())\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires minimizing the cost to transform a tree's node values from initial binary digits ($b_i$) to target binary digits ($c_i$). The transformation involves shuffling digits within the subtree of any node $u$ at a cost of $k * a_u$, where $k$ is the number of shuffled nodes and $a_u$ is the cost of node $u$.\\n- Identifying Constraints and Edge Cases:  The crucial constraint is the ability to shuffle digits only within subtrees. An impossible scenario arises if the total number of initial '1's doesn't match the total number of target '1's. Consider the single-node case, where no operation is needed if the initial and target digits match.\\n- Devising a Strategy: A bottom-up approach, starting from the deepest nodes, seems promising. Calculate the surplus or deficit of '1's needed in each subtree. The key is to propagate the differences upwards towards the root, balancing '1's and '0's by incurring the minimum cost at ancestor nodes.\\n- Optimizing Cost Calculation: The cost incurred at each node should be based on the node's cost ($a_i$) and the number of '1's and '0's being shuffled. The minimum cost can be achieved by finding the minimum number of '1's that need to be changed to '0's or vice versa. This involves traversing the tree and accumulating the changes required in each subtree.\",\n  \"LLM Questions\": [\n    \"How can we determine if it's impossible to achieve the target configuration of digits?\",\n    \"What is the significance of subtree operations in the problem statement, and how does it affect the solution strategy?\",\n    \"How can we minimize the cost when shuffling digits within a subtree?\",\n    \"What data structure can efficiently represent the tree structure and facilitate traversal?\",\n    \"How would you handle the edge case where the tree consists of only one node?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"It's impossible if the total number of initial '1's across all nodes is not equal to the total number of target '1's. This is because the operations only shuffle existing digits and do not create or destroy them.\",\n    \"Subtree operations restrict the shuffling of digits to within the subtree of a node. This means we can only adjust digits within a subtree and not arbitrarily across the entire tree. This necessitates a bottom-up approach where we resolve imbalances starting from leaf nodes.\",\n    \"To minimize the cost, we should aim to shuffle the minimum number of digits necessary to satisfy the target configuration in each subtree. The cost is minimized when the number of 1->0 conversions equals the number of 0->1 conversions and this must be the minimum possible such number.\",\n    \"Adjacency lists or dictionaries can be used to represent the tree, where each node maps to its children. This facilitates tree traversal algorithms like Depth-First Search (DFS) or Breadth-First Search (BFS).\",\n    \"If there's only one node, check if the initial digit equals the target digit. If they are the same, the cost is 0; otherwise, it's impossible since no operations can be performed (it would still mean sum(Fr) != sum(To) and lead to -1 output.).\"\n  ]\n}\n```"