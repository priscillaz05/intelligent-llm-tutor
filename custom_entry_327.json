"```json\n{\n  \"Coding Problem\": \"Read problems statements in Mandarin Chinese, Russian and Vietnamese as well. \\n\\nBearland can be represented as a square grid that consists of N rows and N columns.\\nTwo cells are called adjacent if they share a side.\\nIn the input, each cell is described by one character:\\n\\n'.' is an empty cell.\\n'B', 'G' or 'P' is a cell inhabited by bears of one species \u2014 brown, grizzly or polar bears respectively.\\n'?' is a cell inhabited by bears of one species but you don't know which one.\\nNote that this cell can't be empty.\\n\\nGrizzly bears are the most aggressive species.\\nIf a cell is inhabited by grizzly bears, all adjacent cells should be empty, because otherwise there would be fights between bears.\\n\\nBrown and polar bears are a bit calmer.\\nAll brown bears are fine with other brown bears in adjacent cells, but they would fight with bears of any other species.\\nSimilarly, polar bears would fight with bears of any species other than polar bears.\\n\\nLet X denote the number of question marks.\\nSince each question mark represents one of the three species, there are 3^{X} ways to replace them with characters 'B', 'G' and 'P' (denoting the species that live in that cell).\\nFind the number of such ways that there are no fights between bears.\\nPrint the answer modulo (10^{9}+7).\\n\\n------ Input ------ \\n\\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\\n\\nThe first line of each test case contains an integer N denoting the size of the grid.\\n\\nThe following N lines describe the grid.\\nEach of those lines contains a string of length N.\\nEach character is one of five: '.', '?', 'B', 'G', 'P'.\\n\\n------ Output ------ \\n\\nFor each test case, output a single line containing one integer \u2014 the number of ways to replace question marks to avoid fights in Bearland, modulo (10^{9}+7).\\n\\n------ Constraints ------ \\n\\n$1 \u2264 T \u2264 50$\\n$2 \u2264 N \u2264 50$\\n\\n------ Subtasks ------ \\n\\n$Subtask #1 (30 points): 2 \u2264 N \u2264 3$\\n$Subtask #2 (30 points): Each character in the grid will be either '.' or '?'.$\\n$Subtask #3 (40 points): Original constraints.$\\n\\n------ Example ------ \\n\\nInput:\\n6\\n3\\n..?\\n.?B\\nG..\\n2\\nGG\\n..\\n3\\n?.. \\n.??\\n??.\\n3\\n??P\\n???\\n??B\\n7\\n?.?.?.?\\n.?.?.?. \\n?.?.?.?\\n.?.?.?. \\n?.?.?.?\\n.?.?.?. \\n?.?.?.?\\n2\\nPP\\nPP\\n\\nOutput:\\n1\\n0\\n6\\n0\\n288603514\\n1\\n\\n------ Explanation ------ \\n\\nTest case 1. We are given the grid of size 3 \u00d7 3. One of the already fixed cells is inhabited by brown bears. They would fight with bears of any species other than brown bears, so adjacent cells with question marks must by inhabited by brown bears as well.\\nHence, there is only 1 way to replace question marks (both of them must be replaced by 'B').\\n\\nTest case 2. In the given grid, there are two adjacent cells both inhabited by grizzly bears.\\nThey will fight with each other, so the answer is 0 \u2014 it's impossible to replace question marks so that there would be no fights (it doesn't matter that there are no question marks at all).\\n\\nTest case 3. There are 6 ways:\\n\\nB.. B.. G.. G.. P.. P..\\n.BB .PP .BB .PP .BB .PP\\nBB. PP. BB. PP. BB. PP.\\n\\nTest case 4. No matter how we replace question marks, bears in some two adjacent cells will start a fight.\\nThe answer is 0.\",\n  \"Ground Truth Solution\": \"import sys\\nsys.setrecursionlimit(5000)\\n\\ndef findConnections(i, j, visited, connections):\\n\\tif i > 0:\\n\\t\\tif visited[i - 1][j] == False:\\n\\t\\t\\tconnections[-1].append(land[i - 1][j])\\n\\t\\t\\tvisited[i - 1][j] = True\\n\\t\\t\\tfindConnections(i - 1, j, visited, connections)\\n\\tif i < N - 1:\\n\\t\\tif visited[i + 1][j] == False:\\n\\t\\t\\tconnections[-1].append(land[i + 1][j])\\n\\t\\t\\tvisited[i + 1][j] = True\\n\\t\\t\\tfindConnections(i + 1, j, visited, connections)\\n\\tif j > 0:\\n\\t\\tif visited[i][j - 1] == False:\\n\\t\\t\\tconnections[-1].append(land[i][j - 1])\\n\\t\\t\\tvisited[i][j - 1] = True\\n\\t\\t\\tfindConnections(i, j - 1, visited, connections)\\n\\tif j < N - 1:\\n\\t\\tif visited[i][j + 1] == False:\\n\\t\\t\\tconnections[-1].append(land[i][j + 1])\\n\\t\\t\\tvisited[i][j + 1] = True\\n\\t\\t\\tfindConnections(i, j + 1, visited, connections)\\n\\ndef countAns(connections):\\n\\tans = 1\\n\\tfor i in connections:\\n\\t\\tif len(i) == 1 and i == ['?']:\\n\\t\\t\\tans = ans % MOD * 3\\n\\t\\tif len(i) > 1:\\n\\t\\t\\tif i.count('G') > 0:\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif i.count('B') > 0 and i.count('P') > 0:\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif i.count('B') > 0 or i.count('P') > 0:\\n\\t\\t\\t\\tans *= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans = ans % MOD * 2\\n\\treturn ans % MOD\\n\\ndef solve(N, land):\\n\\tvisited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\\n\\tconnections = []\\n\\tfor i in range(N):\\n\\t\\tfor j in range(N):\\n\\t\\t\\tif visited[i][j] == False:\\n\\t\\t\\t\\tvisited[i][j] = True\\n\\t\\t\\t\\tconnections.append([land[i][j]])\\n\\t\\t\\t\\tfindConnections(i, j, visited, connections)\\n\\tans = countAns(connections)\\n\\treturn ans\\nT = int(input())\\nfor case in range(1, T + 1):\\n\\tN = int(input())\\n\\tland = [[i for i in input()] for j in range(N)]\\n\\tMOD = 10 ** 9 + 7\\n\\tprint(solve(N, land))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem involves determining the number of valid configurations of bear species in a grid, given constraints on which species can coexist in adjacent cells. Question marks ('?') represent unknown species that can be any of the three (B, G, or P). The primary constraint is avoiding fights between bears, where Grizzlies (G) must be isolated, Browns (B) can only coexist with Browns, and Polars (P) can only coexist with Polars.\\n- Identifying Constraints and Edge Cases: Key constraints are the adjacency rules for each bear species. Edge cases include grids with conflicting bear placements (e.g., adjacent G bears or adjacent B and P bears) and handling question marks that might lead to conflicts. The modulo operation is important to prevent integer overflow.\\n- Selecting an Algorithmic Strategy:  A Depth-First Search (DFS) can be used to find connected components of non-empty cells. Then, for each connected component, check if the placement of the bears follows the rules (no conflicting species). The number of ways to fill the question marks within a component is calculated, taking into account the existing bear types in that component and their constraints.\\n- Implementing Conflict Detection and Counting:  The solution needs to implement a function to determine adjacent cells and check for conflicts given the grid configuration. Another function should count the number of '?' in each connected component and calculates possible valid arrangements while adhering to the provided constraints.\",\n  \"LLM Questions\": [\n    \"How do you identify if two cells are adjacent, and why is adjacency important in this problem?\",\n    \"How would you handle a scenario where a cell contains 'G' (Grizzly bear) and it has an adjacent cell that is not empty (i.e. not '.')?\",\n    \"How would you efficiently determine the number of connected components of bear cells in the grid?\",\n    \"Given a connected component, how would you efficiently check for conflicts and count valid configurations if the component contains question marks?\",\n    \"What considerations are necessary when performing calculations modulo (10^9 + 7) to prevent overflow?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Two cells are adjacent if they share a side (up, down, left, or right). Adjacency is important because the problem's constraints dictate which bear species can coexist in adjacent cells without conflict.\",\n    \"If a cell with 'G' has a non-empty adjacent cell, it immediately leads to a conflict. The answer for that test case would be 0, as it's impossible to avoid fights.\",\n    \"A Depth-First Search (DFS) algorithm or a Union-Find algorithm would be efficient to find connected components of bear cells. You can start at each bear cell and explore its neighbors to form connected groups.\",\n    \"Within a connected component, first check if there's a direct conflict between bear types (e.g., adjacent 'B' and 'P', or a 'G' with an adjacent non-'.'). If there are no conflicts, count the '?' in the component. If the component contains 'B' or 'P', all '?' must be filled with the same type to avoid conflict. If the component contains only '?', each can be 'B', 'G', or 'P' except where G's are adjacent to non '.'. Multiply the possibilities modulo (10^9 + 7).\",\n    \"When performing calculations modulo (10^9 + 7), ensure that you take the modulo after each multiplication operation to prevent integer overflow and ensure that the result stays within the specified range. Specifically, after multiplication `ans = (ans % MOD * count % MOD) % MOD`.\"\n  ]\n}\n```"