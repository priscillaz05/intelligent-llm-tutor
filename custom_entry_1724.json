"```json\n{\n  \"Coding Problem\": \"Creatnx has $n$ mirrors, numbered from $1$ to $n$. Every day, Creatnx asks exactly one mirror \\\"Am I beautiful?\\\". The $i$-th mirror will tell Creatnx that he is beautiful with probability $\\\\frac{p_i}{100}$ for all $1 \\\\le i \\\\le n$.\\n\\nCreatnx asks the mirrors one by one, starting from the $1$-st mirror. Every day, if he asks $i$-th mirror, there are two possibilities:  The $i$-th mirror tells Creatnx that he is beautiful. In this case, if $i = n$ Creatnx will stop and become happy, otherwise he will continue asking the $i+1$-th mirror next day;  In the other case, Creatnx will feel upset. The next day, Creatnx will start asking from the $1$-st mirror again. \\n\\nYou need to calculate the expected number of days until Creatnx becomes happy.\\n\\nThis number should be found by modulo $998244353$. Formally, let $M = 998244353$. It can be shown that the answer can be expressed as an irreducible fraction $\\\\frac{p}{q}$, where $p$ and $q$ are integers and $q \\\\not \\\\equiv 0 \\\\pmod{M}$. Output the integer equal to $p \\\\cdot q^{-1} \\\\bmod M$. In other words, output such an integer $x$ that $0 \\\\le x < M$ and $x \\\\cdot q \\\\equiv p \\\\pmod{M}$.\\n\\n\\n-----Input-----\\n\\nThe first line contains one integer $n$ ($1\\\\le n\\\\le 2\\\\cdot 10^5$)\u00a0\u2014 the number of mirrors.\\n\\nThe second line contains $n$ integers $p_1, p_2, \\\\ldots, p_n$ ($1 \\\\leq p_i \\\\leq 100$).\\n\\n\\n-----Output-----\\n\\nPrint the answer modulo $998244353$ in a single line.\\n\\n\\n-----Examples-----\\nInput\\n1\\n50\\n\\nOutput\\n2\\n\\nInput\\n3\\n10 20 50\\n\\nOutput\\n112\\n\\n\\n\\n-----Note-----\\n\\nIn the first test, there is only one mirror and it tells, that Creatnx is beautiful with probability $\\\\frac{1}{2}$. So, the expected number of days until Creatnx becomes happy is $2$.\",\n  \"Ground Truth Solution\": \"def main():\\n\\tm = 998244353\\n\\tn = int(input())\\n\\tpp = map(int, input().split())\\n\\tprobb = 100\\n\\tnum = 0\\n\\tfor (i, p) in enumerate(pp, 1):\\n\\t\\tprobu = (100 - p) * probb % m\\n\\t\\tprobb = p * probb % m\\n\\t\\tnum = (num * 100 + i * probu) % m\\n\\tnum = (num + n * probb) % m\\n\\tprint(num * pow(probb, m - 2, m) % m)\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: Creatnx asks mirrors sequentially if he is beautiful. Each mirror has a probability of saying yes. If a mirror says no, Creatnx restarts from the first mirror. The goal is to find the expected number of days until Creatnx reaches the last mirror and it says yes.\\n- Identifying Key Components: Define probabilities, modular arithmetic, and the expected value calculation as important. The main idea is to express the expected number of days using recursive relationships and then use modular inverse to avoid floating point numbers.\\n- Defining Variables: Let $n$ be the number of mirrors, $p_i$ the probability of the $i$-th mirror saying yes, and $E$ be the expected number of days. Pre-compute prefix products of $p_i$ to efficiently calculate the probability of reaching a specific mirror.\\n- Calculating the Expected Value: The expected number of days is calculated by taking into account the probability of failing at each mirror (mirror says no) and restarting the process. Using modular arithmetic at each step to prevent overflow.\\n- Implementation Details: Pay special attention to calculating the modular inverse correctly using Fermat's Little Theorem. Use fast exponentiation (binary exponentiation) to compute the modular inverse. The modulo operation must be applied throughout the computations to keep numbers within the required range.\",\n  \"LLM Questions\": [\n    \"How do you handle the constraint that the answer must be modulo 998244353?\",\n    \"How can you efficiently compute $a^{-1} \\\\pmod{m}$ if $m$ is a prime number?\",\n    \"How does the fact that Creatnx restarts from mirror 1 after a negative response affect the expected value calculation?\",\n    \"Given the probabilities $p_i$, how can you calculate the probability that Creatnx reaches a certain mirror $i$ for the first time?\",\n    \"How do you avoid floating-point arithmetic when computing the expected value under modulo constraints?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Every arithmetic operation must be done modulo 998244353 to prevent integer overflow. This means after each addition, subtraction, multiplication, or exponentiation, the result should be taken modulo 998244353.\",\n    \"If $m$ is a prime number, you can use Fermat's Little Theorem, which states that $a^{m-1} \\\\equiv 1 \\\\pmod{m}$.  Therefore, $a^{-1} \\\\equiv a^{m-2} \\\\pmod{m}$. This can be computed efficiently using binary exponentiation.\",\n    \"The fact that Creatnx restarts from mirror 1 means that if at any point a mirror responds negatively, the whole process starts over. This introduces a recursive element in the calculation of the expected number of days. You need to factor in the probability of returning to the start, which will affect the final expected value.\",\n    \"The probability that Creatnx reaches mirror $i$ for the first time is the product of the probabilities of all mirrors before $i$ saying 'yes', i.e., $\\\\prod_{j=1}^{i-1} \\\\frac{p_j}{100}$.\",\n    \"Floating-point arithmetic can be avoided by performing all calculations using integers and modular arithmetic. The final division is done by multiplying by the modular inverse of the denominator (which is also an integer). Using this approach ensures no loss of precision and avoids floating-point errors.\"\n  ]\n}\n```"