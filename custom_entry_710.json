"```json\n{\n  \"Coding Problem\": \"Make a custom esolang interpreter for InfiniTick. InfiniTick has 8 commands: `>`, `<`, `+`, `-`, `*`, `&`, `/`, `\\\\`. The interpreter should run infinitely, stopping only when an error (`&`) occurs. It operates on an infinite memory of bytes and produces infinite output. Non-commands should be ignored.\\n\\nCommands:\\n`>`: Move data selector right.\\n`<`: Move data selector left.\\n`+`: Increment memory cell (truncate overflow: 255+1=0).\\n`-`: Decrement memory cell (truncate overflow: 0-1=255).\\n`*`: Add ASCII value of memory cell to the output tape.\\n`&`: Raise an error, i.e., stop the program.\\n`/`: Skip the next command if the cell value is zero.\\n`\\\\`: Skip the next command if the cell value is nonzero.\",\n  \"Ground Truth Solution\": \"def interpreter(tape):\\n\\t(memory, ptr, output, iCmd) = ({}, 0, '', 0)\\n\\twhile True:\\n\\t\\tcmd = tape[iCmd]\\n\\t\\tif cmd == '>':\\n\\t\\t\\tptr += 1\\n\\t\\telif cmd == '<':\\n\\t\\t\\tptr -= 1\\n\\t\\telif cmd == '+':\\n\\t\\t\\tmemory[ptr] = (memory.get(ptr, 0) + 1) % 256\\n\\t\\telif cmd == '-':\\n\\t\\t\\tmemory[ptr] = (memory.get(ptr, 0) - 1) % 256\\n\\t\\telif cmd == '*':\\n\\t\\t\\toutput += chr(memory.get(ptr, 0))\\n\\t\\telif cmd == '&':\\n\\t\\t\\tbreak\\n\\t\\telif cmd == '/':\\n\\t\\t\\tiCmd += memory.get(ptr, 0) == 0\\n\\t\\telif cmd == '\\\\\\\\':\\n\\t\\t\\tiCmd += memory.get(ptr, 0) != 0\\n\\t\\tiCmd = (iCmd + 1) % len(tape)\\n\\treturn output\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Language: InfiniTick is an esoteric programming language with a unique set of commands operating on a byte array with wrap-around.\\n- Interpreter Setup: Need to initialize the memory (dictionary), a data pointer, an output string, and the instruction pointer.\\n- Main Execution Loop: The interpreter should run in an infinite loop that only stops when an error occurs.\\n- Command Implementation: Properly implement each of the 8 commands, including memory operations, pointer movement, output generation, and conditional skips.\\n- Handling Memory: Memory is a byte array; operations should wrap around at 0 and 255.\\n- Error Condition: The program should stop immediately when the `&` command is encountered.\\n- Wrap-Around: Instruction Pointer `iCmd` must wrap-around the tape length.\",\n  \"LLM Questions\": [\n    \"How should the memory be represented and initialized?\",\n    \"How are the increment and decrement operations implemented, especially regarding overflow?\",\n    \"What should happen when the `&` command is encountered?\",\n    \"How are the conditional skip commands `/` and `\\\\` implemented, and what conditions cause the next command to be skipped?\",\n    \"How does the program handle wrap-around when the instruction pointer goes out of bounds?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The memory can be represented as a dictionary where the keys are memory addresses (integers) and the values are bytes (integers between 0 and 255 inclusive). It should be initialized as an empty dictionary.\",\n    \"Increment and decrement operations should wrap around. Incrementing 255 results in 0, and decrementing 0 results in 255. This can be implemented using the modulo operator `% 256`.\",\n    \"When the `&` command is encountered, the interpreter should immediately terminate the execution loop and return the accumulated output.\",\n    \"The `/` command skips the next command if the current memory cell's value is zero, meaning the instruction pointer is incremented by 1 in addition to the normal increment. The `\\\\` command skips the next command if the current memory cell's value is nonzero, meaning the instruction pointer is incremented by 1 in addition to the normal increment.\",\n    \"The instruction pointer should wrap around to the beginning of the tape when it exceeds the tape's length. This can be implemented using the modulo operator `% len(tape)`.\"\n  ]\n}\n```"