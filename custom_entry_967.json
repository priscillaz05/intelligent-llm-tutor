"```json\n{\n  \"Coding Problem\": \"# Let's play some games!\\n\\nA new RPG called **_Demon Wars_** just came out! Imagine the surprise when you buy it after work, go home, start you _GameStation X_ and it happens to be too difficult for you. Fortunately, you consider yourself a computer connoisseur, so you want to build an AI that tells you every step you have to make to **defeat the evil Demon Lord** and win the game. For now, let's program a simulator.\\n\\nThis game features procedurally generated stages like this one:\\n\\n\\n  Health: \u2665\ufe0f \u2665\ufe0f \u2665\ufe0f   Atk: 1   Def: 1   Bag: []  \\nK   E     |    X#        C      E   S#  D  \\n    E     #######               ###### E E \\n##### #####                          ###-##\\n     M                                 EEE \\n                     ###   ###             \\n                     #       ##E##E##      \\n     ^               #          C  K#      \\n               C      #   H   ##E##E##       \\n\\n\\nAs you can see in the upper status bar, your player starts with **three Health Points**, **1 Attack**, **1 Defense** and an empty **Bag**. These are the only stats that you have to care about for the game. As for the map, we can see many different things, so let's explain every tile one by one:\\n* `^` or `v` or `<` or `>` => **Player** (you). It can face any of four directions.\\n* `#` => **Wall**. You cannot pass through here.\\n* `C` => **Coin _[object]_**.\\n* `M` => **Merchant**. They will go away if you give them **three coins**.\\n* `K` => **Key _[object]_**. They can open a door, after which they break _(yes, like in horror games)_.\\n* `-` and `|` => **Doors** _(there are two doors in the map above)_. \\n* `H` => **Health Potion _[object]_**. It refuels your life to three hearts.\\n* `S` => **Shield**. It gives **+1 defense** permanently.\\n* `X` => **Dual Swords**. It gives **+1 attack** permanently.\\n* `E` => **Enemy**. Has **1 Health Point** and **2 Attack**.\\n* `D` => **Demon Lord**. Has **10 Health Points** and **3 Attack**. You win the game if you kill him.\\n\\nNow, _Demon Wars_ is a turn based game with tank controls. Each turn you can either:\\n* Move forward.\\n* Change direction.\\n* Use an item.\\n* Attack the enemy you have in front of you.\\n\\n\\nWill you be able to defeat your foe and save us all?\\n\\n---------------------\\n\\n# Attack mechanics and enemies\\n\\nWhen you use the attack command, you will attack the enemy right in front of you and deal **the same amount of damage as your attack stat**:\\n\\n\\n E                         E\\n>E    === [Attack] ==>    > \\n E                         E\\n\\n\\n**However**, an enemy can attack you (whatever your orientation is), as long as you are on an adjacent cell to the enemy (vertically or horizontally, not diagonally) and if one of those conditions is fullfilled:\\n\\n* If you turn your character during the turn.\\n* If you move away from them (_D&D's opportunity attack_ :D).\\n* If you use a potion. You will still recover your life points, but then you will be attacked.\\n\\nThe damage formula is `max(0, (Enemy's attack stat) - (Your defense stat))`. Just remember that you attack and use objects **before** the enemies besides you attack. Here is an example where two enemies would attack you:\\n\\n\\nEEE                        EEE\\n >E    === [Attack] ==>     > \\nEEE                        EEE\\n\\n\\nBut enemies are more than obstacles, each time you defeat three of them (demon lord not included), you level up! This level increase will give you **+1 attack** permanently.\\n\\n# Object usage mechanics\\n\\nThere are only three cases where it is acceptable to use objects:\\n* When you use a key in front of a closed door.\\n\\n\\n #                          #\\n>|    === [Use Key] ==>    > \\n #                          #\\n\\n\\n* When you use a coin in front of a merchant (repeat three times for them to go away).\\n\\n\\n>M  === [Use Coin] ==>  >M  === [Use Coin] ==>  >M  === [Use Coin] ==> > \\n\\n\\n\\n* When you refuel your life using a potion (you must have suffered some damage).\\n\\nAny other object usage is considered **invalid**. Also, this is more or less standard, but you have to walk over an object to pick it up automatically.\\n\\n---------------------\\n\\n# Your task\\n\\nWrite a function `rpg(field: List[List[str]], actions: List[str]) -> Tuple[List[List[str]], int, int, int, List[str]]` that takes the initial state of the game map and a list of actions and returns the new state of the map and the player after executing them in order. All these actions must be valid (no using objects in invalid spots, attacking thin air, going out of bounds, etc), so if any of them turns out not to be valid, return `None`. **Dying counts as an invalid state**.\\n\\nThe order of the elements of the output tuple is: (`new map state`, `health`, `attack`, `defense`, `sorted bag`)\\n\\nThe syntax of the actions is as follows:\\n* `F` to move forward.\\n* `^`, `>`, `v` and `<`to rotate the player.\\n* `A` to attack the enemy you have in front of you.\\n* `C`, `K` and `H` to use a coin, a key and a health potion, respectively.\\n\\n**Technical notes:** \\n* You **can** mutate the input (and probably should), but it is not necessary.\\n* There will only be one Demon Lord per map, but every other tile may be repeated two or even more times.\\n* Only the tiles marked as **[object]** will be stored in your bag (i.e. keys, coins and potions).\\n* Only valid inputs will be given.\\n\\n----------------\\n\\nAs always, I hope you have fun with this kata :)\",\n  \"Ground Truth Solution\": \"def rpg(field, actions):\\n\\tp = Player(field)\\n\\ttry:\\n\\t\\tfor m in actions:\\n\\t\\t\\tif m == 'A':\\n\\t\\t\\t\\tp.attack()\\n\\t\\t\\telif m in 'HCK':\\n\\t\\t\\t\\tp.use(m)\\n\\t\\t\\telif m in '<^>v':\\n\\t\\t\\t\\tp.rotate(m)\\n\\t\\t\\tp.checkDmgsAndAlive()\\n\\t\\t\\tif m == 'F':\\n\\t\\t\\t\\tp.move()\\n\\texcept Exception as e:\\n\\t\\treturn None\\n\\treturn p.state()\\n\\nclass Player:\\n\\tDIRS = dict(list(zip('<>^v', ((0, -1), (0, 1), (-1, 0), (1, 0)))))\\n\\n\\tdef __init__(self, field):\\n\\t\\t(self.h, self.atk, self.d, self.bag, self.xps) = (3, 1, 1, [], 0)\\n\\t\\tself.field = field\\n\\t\\tself.pngs = {}\\n\\t\\tfor (x, r) in enumerate(self.field):\\n\\t\\t\\tfor (y, c) in enumerate(r):\\n\\t\\t\\t\\tif c in self.DIRS:\\n\\t\\t\\t\\t\\t(self.x, self.y, self.c) = (x, y, c)\\n\\t\\t\\t\\t\\t(self.dx, self.dy) = self.DIRS[c]\\n\\t\\t\\t\\telif c == 'D':\\n\\t\\t\\t\\t\\tself.pngs[x, y] = {'h': 10, 'atk': 3}\\n\\t\\t\\t\\telif c == 'E':\\n\\t\\t\\t\\t\\tself.pngs[x, y] = {'h': 1, 'atk': 2}\\n\\t\\t\\t\\telif c == 'M':\\n\\t\\t\\t\\t\\tself.pngs['M'] = {'coins': 3}\\n\\n\\tdef state(self):\\n\\t\\treturn (self.field, self.h, self.atk, self.d, sorted(self.bag))\\n\\n\\tdef rotate(self, c):\\n\\t\\t(self.dx, self.dy) = self.DIRS[c]\\n\\t\\tself.c = self.field[self.x][self.y] = c\\n\\n\\tdef move(self):\\n\\t\\tself.field[self.x][self.y] = ' '\\n\\t\\tself.x += self.dx\\n\\t\\tself.y += self.dy\\n\\t\\tc = self.field[self.x][self.y]\\n\\t\\tassert c not in '#ED-|M' and self.x >= 0 and (self.y >= 0)\\n\\t\\tif c != ' ':\\n\\t\\t\\tself.takeThis(c)\\n\\t\\tself.field[self.x][self.y] = self.c\\n\\n\\tdef checkAhead(self, what):\\n\\t\\t(x, y) = (self.x + self.dx, self.y + self.dy)\\n\\t\\tassert self.field[x][y] in what\\n\\t\\treturn (x, y)\\n\\n\\tdef takeThis(self, c):\\n\\t\\tif c not in 'SX':\\n\\t\\t\\tself.bag.append(c)\\n\\t\\tif c == 'S':\\n\\t\\t\\tself.d += 1\\n\\t\\telif c == 'X':\\n\\t\\t\\tself.atk += 1\\n\\n\\tdef use(self, c):\\n\\t\\tself.bag.remove(c)\\n\\t\\tif c == 'C':\\n\\t\\t\\t(x, y) = self.checkAhead('M')\\n\\t\\t\\tself.pngs['M']['coins'] -= 1\\n\\t\\t\\tif not self.pngs['M']['coins']:\\n\\t\\t\\t\\tself.field[x][y] = ' '\\n\\t\\telif c == 'H':\\n\\t\\t\\tassert self.h < 3\\n\\t\\t\\tself.h = 3\\n\\t\\telif c == 'K':\\n\\t\\t\\t(x, y) = self.checkAhead('|-')\\n\\t\\t\\tself.field[x][y] = ' '\\n\\n\\tdef attack(self):\\n\\t\\t(x, y) = nmy = self.checkAhead('ED')\\n\\t\\tself.pngs[nmy]['h'] -= self.atk\\n\\t\\tif self.pngs[nmy]['h'] < 1:\\n\\t\\t\\tdel self.pngs[nmy]\\n\\t\\t\\tself.field[x][y] = ' '\\n\\t\\t\\t(lvlUp, self.xps) = divmod(self.xps + 1, 3)\\n\\t\\t\\tself.atk += lvlUp\\n\\n\\tdef checkDmgsAndAlive(self):\\n\\t\\tfor (dx, dy) in list(self.DIRS.values()):\\n\\t\\t\\tnmy = (self.x + dx, self.y + dy)\\n\\t\\t\\tif nmy in self.pngs:\\n\\t\\t\\t\\tself.h -= max(0, self.pngs[nmy]['atk'] - self.d)\\n\\t\\t\\t\\tassert self.h > 0\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the game rules: Carefully read through the problem statement to identify the various game mechanics, player stats, map elements, and valid actions.\\n- Defining the game state: The game state consists of the map, player's health, attack, defense, and inventory. Devise a representation to store and update this information.\\n- Implementing action handling: Each action (`F`, `^`, `>`, `v`, `<`, `A`, `C`, `K`, `H`) needs to be translated into a specific set of state changes, subject to validity checks (e.g., not moving into a wall, having an enemy to attack, having the necessary items to use).\\n- Implementing the combat mechanics: When attacking, calculate the damage dealt to the enemy. Handle enemy deaths, experience gain, and level-ups. Implement the opportunity attack mechanic where enemies can attack the player if they move away or use a potion.\\n- Object usage mechanics: Implement the object usage rules for coins, keys, and health potions, including the required conditions and corresponding state changes.\\n- Error handling: Handle invalid actions and player death by returning `None`.\",\n  \"LLM Questions\": [\n    \"How do you represent the game map and player state?\",\n    \"What data structure would be most effective for storing the game map, considering the need to update the board state during each turn?\",\n    \"How would you represent the player's stats (health, attack, defense) and inventory, and how will these stats change during the game?\",\n    \"How do you handle the different actions (`F`, `^`, `>`, `v`, `<`, `A`, `C`, `K`, `H`)?\",\n    \"How do you validate actions to ensure that the player doesn't perform invalid moves or actions, such as moving into a wall or using an item without possessing it?\",\n    \"How do you implement the combat and level up mechanics?\",\n    \"How do you calculate the damage dealt during combat, considering both the player's attack and the enemy's defense?\",\n    \"How do you implement the experience and level-up system when the player defeats enemies?\",\n    \"How do you handle the object usage?\",\n    \"How do you implement the logic for using coins, keys, and health potions, ensuring the correct conditions are met before usage?\",\n    \"What edge cases should be handled?\",\n    \"How do you ensure that the player doesn't go out of bounds or perform actions that result in an invalid game state (e.g., using an item without having it)?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The game map can be represented as a list of lists of strings, and the player state as separate variables for health, attack, defense, and a list for the inventory.\",\n    \"A 2D list or array is suitable for the game map, with each element representing a tile.  This allows easy access and modification of the board state.\",\n    \"Use integers for health, attack, and defense, and a list to store the items in the player's bag. These should be updated appropriately based on the actions performed.\",\n    \"Create a function or method for each action that updates the game state based on the action's effects, including moving the player, changing direction, attacking, or using items.\",\n    \"Implement validation checks at the start of each action's function to ensure that the action can be performed, returning `None` if the action is invalid.\",\n    \"Implement the combat mechanics by calculating damage and updating the enemy's health. When an enemy is defeated, increment the player's experience and potentially trigger a level-up, increasing the player's attack.\",\n    \"The damage dealt is the player's attack minus the enemy's defense, with a minimum damage of 0. `damage = max(0, player_attack - enemy_defense)`.\",\n    \"Keep track of the number of defeated enemies. After every 3 kills, increase the player's attack by 1.\",\n    \"Implement specific logic for each object. For instance, using a coin requires being next to a merchant, using a key requires being next to a door, and using a health potion requires the player to have taken damage.\",\n    \"Implement checks to ensure that the player has the required items and is in the correct position before allowing the usage of the item. For instance, `if 'C' in player.bag and map[player.x + dx][player.y + dy] == 'M': use_coin()`.\",\n    \"Handle cases such as the player running into walls, trying to attack without an enemy in front, attempting to use items without having them, dying (health <= 0), and going out of bounds. Invalid inputs provided to the function should also be considered.\",\n    \"Implement boundary checks for movement and action validation functions to ensure the player stays within the map bounds. Check that actions are only performed when the required conditions are met.\"\n  ]\n}\n```"