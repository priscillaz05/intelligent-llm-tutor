"```json\n{\n  \"Coding Problem\": \"Fox Ciel is playing a card game with her friend Fox Jiro. There are n piles of cards on the table. And there is a positive integer on each card.\\n\\nThe players take turns and Ciel takes the first turn. In Ciel's turn she takes a card from the top of any non-empty pile, and in Jiro's turn he takes a card from the bottom of any non-empty pile. Each player wants to maximize the total sum of the cards he took. The game ends when all piles become empty.\\n\\nSuppose Ciel and Jiro play optimally, what is the score of the game?\\n\\n\\n-----Input-----\\n\\nThe first line contain an integer n (1 \u2264 n \u2264 100). Each of the next n lines contains a description of the pile: the first integer in the line is s_{i} (1 \u2264 s_{i} \u2264 100) \u2014 the number of cards in the i-th pile; then follow s_{i} positive integers c_1, c_2, ..., c_{k}, ..., c_{s}_{i} (1 \u2264 c_{k} \u2264 1000) \u2014 the sequence of the numbers on the cards listed from top of the current pile to bottom of the pile.\\n\\n\\n-----Output-----\\n\\nPrint two integers: the sum of Ciel's cards and the sum of Jiro's cards if they play optimally.\\n\\n\\n-----Examples-----\\nInput\\n2\\n1 100\\n2 1 10\\n\\nOutput\\n101 10\\n\\nInput\\n1\\n9 2 8 6 5 9 4 7 1 3\\n\\nOutput\\n30 15\\n\\nInput\\n3\\n3 1 3 2\\n3 5 4 6\\n2 8 7\\n\\nOutput\\n18 18\\n\\nInput\\n3\\n3 1000 1000 1000\\n6 1000 1000 1000 1000 1000 1000\\n5 1000 1000 1000 1000 1000\\n\\nOutput\\n7000 7000\\n\\n\\n\\n-----Note-----\\n\\nIn the first example, Ciel will take the cards with number 100 and 1, Jiro will take the card with number 10.\\n\\nIn the second example, Ciel will take cards with numbers 2, 8, 6, 5, 9 and Jiro will take cards with numbers 4, 7, 1, 3.\",\n  \"Ground Truth Solution\": \"from functools import reduce\\nn = int(input())\\ncards = [list(map(int, input().split()[1:])) for i in range(n)]\\nmid = sorted((c[len(c) >> 1] for c in cards if len(c) & 1 == 1), reverse=True)\\nadd = lambda x=0, y=0: x + y\\n(a, b) = (reduce(add, mid[::2] or [0]), reduce(add, mid[1::2] or [0]))\\nfor c in cards:\\n\\tm = len(c) >> 1\\n\\ta += reduce(add, c[:m] or [0])\\n\\tb += reduce(add, c[m + (len(c) & 1):] or [0])\\nprint(a, b)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the problem: The problem describes a card game where two players, Ciel and Jiro, take turns picking cards from the top and bottom of multiple piles, respectively. The objective is to determine the optimal scores for each player, assuming both play to maximize their total sum.\\n- Identifying the optimal strategy: For piles with an even number of cards, Ciel takes the top half, and Jiro takes the bottom half. For piles with an odd number of cards, the middle card needs special handling. Ciel and Jiro will compete for the middle cards.\\n- Dealing with odd-sized piles: Sort the middle cards from the odd-sized piles in descending order. Ciel will take the largest, then the third largest, and so on. Jiro will take the second largest, then the fourth largest, and so on.\\n- Implementing the solution: Read the input, process each pile, and keep track of Ciel's and Jiro's scores. Sort the middle cards from odd-sized piles and distribute them appropriately. Sum the scores and print the result.\",\n  \"LLM Questions\": [\n    \"How should the middle cards from piles with odd number of cards be distributed?\",\n    \"How to calculate the total score for Ciel and Jiro?\",\n    \"What edge cases might exist in the given problem?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The middle cards are sorted in descending order, with Ciel taking the largest, then every other card and Jiro taking the remaining middle cards\",\n    \"The total score can be calculated by iterating the cards and assigning the first half to Ciel and the last half to Jiro.\",\n    \"Consider edge cases such as empty piles or piles with only one card.\"\n  ]\n}\n```"