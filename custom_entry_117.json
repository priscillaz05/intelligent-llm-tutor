"```json\n{\n  \"Coding Problem\": \"Vasya had an array of $n$ integers, each element of the array was from $1$ to $n$. He chose $m$ pairs of different positions and wrote them down to a sheet of paper. Then Vasya compared the elements at these positions, and wrote down the results of the comparisons to another sheet of paper. For each pair he wrote either \\\"greater\\\", \\\"less\\\", or \\\"equal\\\".\\n\\nAfter several years, he has found the first sheet of paper, but he couldn't find the second one. Also he doesn't remember the array he had. In particular, he doesn't remember if the array had equal elements. He has told this sad story to his informatics teacher Dr Helen.\\n\\nShe told him that it could be the case that even if Vasya finds his second sheet, he would still not be able to find out whether the array had two equal elements. \\n\\nNow Vasya wants to find two arrays of integers, each of length $n$. All elements of the first array must be distinct, and there must be two equal elements in the second array. For each pair of positions Vasya wrote at the first sheet of paper, the result of the comparison must be the same for the corresponding elements of the first array, and the corresponding elements of the second array. \\n\\nHelp Vasya find two such arrays of length $n$, or find out that there are no such arrays for his sets of pairs.\\n\\n\\n-----Input-----\\n\\nThe first line of input contains two integers $n$, $m$\u00a0\u2014 the number of elements in the array and number of comparisons made by Vasya ($1 \\\\le n \\\\le 100\\,000$, $0 \\\\le m \\\\le 100\\,000$).\\n\\nEach of the following $m$ lines contains two integers $a_i$, $b_i$ \u00a0\u2014 the positions of the $i$-th comparison ($1 \\\\le a_i, b_i \\\\le n$; $a_i \\\\ne b_i$). It's guaranteed that any unordered pair is given in the input at most once.\\n\\n\\n-----Output-----\\n\\nThe first line of output must contain \\\"YES\\\" if there exist two arrays, such that the results of comparisons would be the same, and all numbers in the first one are distinct, and the second one contains at least one pair of equal elements. Otherwise it must contain \\\"NO\\\".\\n\\nIf the arrays exist, the second line must contain the array of distinct integers, the third line must contain the array, that contains at least one pair of equal elements. Elements of the arrays must be integers from $1$ to $n$.\\n\\n\\n-----Examples-----\\nInput\\n1 0\\n\\nOutput\\nNO\\n\\nInput\\n3 1\\n1 2\\n\\nOutput\\nYES\\n1 3 2 \\n1 3 1 \\n\\nInput\\n4 3\\n1 2\\n1 3\\n2 4\\n\\nOutput\\nYES\\n1 3 4 2 \\n1 3 4 1\",\n  \"Ground Truth Solution\": \"(n, m) = map(int, input().split())\\nc = [[0, i, []] for i in range(n)]\\nfor i in range(m):\\n\\t(a, b) = map(int, input().split())\\n\\tc[a - 1][0] += 1\\n\\tc[a - 1][2].append(b - 1)\\n\\tc[b - 1][0] += 1\\n\\tc[b - 1][2].append(a - 1)\\nif n == 1:\\n\\tprint('NO')\\nelse:\\n\\tans = n * (n - 1) // 2\\n\\tif m >= ans:\\n\\t\\tprint('NO')\\n\\telse:\\n\\t\\tc.sort(key=lambda x: x[0])\\n\\t\\tvall = c[0][1]\\n\\t\\tc[0][2].append(vall)\\n\\t\\tc[0][2].sort()\\n\\t\\tfinal = -1\\n\\t\\tfor i in range(len(c[0][2])):\\n\\t\\t\\tif c[0][2][i] != i and i != vall:\\n\\t\\t\\t\\tfinal = i\\n\\t\\t\\t\\tbreak\\n\\t\\tif final == -1:\\n\\t\\t\\tfinal = len(c[0][2])\\n\\t\\tprint('YES')\\n\\t\\tflag = True\\n\\t\\ts1 = ''\\n\\t\\ts2 = ''\\n\\t\\tval = 1\\n\\t\\ttemp = min(vall, final)\\n\\t\\ttemp2 = max(vall, final)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif i == temp:\\n\\t\\t\\t\\ts1 += str(n) + ' '\\n\\t\\t\\t\\ts2 += str(n) + ' '\\n\\t\\t\\telif i == temp2:\\n\\t\\t\\t\\ts1 += str(n - 1) + ' '\\n\\t\\t\\t\\ts2 += str(n) + ' '\\n\\t\\t\\telse:\\n\\t\\t\\t\\ts1 += str(val) + ' '\\n\\t\\t\\t\\ts2 += str(val) + ' '\\n\\t\\t\\t\\tval += 1\\n\\t\\tprint(s1[:-1])\\n\\t\\tprint(s2[:-1])\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires constructing two arrays of length 'n' based on 'm' comparisons between array elements at specific positions. The first array must have distinct elements, while the second must contain at least two equal elements. Both arrays must satisfy the given comparison results.\\n- Identifying Edge Cases: The most important edge case is when n = 1 since there can't be two distinct elements.\\n- Algorithmic Strategy: It is not required to generate all possible arrays, but rather to find out if such arrays exist, and generate any such arrays to prove it exists. Consider that if there are too many comparisons, such arrays may not exist. This is because with n elements, there are n*(n-1)/2 possible comparisons. If m >= n*(n-1)/2, then no such array can be made.\\n- Implementation Details: The implementation must first check if the edge case n=1 holds true, or if there are too many comparisons. Otherwise, the comparisons must be handled in order to create both arrays. The approach used in the solution sorts by the number of connections, which determines the values assigned in s1 and s2. Note that the positions where the first comparison occurs dictate the array values.\",\n  \"LLM Questions\": [\n    \"What is the relationship between the number of elements 'n' and the number of comparisons 'm' in determining the existence of the arrays?\",\n    \"How can you determine if it's impossible to create the two arrays based on the number of comparisons?\",\n    \"What is the impact of the condition that the first array must have distinct elements while the second array must have at least two equal elements?\",\n    \"How does the solution handle the comparisons to ensure that both arrays satisfy the same comparison results?\",\n    \"What is the significance of sorting the array elements by their number of comparisons, and how does it simplify array construction?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The number of comparisons 'm' must be less than n*(n-1)/2 to guarantee the existence of two arrays satisfying the specified conditions.\",\n    \"If 'm' is greater than or equal to n*(n-1)/2, there are too many constraints, making it impossible to construct such arrays, and the output should be 'NO'.\",\n    \"The distinct elements requirement in the first array and the equal elements requirement in the second array impose constraints on the element assignment and create the distinction between these arrays.\",\n    \"The comparisons dictate how the elements in both arrays relate to each other, preserving the 'greater', 'less', or 'equal' relationship for corresponding positions.\",\n    \"Sorting by the number of comparisons helps find the elements with fewer constraints, allowing them to be manipulated more easily when generating arrays with distinct or equal elements while adhering to the comparison constraints.\"\n  ]\n}\n```"