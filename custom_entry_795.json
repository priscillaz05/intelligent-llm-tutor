"```json\n{\n  \"Coding Problem\": \"Mike has always been thinking about the harshness of social inequality. He's so obsessed with it that sometimes it even affects him while solving problems. At the moment, Mike has two sequences of positive integers A = [a1, a2, ..., an] and B = [b1, b2, ..., bn] of length n each which he uses to ask people some quite peculiar questions.\\n\\nTo test you on how good are you at spotting inequality in life, he wants you to find an \\\"unfair\\\" subset of the original sequence. To be more precise, he wants you to select k numbers P = [p1, p2, ..., pk] such that 1 \u2264 pi \u2264 n for 1 \u2264 i \u2264 k and elements in P are distinct. Sequence P will represent indices of elements that you'll select from both sequences. He calls such a subset P \\\"unfair\\\" if and only if the following conditions are satisfied: 2\u00b7(ap1 + ... + apk) is greater than the sum of all elements from sequence A, and 2\u00b7(bp1 + ... + bpk) is greater than the sum of all elements from the sequence B. Also, k should be smaller or equal to <image> because it will be to easy to find sequence P if he allowed you to select too many elements!\\n\\nMike guarantees you that a solution will always exist given the conditions described above, so please help him satisfy his curiosity!\\n\\nInput\\n\\nThe first line contains integer n (1 \u2264 n \u2264 105) \u2014 the number of elements in the sequences. \\n\\nOn the second line there are n space-separated integers a1, ..., an (1 \u2264 ai \u2264 109) \u2014 elements of sequence A.\\n\\nOn the third line there are also n space-separated integers b1, ..., bn (1 \u2264 bi \u2264 109) \u2014 elements of sequence B.\\n\\nOutput\\n\\nOn the first line output an integer k which represents the size of the found subset. k should be less or equal to <image>.\\n\\nOn the next line print k integers p1, p2, ..., pk (1 \u2264 pi \u2264 n) \u2014 the elements of sequence P. You can print the numbers in any order you want. Elements in sequence P should be distinct.\\n\\nExample\\n\\nInput\\n\\n5\\n8 7 4 8 3\\n4 2 5 3 7\\n\\n\\nOutput\\n\\n3\\n1 4 5\",\n  \"Ground Truth Solution\": \"n = int(input())\\nA = [int(x) for x in input().split()]\\nB = [int(x) for x in input().split()]\\nidAB = zip(range(n), A, B)\\nidAB = sorted(idAB, key=lambda x: x[1], reverse=True)\\nans = [idAB[0][0] + 1]\\ni = 1\\nwhile i < n:\\n\\tchoice = max(idAB[i:i + 2], key=lambda x: x[2])\\n\\tans.append(choice[0] + 1)\\n\\ti += 2\\nans = sorted(ans)\\nprint(len(ans))\\nprint(*ans)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires finding a subset of indices `P` from two arrays `A` and `B` such that twice the sum of elements at those indices in `A` is greater than the sum of all elements in `A`, and similarly for `B`. The size of `P` must be less than or equal to `ceil(n/2)`.\\n- Algorithmic Strategy: A greedy approach can be used. First, find the index with the maximum value in array A. Then, iterate through the remaining indices, adding pairs of indices, and choose the index from that pair with the larger corresponding value in array B. This increases the total sum for B more quickly. Alternatively, take only the largest element from array A and ensure it satisfies the condition. If it doesn't, keep adding elements that maximize the sum of array B until the conditions are met, all while satisfying the k <= ceil(n/2) constraint.\\n- Implementation Details: Input the values of n, A, and B. Calculate the sums of A and B. Sort indices based on values in A in descending order. Create a subset of indices by starting with the index of the maximum A value. From the remaining indices, include pairs, prioritizing elements that maximize the B-sum until both unfairness conditions are met.\\n- Optimization Considerations: Given the guarantee that a solution exists, the first element with the maximum A value along with the highest corresponding B value may already satisfy the condition.\",\n  \"LLM Questions\": [\n    \"What does it mean for a subset `P` to be considered 'unfair', and what conditions must be satisfied?\",\n    \"Given that the problem guarantees a solution exists, what's a quick and easy way to ensure a subset satisfies the first condition regarding array `A`?\",\n    \"How can you effectively prioritize indices to maximize the sum of array `B` in relation to array `A` when selecting elements for `P`?\",\n    \"What is the constraint for the size `k` of the subset `P`, and how does this limitation impact the selection strategy?\",\n    \"How should you handle input and output, and what needs to be printed on the first and second lines of the output?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"For a subset `P` to be 'unfair', twice the sum of `A` at indices in `P` must be greater than the total sum of `A`, and similarly for `B`. In mathematical terms, 2 * sum(A[p_i]) > sum(A) and 2 * sum(B[p_i]) > sum(B).\",\n    \"The simplest approach is to pick the index with the largest value in `A`. This usually gets us close to satisfying the first condition. You can then add more indices until the condition is met.\",\n    \"Prioritize including indices that contribute the most to the sum of B. One strategy is to consider elements in pairs from indices that have not been chosen yet, and include the index with the higher B value.\",\n    \"The size `k` of the subset `P` must be less than or equal to `ceil(n/2)`. This constraint limits the number of elements you can include, so selection has to be strategic to maximize the sums while staying within the size limit.\",\n    \"On the first line, print the integer `k` representing the size of subset `P`. On the second line, print `k` space-separated integers representing the selected indices `p1, p2, ..., pk`. The indices should be 1-based, as indicated in the problem statement.\"\n  ]\n}\n```"