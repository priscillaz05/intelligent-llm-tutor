"```json\n{\n  \"Coding Problem\": \"Little penguin Polo likes permutations. But most of all he likes permutations of integers from 0 to n, inclusive.\\n\\nFor permutation p = p_0, p_1, ..., p_{n}, Polo has defined its beauty \u2014 number $(0 \\\\oplus p_{0}) +(1 \\\\oplus p_{1}) + \\\\cdots +(n \\\\oplus p_{n})$.\\n\\nExpression $x \\\\oplus y$ means applying the operation of bitwise excluding \\\"OR\\\" to numbers x and y. This operation exists in all modern programming languages, for example, in language C++ and Java it is represented as \\\"^\\\" and in Pascal \u2014 as \\\"xor\\\".\\n\\nHelp him find among all permutations of integers from 0 to n the permutation with the maximum beauty.\\n\\n\\n-----Input-----\\n\\nThe single line contains a positive integer n (1 \u2264 n \u2264 10^6).\\n\\n\\n-----Output-----\\n\\nIn the first line print integer m the maximum possible beauty. In the second line print any permutation of integers from 0 to n with the beauty equal to m.\\n\\nIf there are several suitable permutations, you are allowed to print any of them.\\n\\n\\n-----Examples-----\\nInput\\n4\\n\\nOutput\\n20\\n0 2 1 4 3\",\n  \"Ground Truth Solution\": \"s = n = int(input()) + 1\\n(t, r) = ([], list(range(n))[::-1])\\nk = 2 ** 20\\nwhile s:\\n\\twhile k >= 2 * s:\\n\\t\\tk //= 2\\n\\tt = r[n - s:n + s - k] + t\\n\\ts = k - s\\nprint(n * n - n)\\nprint(' '.join(map(str, t)))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks to find a permutation of numbers from 0 to n that maximizes the sum of the bitwise XOR operation between each index i and the value at that index p_i.\\n- Identifying Key Idea: The key insight is that to maximize the beauty, we should pair numbers i and p_i such that i ^ p_i is maximized. This generally means pairing numbers that have different leading bits.\\n- Algorithmic Strategy: We can iterate from n down to 0. For each number i, find the largest number j (<= n) such that i ^ j is maximized.  Since we need a permutation, we need to ensure that j has not been used previously. An optimal approach is pairing i with `i ^ k` where k is the largest power of 2 such that `i ^ k` is within the range [0, n] and has not been used yet.\\n- Data structures: Keep track of the used numbers in a set. Create a list to store the generated permutation.\\n- Implementation Detail: Calculate the maximum beauty by summing i ^ p_i for each i. Print the total beauty and the permutation.\",\n  \"LLM Questions\": [\n    \"How can we maximize the beauty of the permutation, and what does 'beauty' mean in this context?\",\n    \"What data structure can we use to efficiently keep track of which numbers have already been used in the permutation?\",\n    \"How do we find the optimal pairing for a given number i to maximize the XOR sum, and what is the range constraint?\",\n    \"How can the calculated beauty be verified?\",\n    \"How does the algorithm account for cases when a suitable 'xor partner' has already been used in the permutation?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The beauty of the permutation is the sum of (i XOR p_i) for each index i from 0 to n. To maximize this sum, we want to pair each number i with another number p_i such that their XOR is as large as possible.\",\n    \"A set can be used to efficiently check if a number has been used in O(1) time complexity.\",\n    \"For each number i, we want to find the largest power of 2, k, such that (i XOR k) is in the range [0, n] and is not already used in the permutation. The optimal pairing would be i XOR k.\",\n    \"The beauty can be verified by summing (i XOR p_i) for all i in the permutation and comparing with the expected result.\",\n    \"If the 'xor partner' has already been used, the algorithm can either iterate down powers of 2 to find a suitable partner, or it can maintain a separate pool of unused numbers and select a partner from that pool.\"\n  ]\n}\n```"