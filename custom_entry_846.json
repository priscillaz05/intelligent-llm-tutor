"```json\n{\n  \"Coding Problem\": \"The year is 2088 and the Radical Marxist Socialist People's Party (RMSPP) has just seized power in Brazil.\\n\\nTheir first act in power is absolute wealth equality through coercive redistribution.\\n\\nCreate a function that redistributes all wealth equally among all citizens.\\n\\nWealth is represented as an array/list where every index is the wealth of a single citizen. The function should mutate the input such that every index has the same amount of wealth. **MUTATE the input array/list, don't return anything.**\\n\\nSee example:\\n\\n```python\\nwealth = [5, 10, 6]  # This represents:\\n                     # citizen 1 has wealth 5\\n                     # citizen 2 has wealth 10\\n                     # citizen 3 has wealth 6\\n                     \\nredistribute_wealth(wealth) # mutates wealth list\\nwealth => [7, 7, 7] # wealth has now been equally redistributed\\n\\n```\\n\\nInfo:\\n\\n- **MUTATE the input array/list, don't return anything**\\n\\n- Input is garantueed to hold at least 1 or more citizens\\n\\n- Wealth of citizen will an integer with minimum 0 (negative wealth not possible)\\n\\n- Handling of floating point error will not be tested\",\n  \"Ground Truth Solution\": \"def redistribute_wealth(wealth):\\n\\twealth[:] = [sum(wealth) / len(wealth)] * len(wealth)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires redistributing wealth equally among citizens represented by a list of integers. The key is to calculate the average wealth and update each element in the list to this average.\\n- Identifying Constraints: The primary constraint is to mutate the original list in-place and not return a new list. The wealth of each citizen is non-negative.\\n- Selecting an Algorithmic Strategy: Calculate the total wealth by summing all elements in the list. Divide this total wealth by the number of citizens (the length of the list) to find the average wealth. Then, update each element in the list to this average wealth.\\n- Implementation Details: Using the slice assignment `wealth[:] = ...` ensures that the original list is modified in-place. The `[average_wealth] * len(wealth)` creates a new list with each element being the average wealth which is then assigned to the slice.\",\n  \"LLM Questions\": [\n    \"What does it mean to mutate the list in-place, and why is this crucial for the problem?\",\n    \"How do you calculate the average wealth given the list of wealth for each citizen?\",\n    \"Can you explain how slice assignment works and why it's used for in-place modification?\",\n    \"What edge cases, if any, do you need to consider given the problem's constraints?\",\n    \"What would be the result if the input array contained [1, 2, 3, 4, 5]?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Mutating the list in-place means modifying the original list directly without creating a new list. This is crucial because the problem explicitly requires that the input list is modified directly and no value is returned.\",\n    \"The average wealth is calculated by summing up the wealth of all citizens (all elements in the list) and dividing it by the total number of citizens (the length of the list).\",\n    \"Slice assignment `wealth[:] = ...` replaces all the elements in the original list with the elements from the right-hand side. It's used because it modifies the list in place rather than creating a new list.\",\n    \"Given the problem constraints, there are no real edge cases to consider. The problem states that the input list will always have at least one citizen, and the wealth of each citizen will be a non-negative integer.\",\n    \"The sum of the array would be 15. 15 / 5 = 3. The array would become [3, 3, 3, 3, 3]\"\n  ]\n}\n```"