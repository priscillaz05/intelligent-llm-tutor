"```json\n{\n  \"Coding Problem\": \"Read problems statements in Mandarin chinese, Russian and Vietnamese as well. \\n\\nChef is working at his dream workplace with $N-1$ of his friends! Like any dream workplace, this one also has dream work conditions. To ensure absolute happiness of the employees, there are the following rules at the company:\\nEach worker works on exactly one day! You heard it right: no more, no less.\\nOn each day, at most one worker may work. This provides the perfect work conditions: no crowd, just the work and you.\\nEvery worker has a *deadline*; let's denote the deadline of the $i$-th worker by $d_{i}$. (This means that the day on which the $i$-th worker works must not be later than day $d_{i}$; the days are numbered starting from $1$.) You thought there weren't any limitations, eh?\\n\\nHowever, sooner or later, all dream workplaces have to fall. The CLO (Chefland Labour Office) demands that there should be exactly $C$ ways to schedule the work such that the above conditions are fulfilled. Two schedulings are different if there is an employee that works at different days in these schedulings.\\n\\nChef is asking for your help, since he can't spare any workdays at this company. You should find a sequence of employees' deadlines $d_{1} \u2264 d_{2} \u2264 \\\\dots \u2264 d_{N}$ such that there are exactly $C$ ways to schedule the work. If there are multiple sequences satisfying this condition, do another little favour for Chef: minimise $d_{N}$ (his deadline).\\n\\n------  Input ------\\nThe first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\\nThe first and only line of each test case contains two space-separated integers $N$ and $C$. \\n\\n------  Output ------\\nFor each test case, print a single line containing $N$ space-separated integers $d_{1}, d_{2}, \\\\dots, d_{N}$ that describe your chosen sequence. If there are multiple sequences satisfying all conditions, you may output any one.\\n\\n------  Constraints ------\\n$1 \u2264 T \u2264 100$\\nthe sum of $N$ over all test cases does not exceed $10^{7}$\\n$1 \u2264 C \u2264 10^{9}$\\n\\n------  Subtasks ------\\nSubtask #1 (10 points):\\n$1 \u2264 N \u2264 10$\\n$1 \u2264 C \u2264 100$\\n\\nSubtask #2 (20 points): $1 \u2264 N \u2264 100$\\n\\nSubtask #3 (70 points): $1 \u2264 N \u2264 10^{6}$\\n\\n----- Sample Input 1 ------ \\n1\\n2 12\\n----- Sample Output 1 ------ \\n4 4\\n----- explanation 1 ------ \\nExample case 1: Each worker can work on any day from day $1$ to day $4$. The 12 possible schedulings (pairs of days on which they work) are $[1, 2]$, $[1, 3]$, $[1, 4]$, $[2, 3]$, $[2, 4]$, $[3, 4]$, $[2, 1]$, $[3, 1]$, $[4, 1]$, $[3, 2]$, $[4, 2]$, $[4, 3]$.\",\n  \"Ground Truth Solution\": \"from sys import stdin, stdout\\n\\ndef calc(c, y):\\n\\tif 1 < c <= y:\\n\\t\\treturn [c]\\n\\tB = []\\n\\tz = 2\\n\\twhile z * z <= c:\\n\\t\\tif c % z == 0 and 1 < c // z <= y:\\n\\t\\t\\tB.append(c // z)\\n\\t\\t\\tB.append(z)\\n\\t\\t\\tc = 1\\n\\t\\t\\tbreak\\n\\t\\tz += 1\\n\\twhile z >= 2 and c > 1:\\n\\t\\tif c % z == 0 and 1 < z <= y:\\n\\t\\t\\twhile c % z == 0 and c > y:\\n\\t\\t\\t\\tB.append(z)\\n\\t\\t\\t\\tc //= z\\n\\t\\tif 1 < c <= y:\\n\\t\\t\\tB.append(c)\\n\\t\\t\\tc = 1\\n\\t\\t\\tbreak\\n\\t\\tz -= 1\\n\\tif c > 1:\\n\\t\\treturn None\\n\\treturn sorted(B)\\n\\ndef solve(c, x, n):\\n\\ty = x\\n\\tA = []\\n\\twhile c % y == 0:\\n\\t\\tc //= y\\n\\t\\tA.append(y)\\n\\t\\tB = calc(c, y)\\n\\t\\tif B is not None:\\n\\t\\t\\tX = sorted(B) + A[::-1]\\n\\t\\t\\tm = len(X)\\n\\t\\t\\tif m <= n:\\n\\t\\t\\t\\tres = [1] * (n - m) + X\\n\\t\\t\\t\\treturn [e + i for (i, e) in enumerate(res)]\\n\\t\\ty += 1\\n\\treturn None\\n\\ndef main():\\n\\tt = stdin.readline()\\n\\tt = int(t)\\n\\twhile t > 0:\\n\\t\\t(n, c) = map(int, stdin.readline().split())\\n\\t\\tx = 1\\n\\t\\tans = None\\n\\t\\twhile x * x <= c:\\n\\t\\t\\tif c % x == 0:\\n\\t\\t\\t\\tres = solve(c, x, n)\\n\\t\\t\\t\\tif res is not None:\\n\\t\\t\\t\\t\\tans = res\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tx += 1\\n\\t\\telse:\\n\\t\\t\\twhile x >= 1:\\n\\t\\t\\t\\tif c % x == 0:\\n\\t\\t\\t\\t\\tres = solve(c, c // x, n)\\n\\t\\t\\t\\t\\tif res is not None:\\n\\t\\t\\t\\t\\t\\tans = res\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tx -= 1\\n\\t\\tprint(' '.join(map(str, ans)))\\n\\t\\tt = t - 1\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires finding a sequence of deadlines for N workers such that there are exactly C ways to schedule their work, adhering to specific constraints: each worker works on exactly one day, at most one worker works on each day, and each worker's work day must not exceed their deadline.\\n- Identifying Constraints and Edge Cases: Key constraints include the non-exceedance of deadlines, the number of workers, and the target scheduling count. Edge cases need consideration in the form of C being small or large relative to N, influencing the assignment of deadlines.\\n- Devising a Strategy: A possible approach involves finding factors of C that could represent the ranges of the deadlines. Minimize the largest deadline $d_N$ while ensuring the total number of valid schedules equals C. This requires potentially distributing the multiplicative components of C among workers, starting with the smallest possible values for deadlines.\\n- Developing Algorithmic Details: First check trivial cases (e.g., if C == 1). Then, attempt to express C as a product of numbers related to the workers' deadlines. Given $d_1 <= d_2 <= ... <= d_N$, if all deadlines were the same, the number of ways to schedule is combinations of the form $d_n$ choose n. If the deadlines are different factors need to be carefully constructed so that exactly C arrangements occur.\\n- Implementation Details: The solution needs to output a sequence of deadlines such that their product, related to the combination formula mentioned earlier, leads to C possible schedules. We attempt to factorize C and distribute these factors among the worker deadlines. If factorization fails, we may need more complex logic for assigning deadlines.\",\n  \"LLM Questions\": [\n    \"What are the key constraints in this problem, and how do they influence the possible solutions?\",\n    \"How does the relationship between N (number of workers) and C (number of ways to schedule) affect the complexity of finding a solution?\",\n    \"Can you describe a strategy for assigning deadlines such that we minimize the largest deadline while ensuring the total number of schedules is exactly C?\",\n    \"What are some edge cases that might require special handling, and how should those cases be addressed?\",\n    \"Given N and C, what mathematical relationships or factorizations should we look for to determine the optimal sequence of deadlines?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Key constraints include each worker working on one day, at most one worker working per day, and work happening before or on the deadline. These constraints limit possible deadline assignments and influence the complexity of calculating the valid schedules.\",\n    \"The relationship between N and C dictates the method of solution. If C is relatively small compared to N, simpler solutions involving smaller deadlines might suffice. Larger C values may need larger or more varied deadlines.\",\n    \"A useful strategy involves expressing C as a product of integers related to the worker deadlines. We want to minimize the largest deadline, so we should attempt to distribute the factors of C among the deadlines as evenly as possible, starting with smaller values.\",\n    \"Edge cases include C = 1, where all deadlines can be 1, or C > some maximum value given n workers - which would indicate an error. Also the case when N=1 and C can be any valid deadline.\",\n    \"We should look for ways to express C as a combination or product of N integers, each corresponding to a worker's deadline incremented by its index. The goal is to find a combination where the resulting sequence minimizes the last element (dn) while adhering to the constraints of sorted order (d1 <= d2 <= ... <= dn).\"\n  ]\n}\n```"