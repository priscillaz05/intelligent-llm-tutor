"```json\n{\n  \"Coding Problem\": \"Recall that MEX of an array is a minimum non-negative integer that does not belong to the array. Examples:  for the array $[0, 0, 1, 0, 2]$ MEX equals to $3$ because numbers $0, 1$ and $2$ are presented in the array and $3$ is the minimum non-negative integer not presented in the array;  for the array $[1, 2, 3, 4]$ MEX equals to $0$ because $0$ is the minimum non-negative integer not presented in the array;  for the array $[0, 1, 4, 3]$ MEX equals to $2$ because $2$ is the minimum non-negative integer not presented in the array. \\n\\nYou are given an empty array $a=[]$ (in other words, a zero-length array). You are also given a positive integer $x$.\\n\\nYou are also given $q$ queries. The $j$-th query consists of one integer $y_j$ and means that you have to append one element $y_j$ to the array. The array length increases by $1$ after a query.\\n\\nIn one move, you can choose any index $i$ and set $a_i := a_i + x$ or $a_i := a_i - x$ (i.e. increase or decrease any element of the array by $x$). The only restriction is that $a_i$ cannot become negative. Since initially the array is empty, you can perform moves only after the first query.\\n\\nYou have to maximize the MEX (minimum excluded) of the array if you can perform any number of such operations (you can even perform the operation multiple times with one element).\\n\\nYou have to find the answer after each of $q$ queries (i.e. the $j$-th answer corresponds to the array of length $j$).\\n\\nOperations are discarded before each query. I.e. the array $a$ after the $j$-th query equals to $[y_1, y_2, \\\\dots, y_j]$.\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains two integers $q, x$ ($1 \\\\le q, x \\\\le 4 \\\\cdot 10^5$) \u2014 the number of queries and the value of $x$.\\n\\nThe next $q$ lines describe queries. The $j$-th query consists of one integer $y_j$ ($0 \\\\le y_j \\\\le 10^9$) and means that you have to append one element $y_j$ to the array.\\n\\n\\n-----Output-----\\n\\nPrint the answer to the initial problem after each query \u2014 for the query $j$ print the maximum value of MEX after first $j$ queries. Note that queries are dependent (the array changes after each query) but operations are independent between queries.\\n\\n\\n-----Examples-----\\nInput\\n7 3\\n0\\n1\\n2\\n2\\n0\\n0\\n10\\n\\nOutput\\n1\\n2\\n3\\n3\\n4\\n4\\n7\\n\\nInput\\n4 3\\n1\\n2\\n1\\n2\\n\\nOutput\\n0\\n0\\n0\\n0\\n\\n\\n-----Note-----\\n\\nIn the first example:  After the first query, the array is $a=[0]$: you don't need to perform any operations, maximum possible MEX is $1$.  After the second query, the array is $a=[0, 1]$: you don't need to perform any operations, maximum possible MEX is $2$.  After the third query, the array is $a=[0, 1, 2]$: you don't need to perform any operations, maximum possible MEX is $3$.  After the fourth query, the array is $a=[0, 1, 2, 2]$: you don't need to perform any operations, maximum possible MEX is $3$ (you can't make it greater with operations).  After the fifth query, the array is $a=[0, 1, 2, 2, 0]$: you can perform $a[4] := a[4] + 3 = 3$. The array changes to be $a=[0, 1, 2, 2, 3]$. Now MEX is maximum possible and equals to $4$.  After the sixth query, the array is $a=[0, 1, 2, 2, 0, 0]$: you can perform $a[4] := a[4] + 3 = 0 + 3 = 3$. The array changes to be $a=[0, 1, 2, 2, 3, 0]$. Now MEX is maximum possible and equals to $4$.  After the seventh query, the array is $a=[0, 1, 2, 2, 0, 0, 10]$. You can perform the following operations:   $a[3] := a[3] + 3 = 2 + 3 = 5$,  $a[4] := a[4] + 3 = 0 + 3 = 3$,  $a[5] := a[5] + 3 = 0 + 3 = 3$,  $a[5] := a[5] + 3 = 3 + 3 = 6$,  $a[6] := a[6] - 3 = 10 - 3 = 7$,  $a[6] := a[6] - 3 = 7 - 3 = 4$.  The resulting array will be $a=[0, 1, 2, 5, 3, 6, 4]$. Now MEX is maximum possible and equals to $7$.\",\n  \"Ground Truth Solution\": \"import sys\\nfrom sys import stdin, stdout\\nimport bisect\\nimport math\\nimport heapq\\n\\ndef modinv(n, p):\\n\\treturn pow(n, p - 2, p)\\n\\ndef cin():\\n\\treturn map(int, sin().split())\\n\\ndef ain():\\n\\treturn list(map(int, sin().split()))\\n\\ndef sin():\\n\\treturn input()\\n\\ndef inin():\\n\\treturn int(input())\\nimport math\\n\\ndef Divisors(n):\\n\\tl = []\\n\\tfor i in range(1, int(math.sqrt(n) + 1)):\\n\\t\\tif n % i == 0:\\n\\t\\t\\tif n // i == i:\\n\\t\\t\\t\\tl.append(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tl.append(i)\\n\\t\\t\\t\\tl.append(n // i)\\n\\treturn l\\n\\ndef main():\\n\\t(n, k) = cin()\\n\\ty = [-1] * k\\n\\tx = [0] * (n + 2)\\n\\tj = 0\\n\\tfor i in range(n):\\n\\t\\tp = inin()\\n\\t\\tp = p % k\\n\\t\\ty[p] += 1\\n\\t\\tif y[p] * k + p <= n:\\n\\t\\t\\tx[y[p] * k + p] = 1\\n\\t\\twhile x[j] != 0:\\n\\t\\t\\tj += 1\\n\\t\\tprint(j)\\npy2 = round(0.5)\\nif py2:\\n\\tfrom future_builtins import ascii, filter, hex, map, oct, zip\\n\\trange = xrange\\nimport os, sys\\nfrom io import IOBase, BytesIO\\nBUFSIZE = 8192\\n\\nclass FastIO(BytesIO):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._file = file\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.writable = 'x' in file.mode or 'w' in file.mode\\n\\t\\tself.write = super(FastIO, self).write if self.writable else None\\n\\n\\tdef _fill(self):\\n\\t\\ts = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\tself.seek((self.tell(), self.seek(0, 2), super(FastIO, self).write(s))[0])\\n\\t\\treturn s\\n\\n\\tdef read(self):\\n\\t\\twhile self._fill():\\n\\t\\t\\tpass\\n\\t\\treturn super(FastIO, self).read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\ts = self._fill()\\n\\t\\t\\tself.newlines = s.count(b'\\\\n') + (not s)\\n\\t\\tself.newlines -= 1\\n\\t\\treturn super(FastIO, self).readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.getvalue())\\n\\t\\t\\t(self.truncate(0), self.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tif py2:\\n\\t\\t\\tself.write = self.buffer.write\\n\\t\\t\\tself.read = self.buffer.read\\n\\t\\t\\tself.readline = self.buffer.readline\\n\\t\\telse:\\n\\t\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nimport sys\\n\\nclass ostream:\\n\\n\\tdef __lshift__(self, a):\\n\\t\\tsys.stdout.write(str(a))\\n\\t\\treturn self\\ncout = ostream()\\nendl = '\\\\n'\\n\\ndef readnumbers(zero=0):\\n\\tconv = ord if py2 else lambda x: x\\n\\tA = []\\n\\tnumb = zero\\n\\tsign = 1\\n\\ti = 0\\n\\ts = sys.stdin.buffer.read()\\n\\ttry:\\n\\t\\twhile True:\\n\\t\\t\\tif s[i] >= b'0'[0]:\\n\\t\\t\\t\\tnumb = 10 * numb + conv(s[i]) - 48\\n\\t\\t\\telif s[i] == b'-'[0]:\\n\\t\\t\\t\\tsign = -1\\n\\t\\t\\telif s[i] != b'\\\\r'[0]:\\n\\t\\t\\t\\tA.append(sign * numb)\\n\\t\\t\\t\\tnumb = zero\\n\\t\\t\\t\\tsign = 1\\n\\t\\t\\ti += 1\\n\\texcept:\\n\\t\\tpass\\n\\tif s and s[-1] >= b'0'[0]:\\n\\t\\tA.append(sign * numb)\\n\\treturn A\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires finding the maximum achievable MEX of an array after each query.  A key operation is adding or subtracting 'x' from any element any number of times, with the constraint that elements cannot become negative.\\n- Identifying Core Concepts: The MEX concept is essential: find the smallest non-negative integer not present in the array. The operation involving 'x' allows numbers to be converted to equivalent values modulo x.\\n- Devising a Strategy:  Maintain a count of how many numbers have a specific remainder when divided by x. Iterate through the queries, and for each query, append the new number.  Calculate the remainder of the new number when divided by x. Increment the count of that remainder. Increment a 'current_mex' by 1 at each step until a missing number is found. The missing number will have the same remainder as current_mex when divided by x.\\n- Handling Constraints: Array elements can only be increased or decreased by x, not creating new elements.  The task is to maximize MEX using x operations at any step.\",\n  \"LLM Questions\": [\n    \"What does it mean to maximize the MEX of the array, and how does the operation of adding or subtracting 'x' influence it?\",\n    \"How can the modulo operator help simplify the determination of whether a specific MEX value is achievable?\",\n    \"What data structure would be suitable for keeping track of the count of numbers that have certain remainders when divided by x?\",\n    \"How do you determine when to increment the current MEX during query processing?\",\n    \"What are the edge cases to consider when array elements are only allowed to change by multiples of x and must remain non-negative?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Maximizing MEX means finding the largest possible minimum excluded non-negative integer. The operation allows array elements to be manipulated to create missing non-negative integers.\",\n    \"The modulo operator identifies numbers that, by using the +x or -x operations, can become equivalent to another number with the same remainder. For example, if x = 3, then 10 % 3 == 1. Thus, 10 can become 1 by subtracting 3 three times.\",\n    \"An array or a dictionary can efficiently track the count of numbers that have certain remainders when divided by x, where the remainder is the key and the count is the value.\",\n    \"Increment the 'current_mex' as long as a number with remainder current_mex % x is present in the array (i.e., its count is greater than 0).\",\n    \"We need to consider cases where the number cannot be made negative by subtracting x any number of times. Also, consider cases where MEX could be 0.\"\n  ]\n}\n```"