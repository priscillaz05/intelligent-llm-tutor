"```json\n{\n  \"Coding Problem\": \"To improve the boomerang throwing skills of the animals, Zookeeper has set up an $n \\\\times n$ grid with some targets, where each row and each column has at most $2$ targets each. The rows are numbered from $1$ to $n$ from top to bottom, and the columns are numbered from $1$ to $n$ from left to right. \\n\\n For each column, Zookeeper will throw a boomerang from the bottom of the column (below the grid) upwards. When the boomerang hits any target, it will bounce off, make a $90$ degree turn to the right and fly off in a straight line in its new direction. The boomerang can hit multiple targets and does not stop until it leaves the grid.\\n\\n  [Image] \\n\\nIn the above example, $n=6$ and the black crosses are the targets. The boomerang in column $1$ (blue arrows) bounces $2$ times while the boomerang in column $3$ (red arrows) bounces $3$ times.\\n\\n The boomerang in column $i$ hits exactly $a_i$ targets before flying out of the grid. It is known that $a_i \\\\leq 3$.\\n\\nHowever, Zookeeper has lost the original positions of the targets. Thus, he asks you to construct a valid configuration of targets that matches the number of hits for each column, or tell him that no such configuration exists. If multiple valid configurations exist, you may print any of them.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $n$ $(1 \\\\leq n \\\\leq 10^5)$.\\n\\n The next line contains $n$ integers $a_1,a_2,\\\\ldots,a_n$ $(0 \\\\leq a_i \\\\leq 3)$.\\n\\n\\n-----Output-----\\n\\nIf no configuration of targets exist, print $-1$.\\n\\n Otherwise, on the first line print a single integer $t$ $(0 \\\\leq t \\\\leq 2n)$: the number of targets in your configuration. \\n\\n Then print $t$ lines with two spaced integers each per line. Each line should contain two integers $r$ and $c$ $(1 \\\\leq r,c \\\\leq n)$, where $r$ is the target's row and $c$ is the target's column. All targets should be different. \\n\\n Every row and every column in your configuration should have at most two targets each. \\n\\n\\n-----Examples-----\\nInput\\n6\\n2 0 3 0 1 1\\n\\nOutput\\n5\\n2 1\\n2 5\\n3 3\\n3 6\\n5 6\\n\\nInput\\n1\\n0\\n\\nOutput\\n0\\n\\nInput\\n6\\n3 2 2 2 1 1\\n\\nOutput\\n-1\\n\\n\\n\\n-----Note-----\\n\\nFor the first test, the answer configuration is the same as in the picture from the statement.\\n\\n For the second test, the boomerang is not supposed to hit anything, so we can place $0$ targets.\\n\\n For the third test, the following configuration of targets matches the number of hits, but is not allowed as row $3$ has $4$ targets.\\n\\n  [Image] \\n\\nIt can be shown for this test case that no valid configuration of targets will result in the given number of target hits.\",\n  \"Ground Truth Solution\": \"from __future__ import division, print_function\\nfrom fractions import Fraction\\nimport sys\\nimport os\\nfrom io import BytesIO, IOBase\\nfrom heapq import *\\nfrom math import gcd, factorial, floor, ceil\\nfrom copy import deepcopy\\nfrom collections import deque\\nfrom bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom bisect import bisect\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n\\ndef print(*args, **kwargs):\\n\\t(sep, file) = (kwargs.pop('sep', ' '), kwargs.pop('file', sys.stdout))\\n\\tat_start = True\\n\\tfor x in args:\\n\\t\\tif not at_start:\\n\\t\\t\\tfile.write(sep)\\n\\t\\tfile.write(str(x))\\n\\t\\tat_start = False\\n\\tfile.write(kwargs.pop('end', '\\\\n'))\\n\\tif kwargs.pop('flush', False):\\n\\t\\tfile.flush()\\nif sys.version_info[0] < 3:\\n\\t(sys.stdin, sys.stdout) = (FastIO(sys.stdin), FastIO(sys.stdout))\\nelse:\\n\\t(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\nfrom types import GeneratorType\\n\\ndef iterative(f, stack=[]):\\n\\n\\tdef wrapped_func(*args, **kwargs):\\n\\t\\tif stack:\\n\\t\\t\\treturn f(*args, **kwargs)\\n\\t\\tto = f(*args, **kwargs)\\n\\t\\twhile True:\\n\\t\\t\\tif type(to) is GeneratorType:\\n\\t\\t\\t\\tstack.append(to)\\n\\t\\t\\t\\tto = next(to)\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tif not stack:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tto = stack[-1].send(to)\\n\\t\\treturn to\\n\\treturn wrapped_func\\nmod = 10 ** 9 + 7\\n\\ndef inp():\\n\\treturn sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\ndef out(var):\\n\\tsys.stdout.write(str(var))\\n\\ndef lis():\\n\\treturn list(map(int, inp().split()))\\n\\ndef stringlis():\\n\\treturn list(map(str, inp().split()))\\n\\ndef sep():\\n\\treturn map(int, inp().split())\\n\\ndef strsep():\\n\\treturn map(str, inp().split())\\n\\ndef zerolist(n):\\n\\treturn [0] * n\\n\\ndef nextline():\\n\\tout('\\\\n')\\n\\ndef testcase(t):\\n\\tfor pp in range(t):\\n\\t\\tsolve(pp)\\n\\ndef printlist(a):\\n\\tfor p in range(0, len(a)):\\n\\t\\tout(str(a[p]) + ' ')\\n\\ndef google(p):\\n\\tprint('Case #' + str(p) + ': ', end='')\\n\\ndef lcm(a, b):\\n\\treturn a * b // gcd(a, b)\\n\\ndef power(x, y, p):\\n\\tres = 1\\n\\tx = x % p\\n\\tif x == 0:\\n\\t\\treturn 0\\n\\twhile y > 0:\\n\\t\\tif y & 1 == 1:\\n\\t\\t\\tres = res * x % p\\n\\t\\ty = y >> 1\\n\\t\\tx = x * x % p\\n\\treturn res\\n\\ndef ncr(n, r):\\n\\treturn factorial(n) // (factorial(r) * factorial(max(n - r, 1)))\\n\\ndef isPrime(n):\\n\\tif n <= 1:\\n\\t\\treturn False\\n\\tif n <= 3:\\n\\t\\treturn True\\n\\tif n % 2 == 0 or n % 3 == 0:\\n\\t\\treturn False\\n\\ti = 5\\n\\twhile i * i <= n:\\n\\t\\tif n % i == 0 or n % (i + 2) == 0:\\n\\t\\t\\treturn False\\n\\t\\ti = i + 6\\n\\treturn True\\n\\ndef count(g, n, col):\\n\\tans = 0\\n\\trow = -1\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\tif g[i][col] == 1:\\n\\t\\t\\tans += 1\\n\\t\\t\\trow = i\\n\\t\\t\\tbreak\\n\\tif ans == 0:\\n\\t\\treturn 0\\n\\tfor i in range(col + 1, n):\\n\\t\\tif g[row][i] == 1:\\n\\t\\t\\tans += 1\\n\\t\\t\\tcol = i\\n\\t\\t\\tbreak\\n\\tif ans == 1:\\n\\t\\treturn 1\\n\\tfor i in range(row + 1, n):\\n\\t\\tif g[i][col] == 1:\\n\\t\\t\\tans += 1\\n\\t\\t\\tbreak\\n\\treturn ans\\n\\ndef chck(ans, n):\\n\\tg = [[0] * n for i in range(n)]\\n\\tfor i in range(len(ans)):\\n\\t\\tg[ans[i][0]][ans[i][1]] = 1\\n\\tf = True\\n\\tfor i in range(n):\\n\\t\\tif g[i].count(1) > 2:\\n\\t\\t\\tf = False\\n\\t\\t\\tbreak\\n\\tfor j in range(n):\\n\\t\\tcnt = 0\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcnt += g[i][j]\\n\\t\\tif cnt > 2:\\n\\t\\t\\tf = False\\n\\t\\t\\tbreak\\n\\tcol = [0] * n\\n\\tfor i in range(n):\\n\\t\\tcol[i] = count(g, n, i)\\n\\treturn (col, f)\\nfrom random import randint\\nf = True\\n\\ndef solve(case):\\n\\tn = int(inp())\\n\\ta = lis()\\n\\tans = []\\n\\tone = []\\n\\ttwo = []\\n\\tthree = []\\n\\tfor i in range(n - 1, -1, -1):\\n\\t\\tif a[i] == 1:\\n\\t\\t\\tans.append((i, i))\\n\\t\\t\\tone.append(i)\\n\\t\\telif a[i] == 2:\\n\\t\\t\\tif len(one) == 0:\\n\\t\\t\\t\\tprint(-1)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tcurr = one.pop()\\n\\t\\t\\tans.append((curr, i))\\n\\t\\t\\ttwo.append(i)\\n\\t\\telif a[i] == 3:\\n\\t\\t\\tif len(two) == 0 and len(one) == 0 and (len(three) == 0):\\n\\t\\t\\t\\tprint(-1)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tif len(three) != 0:\\n\\t\\t\\t\\tcurr = three.pop()\\n\\t\\t\\t\\tans.append((i, i))\\n\\t\\t\\t\\tans.append((i, curr))\\n\\t\\t\\telif len(two) != 0:\\n\\t\\t\\t\\tcurr = two.pop()\\n\\t\\t\\t\\tans.append((i, i))\\n\\t\\t\\t\\tans.append((i, curr))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcurr = one.pop()\\n\\t\\t\\t\\tans.append((i, i))\\n\\t\\t\\t\\tans.append((i, curr))\\n\\t\\t\\tthree.append(i)\\n\\tprint(len(ans))\\n\\tfor i in range(len(ans)):\\n\\t\\tprint(ans[i][0] + 1, ans[i][1] + 1)\\n\\tsys.stdout.flush()\\nwhile f:\\n\\tf = False\\n\\ttestcase(1)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a scenario where boomerangs are thrown upwards through an n x n grid, bouncing off targets and turning right until they exit the grid. The goal is to reconstruct a valid grid configuration based on the number of targets each boomerang hits, with the constraint that each row and column can have at most two targets.\\n- Identifying Constraints: Each row and column can have at most two targets. The number of hits for each column (ai) is known and is no more than 3. Need to construct a target placement such that the number of hits for each column matches the input, otherwise return -1.\\n- Devising a Strategy: The core idea is to process the columns from right to left. Use a stack or list to maintain available rows after placing the targets in a given column. Columns with 1 hit can have a target placed on the diagonal (row i, column i). Columns with 2 hits require a previous column with 1 hit to bounce off of. Columns with 3 hits require using a previous column with either 1,2, or 3 hits.\\n- Handling Edge Cases: If at any point, a valid configuration cannot be constructed due to a lack of available rows or an impossible target count arrangement, return -1.\\n- Validation: Ensure each row and each column has at most two targets at the end of target assignments.\",\n  \"LLM Questions\": [\n    \"What does it mean for a target configuration to be valid in this context?\",\n    \"How can we approach constructing the target configuration to ensure each column matches the given number of hits while respecting the row and column constraints?\",\n    \"What data structures can be used to efficiently keep track of available rows for target placement?\",\n    \"How do you handle cases where it's not possible to construct a valid target configuration based on the input?\",\n    \"How can we check that each row and column constraint is satisfied?\",\n    \"Why is it important to consider columns from right to left?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A valid configuration is one where the number of targets hit by the boomerang in each column matches the input array 'a', and each row and column contains at most two targets.\",\n    \"We can process the columns from right to left, placing targets strategically such that the number of hits for each column is satisfied by bouncing off previously placed targets, if necessary. Maintain the information about columns with 1,2, and 3 targets, respectively. Place diagonal elements in those columns with 1 target. When a column has a value of 2, we must find a previous column with 1 target and use that to bounce off.\",\n    \"A list or stack can be used to track available rows (columns where targets can be placed) ensuring no row exceeds two targets.\",\n    \"If, at any step, we cannot find a suitable target placement because all available rows are used, or a column requires a target to bounce off an earlier target, but there aren't any available, we return -1.\",\n    \"Iterate through each row and column and verify that the number of targets does not exceed 2.\",\n    \"Processing the columns from right to left makes it easier to satisfy the boomerang trajectory condition, allowing for targets in columns to the left to serve as bounce points for targets in the current column.\"\n  ]\n}\n```"