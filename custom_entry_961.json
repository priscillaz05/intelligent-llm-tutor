"```json\n{\n  \"Coding Problem\": \"Enter-View $\\\\left({\\\\mbox{EV}}\\\\right)$ is a linear, street-like country. By linear, we mean all the cities of the country are placed on a single straight line - the $\\\\boldsymbol{x}$-axis. Thus every city's position can be defined by a single coordinate, $x_i$, the distance from the left borderline of the country. You can treat all cities as single points.\\n\\nUnfortunately, the dictator of telecommunication of EV (Mr. S. Treat Jr.) doesn't know anything about the modern telecom technologies, except for peer-to-peer connections. Even worse, his thoughts on peer-to-peer connections are extremely faulty: he believes that, if $P_i$ people are living in city $\\\\boldsymbol{i}$, there must be at least $P_i$ cables from city $\\\\boldsymbol{i}$ to every other city of EV - this way he can guarantee no congestion will ever occur!\\n\\nMr. Treat hires you to find out how much cable they need to implement this telecommunication system, given the coordination of the cities and their respective population. \\n\\nNote that The connections between the cities can be shared. Look at the example for the detailed explanation.\\n\\nInput Format  \\n\\nA number $\\\\mathbf{T}$ is given in the first line and then comes $\\\\mathbf{T}$ blocks, each representing a scenario.\\n\\nEach scenario consists of three lines. The first line indicates the number of cities (N). The second line indicates the coordinates of the N cities. The third line contains the population of each of the cities. The cities needn't be in increasing order in the input.\\n\\nOutput Format  \\n\\nFor each scenario of the input, write the length of cable needed in a single line modulo $1,000,000,007$.\\n\\nConstraints  \\n\\n$1\\\\leq T\\\\leq20$ \\n\\n$1\\\\leq N\\\\leq200,000$ \\n\\n$P_i\\\\leq10,000$ \\n\\nBorder to border length of the country $\\\\leq1,000,000,000$\\n\\nSample Input  \\n\\n2  \\n3  \\n1 3 6  \\n10 20 30  \\n5  \\n5 55 555 55555 555555  \\n3333 333 333 33 35\\n\\nSample Output  \\n\\n280  \\n463055586\\n\\nExplanation\\n\\nFor the first test case, having $3$ cities requires $3$ sets of cable connections. Between city $1$ and $2$, which has a population of $10$ and $\\\\textbf{20}$, respectively, Mr. Treat believes at least $10$ cables should come out of city 1 for this connection, and at least 20 cables should come out of city $2$ for this connection. Thus, the connection between city $1$ and city $2$ will require $\\\\textbf{20}$ cables, each crossing a distance of $3-1=2$ km. Applying this absurd logic to connection 2,3 and 1,3, we have\\n\\n$[1,2]$ => $\\\\textbf{20}$ connections $X$ $2km=40$ km of cable\\n\\n$[2,3]$ => $30$ connections $X$ $3km=90$ km of cable\\n\\n$[1,3]$ => $30$ connections $X$ $5km=150$ km of cable\\n\\nFor a total of $280$ , Output is $280$ km of cable\",\n  \"Ground Truth Solution\": \"from bisect import bisect_left\\n\\nclass Shell:\\n\\n\\tdef __init__(self, distances):\\n\\t\\tself.size = sum(distances)\\n\\t\\tself.list = distances\\n\\t\\tself.elements = len(self.list)\\n\\n\\tdef __str__(self):\\n\\t\\treturn '({}, {})'.format(self.size, self.list)\\n\\n\\tdef FindValue(self, value):\\n\\t\\ti = bisect_left(self.list, value)\\n\\t\\treturn i if self.elements != i and self.list[i] == value else None\\n\\n\\tdef DestroyElement(self, element):\\n\\t\\tv = self.list.pop(element)\\n\\t\\tself.size -= v\\n\\t\\tself.elements -= 1\\n\\t\\treturn self.size == 0\\n\\n\\tdef Sum(self, element):\\n\\t\\tleftSum = self.list[element] * element - sum(self.list[0:element])\\n\\t\\trightSum = sum(self.list[element + 1:]) - (self.elements - element - 1) * self.list[element]\\n\\t\\treturn leftSum + rightSum\\n\\n\\tdef GetSize(self, element):\\n\\t\\treturn self.list[element]\\n\\n\\tdef CalculateBeforeSize(self, size):\\n\\t\\treturn size * self.elements - self.size\\n\\n\\tdef CalculateAfterSize(self, size):\\n\\t\\treturn self.size - size * self.elements\\n\\n\\tdef __lt__(self, other):\\n\\t\\treturn self.list[self.elements - 1] < other\\n\\nclass DistanceList:\\n\\n\\tdef __init__(self, distances):\\n\\t\\tnumShells = min(int(len(distances) / 3000) + 1, 16)\\n\\t\\tperShell = int(len(distances) / numShells)\\n\\t\\tadditional = len(distances) % numShells\\n\\t\\tself.shells = list()\\n\\t\\tcurShell = 0\\n\\t\\tfor i in range(numShells):\\n\\t\\t\\tplus1 = 1 if additional > 0 else 0\\n\\t\\t\\tnextShell = curShell + perShell + plus1\\n\\t\\t\\tself.shells.append(Shell(distances[curShell:nextShell]))\\n\\t\\t\\tcurShell = nextShell\\n\\t\\t\\tadditional -= 1\\n\\n\\tdef FindValue(self, value):\\n\\t\\ts = bisect_left(self.shells, value)\\n\\t\\treturn (s, self.shells[s].FindValue(value))\\n\\n\\tdef DestroyElement(self, element):\\n\\t\\tif self.shells[element[0]].DestroyElement(element[1]):\\n\\t\\t\\tself.shells.pop(element[0])\\n\\n\\tdef CalculateDistance(self, element):\\n\\t\\tcitySize = self.shells[element[0]].GetSize(element[1])\\n\\t\\tdistanceBefore = 0\\n\\t\\tfor s in self.shells[:element[0]]:\\n\\t\\t\\tdistanceBefore += s.CalculateBeforeSize(citySize)\\n\\t\\tdistanceAfter = 0\\n\\t\\tfor s in self.shells[element[0] + 1:]:\\n\\t\\t\\tdistanceAfter += s.CalculateAfterSize(citySize)\\n\\t\\treturn distanceBefore + distanceAfter + self.shells[element[0]].Sum(element[1])\\n\\n\\tdef __str__(self):\\n\\t\\treturn '\\\\n'.join([str(s) for s in self.shells])\\n\\nclass DistanceFinder:\\n\\n\\tdef __init__(self, distances):\\n\\t\\tself.distanceList = DistanceList(sorted(distances))\\n\\n\\tdef CalculateDistance(self, value):\\n\\t\\telement = self.distanceList.FindValue(value)\\n\\t\\tdistance = self.distanceList.CalculateDistance(element)\\n\\t\\tself.distanceList.DestroyElement(element)\\n\\t\\treturn distance\\n\\n\\tdef Print(self):\\n\\t\\tprint(str(self.distanceList))\\n\\ndef CalculateCable(distances, populations):\\n\\ttotalDistance = 0\\n\\tsortedPop = sorted(zip(distances, populations), key=lambda x: x[1], reverse=True)\\n\\tdf = DistanceFinder(distances)\\n\\tfor (distance, population) in sortedPop:\\n\\t\\ttotalDistance += df.CalculateDistance(distance) * population\\n\\tprint(totalDistance % 1000000007)\\ntests = int(input())\\nfor t in range(tests):\\n\\tcities = int(input())\\n\\tdistances = list(map(int, input().split()))\\n\\tpopulations = list(map(int, input().split()))\\n\\tCalculateCable(distances, populations)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a scenario where cities are located on a line, and the number of cables between any two cities should be equal to the maximum population of the two cities. The objective is to calculate the total length of cable needed modulo 1,000,000,007.\\n- Formulating the Solution: For each pair of cities, calculate the distance between them and multiply by the maximum population of those cities. Sum these values to get the total cable length. Then, take the modulo of this sum by 1,000,000,007.\\n- Handling Constraints: Since the number of cities can be up to 200,000, a naive O(n^2) solution will likely time out. The solution needs to be optimized. The problem states that the connections can be shared, so the cable count should be equal to the maximum population between each city pair. Since the distances are fixed for the cities, calculating the weighted sum of the distances should be efficient.\\n- Identifying Edge Cases: Need to handle cases where either the number of cities or the populations are very large, ensuring that intermediate calculations do not cause overflow issues. Taking modulo at intermediate calculation is important to keep the result within the integer range.\",\n  \"LLM Questions\": [\n    \"How do you calculate the distance between two cities given their coordinates?\",\n    \"How do you determine the number of cables needed between two cities?\",\n    \"How do you efficiently compute the total cable length for all pairs of cities?\",\n    \"How do you handle the modulo operation to prevent integer overflow?\",\n    \"How can you optimize the solution to meet the time constraints, given a large number of cities?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The distance between two cities is the absolute difference of their coordinates: |x1 - x2|.\",\n    \"The number of cables needed between two cities is the maximum of their populations: max(P1, P2).\",\n    \"You can calculate the cable length for each pair of cities (distance * max population), sum up all these lengths, and then take the modulo by 1,000,000,007.\",\n    \"Apply the modulo operation after each multiplication and summation to keep the numbers within a manageable range, thus avoiding integer overflow.\",\n    \"Sort the cities by distance, and use a divide-and-conquer approach to calculate the total cable length. Also, use efficient data structures to track population information.\"\n  ]\n}\n```"