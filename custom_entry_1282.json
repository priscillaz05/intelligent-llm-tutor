"```json\n{\n  \"Coding Problem\": \"This is an interactive problem.\\n\\nWe hid from you a permutation p of length n, consisting of the elements from 1 to n. You want to guess it. To do that, you can give us 2 different indices i and j, and we will reply with p_{i} mod p_{j} (remainder of division p_{i} by p_{j}).\\n\\nWe have enough patience to answer at most 2 \u22c5 n queries, so you should fit in this constraint. Can you do it?\\n\\nAs a reminder, a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\\n\\nInput\\n\\nThe only line of the input contains a single integer n (1 \u2264 n \u2264 10^4) \u2014 length of the permutation.\\n\\nInteraction\\n\\nThe interaction starts with reading n. \\n\\nThen you are allowed to make at most 2 \u22c5 n queries in the following way: \\n\\n  * \\\"? x y\\\" (1 \u2264 x, y \u2264 n, x \u2260 y). \\n\\n\\n\\nAfter each one, you should read an integer k, that equals p_x mod p_y. \\n\\nWhen you have guessed the permutation, print a single line \\\"! \\\" (without quotes), followed by array p and quit.\\n\\nAfter printing a query do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\\n\\n  * fflush(stdout) or cout.flush() in C++;\\n  * System.out.flush() in Java;\\n  * flush(output) in Pascal;\\n  * stdout.flush() in Python;\\n  * see documentation for other languages.\\n\\n\\n\\nExit immediately after receiving \\\"-1\\\" and you will see Wrong answer verdict. Otherwise you can get an arbitrary verdict because your solution will continue to read from a closed stream.\\n\\nHack format\\n\\nIn the first line output n (1 \u2264 n \u2264 10^4). In the second line print the permutation of n integers p_1, p_2, \u2026, p_n.\\n\\nExample\\n\\nInput\\n\\n\\n3\\n\\n1\\n\\n2\\n\\n1\\n\\n0\\n\\nOutput\\n\\n\\n? 1 2\\n\\n? 3 2\\n\\n? 1 3\\n\\n? 2 1\\n\\n! 1 3 2\",\n  \"Ground Truth Solution\": \"import sys\\nDEBUG = False\\n\\ndef debug(*args):\\n\\tif not DEBUG:\\n\\t\\treturn\\n\\tprint('\\\\x1b[0;31m', end='', file=sys.stderr)\\n\\tprint(*args, file=sys.stderr)\\n\\tprint('\\\\x1b[0m', end='', file=sys.stderr)\\n\\tsys.stderr.flush()\\n\\ndef readInt():\\n\\tline = input()\\n\\twhile line == '':\\n\\t\\tline = input()\\n\\tresult = int(line)\\n\\treturn result\\ncache = {}\\n\\ndef query(i, j):\\n\\tif (i, j) not in cache:\\n\\t\\tprint('? ' + str(i + 1) + ' ' + str(j + 1), file=sys.stdout)\\n\\t\\tsys.stdout.flush()\\n\\t\\tif not DEBUG:\\n\\t\\t\\tx = readInt()\\n\\t\\t\\tdebug('query', i, j, ':', x)\\n\\t\\telse:\\n\\t\\t\\tx = REAL[i] % REAL[j]\\n\\t\\t\\tdebug('query', i, j, '\\\\t', REAL[i], '%', REAL[j], ':', x)\\n\\t\\tcache[i, j] = x\\n\\treturn cache[i, j]\\n\\ndef answer(arr):\\n\\tprint('! ' + ' '.join((str(x) for x in arr)), file=sys.stdout)\\n\\tsys.stdout.flush()\\n\\tdebug('ans', arr)\\n\\ndef solve():\\n\\tif DEBUG:\\n\\t\\tcache.clear()\\n\\t\\tN = len(REAL)\\n\\t\\tdebug('Testing', N, REAL)\\n\\telse:\\n\\t\\tN = readInt()\\n\\tif N == 1:\\n\\t\\tanswer([1])\\n\\t\\texit()\\n\\tans = [-1 for i in range(N)]\\n\\tlast = 0\\n\\tfor i in range(1, N):\\n\\t\\ta = query(i, last)\\n\\t\\tb = query(last, i)\\n\\t\\tif a > b:\\n\\t\\t\\tans[i] = a\\n\\t\\t\\tif DEBUG:\\n\\t\\t\\t\\tassert REAL[last] > REAL[i]\\n\\t\\telse:\\n\\t\\t\\tans[last] = b\\n\\t\\t\\tif DEBUG:\\n\\t\\t\\t\\tassert REAL[last] < REAL[i]\\n\\t\\t\\tlast = i\\n\\tfor i in range(N):\\n\\t\\tif ans[i] == -1:\\n\\t\\t\\tans[i] = N\\n\\tanswer(ans)\\n\\tassert len(cache) <= 2 * N\\n\\treturn ans\\nif DEBUG:\\n\\timport random\\n\\trandom.seed(0)\\n\\tfor _ in range(1000):\\n\\t\\tN = 5\\n\\t\\tREAL = list(range(1, N + 1))\\n\\t\\trandom.shuffle(REAL)\\n\\t\\tassert solve() == REAL\\n\\texit()\\nsolve()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the interactive problem format: The problem requires interacting with a judge by sending queries and receiving answers. Failing to follow the IO format leads to runtime errors.\\n- Identifying the problem goal: The objective is to correctly determine a hidden permutation of length 'n' using at most 2*n queries.\\n- Devising a query strategy: A key strategy is to compare pairs of elements to determine their relative order. Using the mod operation reveals which element is larger.\\n- Optimizing query usage: The total query count is limited to 2*n. This necessitates carefully choosing queries to extract maximum information.\\n- Implementation of query and answer: The program must correctly format queries using '? x y', flush the output, and parse integer responses. The final answer is presented as '! p1 p2 ... pn'.\",\n  \"LLM Questions\": [\n    \"How do you interact with the judge in this problem and what is the query format?\",\n    \"What is the maximum number of queries allowed and how does it affect your strategy?\",\n    \"Explain the logic behind using the mod operation to deduce the relative order of permutation elements.\",\n    \"Describe a strategy to identify the permutation while staying within the query limit.\",\n    \"What steps are crucial in ensuring the I/O operations work correctly (e.g. flushing output)?\",\n    \"How should the final answer (the guessed permutation) be formatted for submission?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"You interact with the judge by printing queries in the format '? x y' (where x and y are indices), and then reading the judge's response from standard input.\",\n    \"You are allowed a maximum of 2*n queries. This constraint necessitates an efficient strategy to deduce the permutation with minimal comparisons.\",\n    \"The mod operation (p_i mod p_j) yields a value less than p_j. Therefore, if p_i mod p_j results in a non-zero value, we know p_i > p_j is false and hence p_i is likely smaller than p_j if the outcome is less than p_j. If p_i mod p_j is greater than p_j mod p_i, it suggest that p_i is greater than p_j.\",\n    \"A valid strategy is to iteratively compare elements, find the largest, and place it into result. The comparisons using 'mod' can tell which is larger. You can optimize query usage by maintaining a candidate for the maximum and updating it as necessary.\",\n    \"Flushing the output after each query is essential to send the query to the judge and avoid 'Idleness limit exceeded'. This is done using commands such as `fflush(stdout)` in C++ or `stdout.flush()` in Python.\",\n    \"The final answer should be printed to standard output in the format '! p1 p2 ... pn', where p1, p2, ..., pn are the elements of the deduced permutation.\"\n  ]\n}\n```"