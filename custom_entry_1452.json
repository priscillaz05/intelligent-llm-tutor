"```json\n{\n  \"Coding Problem\": \"Our monk, while taking a stroll in the park, stumped upon a polynomial ( A X^2 + B X +C ) lying on the ground.  The polynomial was dying!  Being considerate, our monk tried to talk and revive the polynomial. The polynomial said: \\nI have served my purpose, and shall not live anymore. Please fulfill my dying wish. Find me the least non-negative integer Xo, that shall make my value atleast K i.e.,  A Xo^2 + B Xo + C \u2265 K . \\nHelp our Monk fulfill the polynomial's dying wish!\\nInput: \\nThe first line contains an integer T. T test cases follow. \\nEach test case consists of four space-separated integers A, B, C and K.\\n\\nOutput:\\nFor each test case, output the answer in a new line.\\nConstraints:\\n1 \u2264 T \u2264 10^5\\n1 \u2264 A,B,C \u2264 10^5\\n1 \u2264 K \u2264 10^10\\n\\nSAMPLE INPUT\\n3\\n3 4 5 6\\n3 4 5 5\\n3 4 5 150\\n\\nSAMPLE OUTPUT\\n1\\n0\\n7\",\n  \"Ground Truth Solution\": \"t=eval(input())\\nwhile t>0:\\n\\ta,b,c,k=list(map(int,input().split()))\\n\\ti=50\\n\\twhile True:\\n\\t\\tif (a*i*i)+(b*i)+(c)>=k:\\n\\t\\t\\tj=i-50\\n\\t\\t\\twhile j<=i:\\n\\t\\t\\t\\tif (a*j*j)+(b*j)+(c)>=k:\\n\\t\\t\\t\\t\\tprint(j)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tj+=1\\n\\t\\t\\tbreak\\n\\t\\ti+=50\\n\\tt-=1\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: We need to find the smallest non-negative integer Xo such that A * Xo^2 + B * Xo + C >= K.\\n- Choosing an Approach: Since we need to find the *least* non-negative integer, we can use a brute-force or iterative approach, starting from 0 and incrementing until the condition is met.  Given the constraints, a binary search approach might be efficient.  However the provided solution uses a different approach using large increments of 50 followed by smaller increments. Let's analyze it. Initial value is checked at 50, then it decreases by 50 and starts increasing by one till the desired value is found. This approach is useful in cases where the required value is very large and also to ensure correctness.\\n- Handling Constraints: The constraints 1 \u2264 A, B, C \u2264 10^5 and 1 \u2264 K \u2264 10^10 suggest that a simple iterative approach will work fine, as the values won't become exceedingly large too quickly. This also means overflow should not be a major concern if we use 64 bit integers.\\n- Implementing the Iterative Solution: Start with Xo = 0, and incrementally increase it. In each step, check if A * Xo^2 + B * Xo + C >= K. Break the loop and return Xo when the condition is satisfied.\",\n  \"LLM Questions\": [\n    \"What is the objective of the problem and what conditions must the solution meet?\",\n    \"What are the constraints on the input variables and how do they impact the choice of algorithm?\",\n    \"Is there any risk of integer overflow given the constraints, and how can we handle it?\",\n    \"Can you suggest a more efficient approach than the iterative approach?\",\n    \"How would you validate the solution to ensure that it's correct and efficient within the specified constraints?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The objective is to find the smallest non-negative integer Xo such that the polynomial A * Xo^2 + B * Xo + C is greater than or equal to K.\",\n    \"A, B, and C are between 1 and 10^5, and K is between 1 and 10^10. The iterative approach should be efficient enough, but a binary search approach could be faster.\",\n    \"Given the constraints, integer overflow is not a big concern, especially if using Python, which automatically handles larger integers.\",\n    \"A binary search could be more efficient if the iterative search takes too long. Given the quadratic function, binary search can effectively find the smallest Xo by narrowing the search range.\",\n    \"Validate the solution by plugging the returned Xo back into the polynomial and confirming that the result is greater than or equal to K. Also, check that Xo - 1 does not satisfy the same condition to ensure that Xo is indeed the smallest.\"\n  ]\n}\n```"