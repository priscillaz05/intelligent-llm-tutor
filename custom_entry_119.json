"```json\n{\n  \"Coding Problem\": \"You are situated in an N dimensional grid at position (x1,x2,...,xN). The dimensions of the grid are (D1,D2,...DN). In one step, you can walk one step ahead or behind in any one of the N dimensions. (So there are always 2\u00d7N possible different moves). In how many ways can you take M steps such that you do not leave the grid at any point? You leave the grid if at any point xi, either xi\u22640 or xi>Di. \\n\\nInput Format\\n\\nThe first line contains the number of test cases T. T test cases follow. For each test case, the first line contains N and M, the second line contains x1,x2,\u2026,xN and the 3rd line contains D1,D2,\u2026,DN.\\n\\nOutput Format\\n\\nOutput T lines, one corresponding to each test case. Since the answer can be really huge, output it modulo 1000000007.\\n\\nConstraints\\n\\n1\u2264T\u226410\\n\\n1\u2264N\u226410\\n\\n1\u2264M\u2264300\\n\\n1\u2264Di\u2264100\\n\\n1\u2264xi\u2264Di\\n\\nSAMPLE INPUT\\n5\\n1 287\\n44\\n78\\n1 236\\n25\\n87\\n1 122\\n41\\n63\\n1 260\\n7\\n64\\n1 127\\n3\\n73\\n\\nSAMPLE OUTPUT\\n38753340\\n587915072\\n644474045\\n423479916\\n320130104\",\n  \"Ground Truth Solution\": \"def ways(di, offset, steps):\\n\\tglobal mem, dimensions\\n\\tif steps in mem[di] and offset in mem[di][steps]:\\n\\t\\treturn mem[di][steps][offset]\\n\\tval = 0\\n\\tif steps == 0:\\n\\t\\tval = 1\\n\\telse:\\n\\t\\tif offset - 1 >= 1:\\n\\t\\t\\tval += ways(di, offset - 1, steps - 1)\\n\\t\\tif offset + 1 <= dimensions[di]:\\n\\t\\t\\tval += ways(di, offset + 1, steps - 1)\\n\\tmem[di][steps][offset] = val\\n\\treturn val\\n\\n\\ndef set_ways(left, right, steps):\\n\\t# must create t1, t2, t3 .. ti for steps\\n\\tglobal mem_set, mem, starting_point\\n\\t#print left, right\\n\\t#sleep(2)\\n\\tif (left, right) in mem_set and steps in mem_set[(left, right)]:\\n\\t\\treturn mem_set[(left, right)][steps]\\n\\tif right - left == 1:\\n\\t\\t#print 'getting steps for', left, steps, starting_point[left]\\n\\t\\t#print 'got ', mem[left][steps][starting_point[left]], 'steps'\\n\\t\\treturn mem[left][steps][starting_point[left]]\\n\\t\\t#return ways(left, starting_point[left], steps)\\n\\tval = 0\\n\\tsplit_point =  left + (right - left) / 2 \\n\\tfor i in range(steps + 1):\\n\\t\\tt1 = i\\n\\t\\tt2 = steps - i\\n\\t\\tmix_factor = fact[steps] / (fact[t1] * fact[t2])\\n\\t\\t#print \\\"mix_factor = %d, dimension: %d - %d steps, dimension %d - %d steps\\\" % (mix_factor, left, t1, split_point, t2)\\n\\t\\tval += mix_factor * set_ways(left, split_point, t1) * set_ways(split_point, right, t2)\\n\\tmem_set[(left, right)][steps] = val\\n\\treturn val\\n\\nimport sys\\nfrom time import sleep, time\\n\\nfact = {}\\nfact[0] = 1\\nstart = time()\\naccum = 1\\nfor k in range(1, 300+1):\\n\\taccum *= k\\n\\tfact[k] = accum\\n#print 'fact_time', time() - start\\n\\ndata = sys.stdin.readlines()\\nnum_tests = int(data.pop(0))\\nfor ignore in range(0, num_tests):\\n\\tn_and_steps = data.pop(0)\\n\\tn, steps = [int(x) for x in n_and_steps.split()]\\n\\tstarting_point = [int(x) for x in data.pop(0).split()]\\n\\tdimensions = [int(x) for x in data.pop(0).split()]\\n\\tmem = {}\\n\\tfor di in range(n):\\n\\t\\tmem[di] = {}\\n\\t\\tfor i in range(steps + 1):\\n\\t\\t\\tmem[di][i] = {}\\n\\t\\t\\tways(di, starting_point[di], i)\\n\\tstart = time()\\n\\t#print 'mem vector is done'\\n\\tmem_set = {}\\n\\tfor i in range(n + 1):\\n\\t\\tfor j in range(n + 1):\\n\\t\\t\\tmem_set[(i, j)] = {}\\n\\tanswer = set_ways(0, n, steps)\\n\\t#print answer\\n\\tprint(answer % 1000000007)\\n\\t#print time() - start\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes movement in an N-dimensional grid. The goal is to find the number of ways to take M steps without leaving the grid, considering the boundaries defined by D1, D2, ... DN, and the starting points x1, x2, ... xN.\\n- Identifying Key Constraints: The grid dimensions are D1 to DN, and current positions must always be between 1 and Di for each dimension i. Each move involves incrementing or decrementing one of the xi values.\\n- Formulating a Recursive Approach: Consider a recursive function that explores all possible paths. The function should take the current position, the number of steps remaining, and the grid dimensions as input. The base case is when the number of steps remaining is zero, in which case we have found a valid path. The recursive step involves trying all possible moves (incrementing or decrementing one of the coordinates) and checking if the move keeps the position within the grid boundaries. If a move is valid, we recursively call the function with the updated position and one fewer step.\\n- Optimization through Memoization: Since the same position and number of steps can be reached through multiple paths, memoization can be used to avoid redundant calculations. Store the results of the recursive calls in a table to reuse them later.\\n- Handling Large Results: Due to the potentially large number of paths, the result must be computed modulo 1000000007 to prevent overflow.\",\n  \"LLM Questions\": [\n    \"How do you ensure that each step taken keeps the position within the grid boundaries?\",\n    \"Can you explain how memoization can improve the performance of the recursive solution?\",\n    \"Why is it necessary to compute the result modulo 1000000007?\",\n    \"What are the base cases for the recursive solution?\",\n    \"How many possible moves can be made at each step?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Each step must be checked to ensure that the updated coordinate xi remains within the bounds 1 <= xi <= Di for all dimensions i.\",\n    \"Memoization stores the results of function calls with particular sets of parameters, allowing the function to return the stored result immediately if called again with the same parameters, thus avoiding redundant calculations.\",\n    \"Computing the result modulo 1000000007 is necessary to prevent integer overflow, as the number of possible paths can be very large.\",\n    \"The base cases are when the number of steps remaining is zero, or when the number of steps is negative or starting positions are invalid.\",\n    \"At each step, there are 2*N possible moves, since you can move one step ahead or behind in any of the N dimensions.\"\n  ]\n}\n```"