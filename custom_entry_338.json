"```json\n{\n  \"Coding Problem\": \"The sequence of $m$ integers is called the permutation if it contains all integers from $1$ to $m$ exactly once. The number $m$ is called the length of the permutation.\\n\\nDreamoon has two permutations $p_1$ and $p_2$ of non-zero lengths $l_1$ and $l_2$.\\n\\nNow Dreamoon concatenates these two permutations into another sequence $a$ of length $l_1 + l_2$. First $l_1$ elements of $a$ is the permutation $p_1$ and next $l_2$ elements of $a$ is the permutation $p_2$. \\n\\nYou are given the sequence $a$, and you need to find two permutations $p_1$ and $p_2$. If there are several possible ways to restore them, you should find all of them. (Note that it is also possible that there will be no ways.)\\n\\n\\n-----Input-----\\n\\nThe first line contains an integer $t$ ($1 \\le t \\le 10\\,000$) denoting the number of test cases in the input.\\n\\nEach test case contains two lines. The first line contains one integer $n$ ($2 \\leq n \\leq 200\\,000$): the length of $a$. The second line contains $n$ integers $a_1, a_2, \\\\ldots, a_n$ ($1 \\leq a_i \\leq n-1$).\\n\\nThe total sum of $n$ is less than $200\\,000$.\\n\\n\\n-----Output-----\\n\\nFor each test case, the first line of output should contain one integer $k$: the number of ways to divide $a$ into permutations $p_1$ and $p_2$.\\n\\nEach of the next $k$ lines should contain two integers $l_1$ and $l_2$ ($1 \\leq l_1, l_2 \\leq n, l_1 + l_2 = n$), denoting, that it is possible to divide $a$ into two permutations of length $l_1$ and $l_2$ ($p_1$ is the first $l_1$ elements of $a$, and $p_2$ is the last $l_2$ elements of $a$). You can print solutions in any order.\\n\\n\\n-----Example-----\\nInput\\n6\\n5\\n1 4 3 2 1\\n6\\n2 4 1 3 2 1\\n4\\n2 1 1 3\\n4\\n1 3 3 1\\n12\\n2 1 3 4 5 6 7 8 9 1 10 2\\n3\\n1 1 1\\n\\nOutput\\n2\\n1 4\\n4 1\\n1\\n4 2\\n0\\n0\\n1\\n2 10\\n0\\n\\n\\n-----Note-----\\n\\nIn the first example, two possible ways to divide $a$ into permutations are $\\{1\\} + \\{4, 3, 2, 1\\}$ and $\\{1,4,3,2\\} + \\{1\\}$.\\n\\nIn the second example, the only way to divide $a$ into permutations is $\\{2,4,1,3\\} + \\{2,1\\}$.\\n\\nIn the third example, there are no possible ways.\",\n  \"Ground Truth Solution\": \"t = int(input())\\nfor i in range(t):\\n\\tn = int(input())\\n\\tmass = [int(x) for x in input().split()]\\n\\tanswer = 0\\n\\tq = []\\n\\tMax = 0\\n\\tind = 0\\n\\tfor j in range(n):\\n\\t\\tif Max < mass[j]:\\n\\t\\t\\tMax = mass[j]\\n\\tind = Max - 1\\n\\ta1 = mass[:n - ind - 1]\\n\\ta2 = mass[n - ind - 1:]\\n\\ta3 = mass[:ind + 1]\\n\\ta4 = mass[ind + 1:]\\n\\ta1.sort()\\n\\ta2.sort()\\n\\ta3.sort()\\n\\ta4.sort()\\nf1 = True\\nf2 = True\\n\\tfor i in range(n - ind - 1):\\n\\t\\tif a1[i] != i + 1:\\n\\t\\t\\tf1 = False\\n\\tif f1:\\n\\t\\tfor i in range(ind + 1):\\n\\t\\t\\tif a2[i] != i + 1:\\n\\t\\t\\t\\tf1 = False\\n\\tif f1:\\n\\t\\tanswer += 1\\n\\t\\tq.append((n - ind - 1, ind + 1))\\n\\tfor i in range(ind + 1):\\n\\t\\tif a3[i] != i + 1:\\n\\t\\t\\tf2 = False\\n\\tif f2:\\n\\t\\tfor i in range(n - ind - 1):\\n\\t\\t\\tif a4[i] != i + 1:\\n\\t\\t\\t\\tf2 = False\\n\\tif f2 and n - ind - 1 != ind + 1:\\n\\t\\tanswer += 1\\n\\t\\tq.append((ind + 1, n - ind - 1))\\n\\tprint(answer)\\n\\tfor l in q:\\n\\t\\tprint(*l)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Problem Constraints: The problem asks to find all possible ways to split a given sequence `a` into two subsequences `p1` and `p2`, such that `p1` and `p2` are permutations.  A permutation of length `m` must contain all integers from 1 to `m` exactly once.\\n- Identifying Potential Pitfalls:  Consider edge cases such as no possible splits, or multiple splits. Also, note the constraint that the integers in the sequence `a` are between 1 and `n-1` inclusive. The length of `p1` and `p2` must add up to `n`.\\n- Selecting an Algorithmic Strategy: Iterate through all possible splits of `a` into `p1` and `p2`. For each split, check if both `p1` and `p2` are permutations.  To check if a sequence is a permutation, sort it and verify it contains exactly the integers 1 to m, where m is the length of the sequence.\\n- Implementation Considerations: Note that since n can be up to 200,000, an O(n^2) algorithm could be slow with larger test cases, but the total sum of n is less than 200,000, so looping to create permutations will be accepted. Sort each permutation which is O(n log n).\",\n  \"LLM Questions\": [\n    \"What exactly constitutes a permutation, and why is it important for determining valid splits of the given sequence?\",\n    \"How would you approach checking if a given subsequence is a valid permutation, considering the integers must range from 1 to the length of the subsequence?\",\n    \"How would you efficiently enumerate all possible ways to split the sequence a into two subsequences, and what considerations should you keep in mind to avoid redundant calculations?\",\n    \"What edge cases might occur during the processing (e.g., an empty sequence or a sequence that cannot be split into permutations), and how should the algorithm respond to such scenarios?\",\n    \"Given the input constraints, how can you ensure that your solution performs efficiently enough to handle the largest possible inputs without exceeding time limits?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A permutation is a sequence of integers where each integer from 1 to m (where m is the length of the sequence) appears exactly once. It is crucial because the problem requires that both p1 and p2 are permutations, so the validity of a split depends on both subsequences meeting this criteria.\",\n    \"To check if a subsequence is a valid permutation, I would first determine its length, m. Then, I would sort the subsequence and verify if it contains each integer from 1 to m exactly once. Sorting can allow easy checking.\",\n    \"To enumerate all possible splits, I would iterate from l1 = 1 to n-1, where l1 is the length of p1, and l2 = n - l1 is the length of p2. For each value of l1, I'd create p1 as the first l1 elements of a and p2 as the remaining n-l1 elements. There aren't many redundant calculation considerations other than terminating early if impossible splits are seen early.\",\n    \"Edge cases include cases where the sequence cannot be split into valid permutations, resulting in zero ways. Also, an empty sequence is implicitly handled by the constraints (n >= 2). When no splits work, the code should simply output '0'.\",\n    \"The given constraints of up to 200,000 total sum of n implies an efficient algorithm is desired. Sorting each permutation will be O(n log n), and enumerating through the possible values to split will be O(n) at worst. In combination, for one test case, the complexity can range up to O(n log n). Given the nature of competitive programming problems, this will most likely pass.\"\n  ]\n}\n```"