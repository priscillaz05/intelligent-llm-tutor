"```json\n{\n  \"Coding Problem\": \"You are given an undirected unweighted graph consisting of $n$ vertices and $m$ edges (which represents the map of Bertown) and the array of prices $p$ of length $m$. It is guaranteed that there is a path between each pair of vertices (districts).\\n\\nMike has planned a trip from the vertex (district) $a$ to the vertex (district) $b$ and then from the vertex (district) $b$ to the vertex (district) $c$. He can visit the same district twice or more. But there is one issue: authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road (he pays each time he goes along the road). The list of prices that will be used $p$ is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road.\\n\\nYou are a good friend of Mike (and suddenly a mayor of Bertown) and want to help him to make his trip as cheap as possible. So, your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the minimum possible. Note that you cannot rearrange prices after the start of the trip.\\n\\nYou have to answer $t$ independent test cases.\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\\n\\nThe first line of the test case contains five integers $n, m, a, b$ and $c$ ($2 \\le n \\le 2 \\cdot 10^5$, $n-1 \\le m \\le min(\\frac{n(n-1)}{2}, 2 \\cdot 10^5)$, $1 \\le a, b, c \\le n$) \u2014 the number of vertices, the number of edges and districts in Mike's trip.\\n\\nThe second line of the test case contains $m$ integers $p_1, p_2, \\dots, p_m$ ($1 \\le p_i \\le 10^9$), where $p_i$ is the $i$-th price from the array.\\n\\nThe following $m$ lines of the test case denote edges: edge $i$ is represented by a pair of integers $v_i$, $u_i$ ($1 \\le v_i, u_i \\le n$, $u_i \\ne v_i$), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i. e. for each pair ($v_i, u_i$) there are no other pairs ($v_i, u_i$) or ($u_i, v_i$) in the array of edges, and for each pair $(v_i, u_i)$ the condition $v_i \\ne u_i$ is satisfied. It is guaranteed that the given graph is connected.\\n\\nIt is guaranteed that the sum of $n$ (as well as the sum of $m$) does not exceed $2 \\cdot 10^5$ ($\\\\sum n \\le 2 \\cdot 10^5$, $\\\\sum m \\le 2 \\cdot 10^5$).\\n\\n\\n-----Output-----\\n\\nFor each test case, print the answer \u2014 the minimum possible price of Mike's trip if you distribute prices between edges optimally.\\n\\n\\n-----Example-----\\nInput\\n2\\n4 3 2 3 4\\n1 2 3\\n1 2\\n1 3\\n1 4\\n7 9 1 5 7\\n2 10 4 8 5 6 7 3 3\\n1 2\\n1 3\\n1 4\\n3 2\\n3 5\\n4 2\\n5 6\\n1 7\\n6 7\\n\\nOutput\\n7\\n12\\n\\n\\n-----Note-----\\n\\nOne of the possible solution to the first test case of the example:\\n\\n[Image]\\n\\nOne of the possible solution to the second test case of the example:\\n\\n[Image]\",\n  \"Ground Truth Solution\": \"from collections import deque\\ng = [[] for y in range(int(200000.0 + 5))]\\nq = int(input())\\nwhile q > 0:\\n\\tq -= 1\\n\\t(n, m, a, b, c) = map(int, input().split())\\n\\n\\tdef BFS(a):\\n\\t\\tList = []\\n\\t\\tdist = [-1] * (n + 1)\\n\\t\\tdist[a] = 0\\n\\t\\tList = deque([a])\\n\\t\\twhile List:\\n\\t\\t\\tu = List.popleft()\\n\\t\\t\\tfor v in g[u]:\\n\\t\\t\\t\\tif dist[v] < 0:\\n\\t\\t\\t\\t\\tdist[v] = dist[u] + 1\\n\\t\\t\\t\\t\\tList.append(v)\\n\\t\\treturn dist\\n\\tp = list(map(int, input().split()))\\n\\tp.sort()\\n\\tp.insert(0, 0)\\n\\tfor i in range(1, n + 1):\\n\\t\\tg[i].clear()\\n\\tfor i in range(1, m + 1):\\n\\t\\tp[i] = p[i] + p[i - 1]\\n\\tfor i in range(1, m + 1):\\n\\t\\t(u, v) = map(int, input().split())\\n\\t\\tg[u].append(v)\\n\\t\\tg[v].append(u)\\n\\tdist1 = []\\n\\tdist2 = []\\n\\tdist3 = []\\n\\tdist1.extend(BFS(a))\\n\\tdist2.extend(BFS(b))\\n\\tdist3.extend(BFS(c))\\n\\tres = int(1e+17)\\n\\tfor i in range(1, n + 1):\\n\\t\\tif dist1[i] + dist2[i] + dist3[i] > m:\\n\\t\\t\\tcontinue\\n\\t\\tres = min(res, p[dist2[i]] + p[dist1[i] + dist2[i] + dist3[i]])\\n\\tprint(res)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the problem: The task is to minimize the cost of a trip from a to b and then from b to c in a given graph. The prices of the edges can be rearranged to minimize the cost.\\n- Identifying potential strategies: The shortest path between each pair of vertices should be found. The optimal arrangement of prices would involve assigning larger prices to edges that are used less frequently in the shortest paths between the vertices.\\n- Selecting an algorithm strategy: BFS can be used to find the shortest path from a to b, b to c, and a to c. After finding the distances, dynamic programming might be considered to find the minimal cost.  However, a greedy approach after sorting the prices seems more efficient in conjunction with BFS.\\n- Implementation details: Read the input, sort the prices. Calculate shortest path distances from a, b, and c to all other nodes using BFS. Then, iterate through each node `i` and check `dist[a][i] + dist[b][i] + dist[c][i] <= m`. The answer will be `p[dist[b][i]] + p[dist[a][i] + dist[b][i] + dist[c][i]]`.\\n\",\n  \"LLM Questions\": [\n    \"How does sorting the edge prices contribute to finding the minimum trip cost?\",\n    \"How do you efficiently compute the shortest path distances between all relevant pairs of nodes in the graph?\",\n    \"Given the shortest path distances from nodes a, b, and c to every other node, how can you optimally assign the edge prices to minimize the total cost of the trip a -> b -> c?\",\n    \"What is the significance of checking the condition dist1[i] + dist2[i] + dist3[i] <= m in the provided solution?\",\n    \"How would you handle cases where the graph is disconnected or where no path exists between some of the given vertices (a, b, c)?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Sorting the edge prices allows us to greedily assign lower prices to edges that are likely to be used more frequently in shortest paths, thus minimizing the overall trip cost. By sorting the prices in ascending order, the smallest prices can be assigned to the edges shared between several shortest paths.\",\n    \"BFS (Breadth-First Search) is an efficient algorithm to compute the shortest path distances in an unweighted graph. Perform three BFS traversals: starting from node a, from node b, and from node c. This allows you to compute the shortest distance from each of these nodes to all other nodes in the graph.\",\n    \"For each possible intermediate node `i`, consider the paths a -> i -> b and b -> i -> c. The cost of the trip would involve dist(a, i) + dist(i, b) + dist(b, i) + dist(i, c), which simplifies to dist(a, i) + 2*dist(b, i) + dist(c, i).  To minimize the cost, iterate through each node and choose the intermediate node `i` that minimizes the corresponding expression for cost and ensure the prices are assigned optimally using precalculated prefix sums of prices. The optimal price can be calculated using the distances and precomputed sorted price array.\",\n    \"The condition dist1[i] + dist2[i] + dist3[i] <= m ensures that the sum of the distances from nodes a, b, and c to the intermediate node 'i' does not exceed the total number of available edges 'm'. If the sum exceeds 'm', it means that even with the optimal arrangement of prices, the total cost would be extremely high, and such an intermediate node 'i' should be skipped.\",\n    \"If the graph is disconnected, you first need to check for connectivity between the nodes a, b, and c. If no path exists between any pair of these nodes, the trip is impossible, and an appropriate error message or a very high cost value (e.g., infinity) should be returned. If some but not all paths exist, consider the cost to be infinity.\"\n  ]\n}\n```"