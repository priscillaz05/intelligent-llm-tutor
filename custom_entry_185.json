"```json\n{\n  \"Coding Problem\": \"You are given an array $a$ of length $n$.\\n\\nLet's define the eversion operation. Let $x = a_n$. Then array $a$ is partitioned into two parts: left and right. The left part contains the elements of $a$ that are not greater than $x$ ($\\\\le x$). The right part contains the elements of $a$ that are strictly greater than $x$ ($> x$). The order of elements in each part is kept the same as before the operation, i. e. the partition is stable. Then the array is replaced with the concatenation of the left and the right parts.\\n\\nFor example, if the array $a$ is $[2, 4, 1, 5, 3]$, the eversion goes like this: $[2, 4, 1, 5, 3] \\\\to [2, 1, 3], [4, 5] \\\\to [2, 1, 3, 4, 5]$.\\n\\nWe start with the array $a$ and perform eversions on this array. We can prove that after several eversions the array $a$ stops changing. Output the minimum number $k$ such that the array stops changing after $k$ eversions.\\n\\n\\n-----Input-----\\n\\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\\\le t \\\\le 100$). Description of the test cases follows.\\n\\nThe first line contains a single integer $n$ ($1 \\\\le n \\\\le 2 \\\\cdot 10^5$).\\n\\nThe second line contains $n$ integers $a_1, a_2, \\\\dots, a_n$ ($1 \\\\le a_i \\\\le 10^9$).\\n\\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\\\cdot 10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case print a single integer $k$ \u2014 the number of eversions after which the array stops changing.\\n\\n\\n-----Examples-----\\n\\nInput\\n3\\n5\\n2 4 1 5 3\\n5\\n5 3 2 4 1\\n4\\n1 1 1 1\\nOutput\\n1\\n2\\n0\\n\\n\\n-----Note-----\\n\\nConsider the fist example.\\n\\nThe first eversion: $a = [1, 4, 2, 5, 3]$, $x = 3$. $[2, 4, 1, 5, 3] \\\\to [2, 1, 3], [4, 5] \\\\to [2, 1, 3, 4, 5]$.\\n\\nThe second and following eversions: $a = [2, 1, 3, 4, 5]$, $x = 5$. $[2, 1, 3, 4, 5] \\\\to [2, 1, 3, 4, 5], [] \\\\to [2, 1, 3, 4, 5]$. This eversion does not change the array, so the answer is $1$.\\n\\nConsider the second example.\\n\\nThe first eversion: $a = [5, 3, 2, 4, 1]$, $x = 1$. $[5, 3, 2, 4, 1] \\\\to [1], [5, 3, 2, 4] \\\\to [1, 5, 3, 2, 4]$.\\n\\nThe second eversion: $a = [1, 5, 3, 2, 4]$, $x = 4$. $[1, 5, 3, 2, 4] \\\\to [1, 3, 2, 4], [5] \\\\to [1, 3, 2, 4, 5]$.\\n\\nThe third and following eversions: $a = [1, 3, 2, 4, 5]$, $x = 5$. $[1, 3, 2, 4, 5] \\\\to [1, 3, 2, 4, 5], [] \\\\to [1, 3, 2, 4, 5]$. This eversion does not change the array, so the answer is $2$.\",\n  \"Ground Truth Solution\": \"import sys\\n\\ndef _hy_anon_var_2(*_hyx_GXUffffX2):\\n\\n\\tdef solution(arr):\\n\\t\\tmax_elt = 0\\n\\t\\tsteps = -1\\n\\t\\tfor x in reversed(arr):\\n\\t\\t\\tif x > max_elt:\\n\\t\\t\\t\\tsteps += 1\\n\\t\\t\\t\\tmax_elt = x\\n\\t\\t\\t\\t_hy_anon_var_1 = None\\n\\t\\t\\telse:\\n\\t\\t\\t\\t_hy_anon_var_1 = None\\n\\t\\treturn steps\\n\\tt = int(input())\\n\\tfor _ in range(t):\\n\\t\\tn = int(input())\\n\\t\\tarr = list(map(int, input().split()))\\n\\t\\tprint(solution(arr))\\n_hyx_GXUffffX1 = _hy_anon_var_2(*sys.argv)\\n_hy_anon_var_3 = sys.exit(_hyx_GXUffffX1) if isinstance(_hyx_GXUffffX1, int) else None\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Eversion Operation: The key is to simulate the eversion operation. This involves selecting the last element of the array as the pivot, partitioning the array into two parts (less than or equal to the pivot, and greater than the pivot), and then concatenating these two parts.\\n- Recognizing Convergence: The array stops changing when the last element is the maximum of the current array.\\n- Developing an Efficient Algorithm: Because we are looking for the number of eversions until the array stops changing, which effectively happens when the last element is the maximum, we can iterate backwards and check for increasing maximums. Each time the maximum increases, it signifies a new eversion.\",\n  \"LLM Questions\": [\n    \"Could you explain the eversion operation in simpler terms, and what conditions cause the array to converge (stop changing)?\",\n    \"What is the significance of the last element in the array during each eversion?\",\n    \"How would you efficiently determine the number of eversions needed without actually performing the eversion operations repeatedly?\",\n    \"What edge cases or initial conditions should you consider to ensure the algorithm works correctly?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The eversion operation rearranges the array by using the last element as a pivot, placing smaller or equal elements before larger elements. The array converges when the last element of the array is the maximum element of the array, implying no elements are larger and thus no further rearrangement occurs.\",\n    \"The last element acts as a pivot, determining how the array is partitioned. If the last element is the maximum of the current array, no elements will move to the right partition, causing the array to remain the same in the next eversion.\",\n    \"Iterate backwards through the array, keeping track of the largest value seen so far. Every time you find a new largest value, it means the array will be everted. The total number of times this 'largest value' changes is the number of eversions.\",\n    \"Consider the case where the array is already sorted in ascending order. In this case, the answer should be 0 because there is no eversion needed. The algorithm should handle the case of all the same numbers as well.\"\n  ]\n}\n```"