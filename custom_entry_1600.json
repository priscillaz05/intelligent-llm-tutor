"```json\n{\n  \"Coding Problem\": \"Read problem statements in [Hindi], [Bengali], [Mandarin Chinese], [Russian], and [Vietnamese] as well.\\n\\nThe *beauty* of a sequence of non-negative integers is computed in the following way: for each of its non-empty (not necessarily contiguous) subsequences, compute the XOR of all elements of this subsequence; then, sum up all the XORs you obtained.\\n\\nLet $F(N, B)$ denotes the number of non-negative integer sequences with length $N$ which have beauty $B$. You are given three integers $N$, $X$ and $M$. Find the smallest non-negative integer $B$ such that $F(N, B) \\\\bmod M = X$, or determine that there is no such $B$. Since even the smallest such $B$ might be very large, compute its remainder modulo $998,244,353$.\\n\\n------  Input ------\\nThe first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\\nThe first and only line of each test case contains three space-separated integers $N$, $X$ and $M$.\\n\\n------  Output ------\\nFor each test case, print a single line containing one integer \u2015 the smallest valid $B$ (modulo $998,244,353$), or $-1$ if there is no valid $B$.\\n\\n------  Constraints  ------\\n$1 \u2264 T \u2264 100$\\n$1 \u2264 N \u2264 10^{10,000}$\\n$1 \u2264 M \u2264 10^{9}$\\n$0 \u2264 X < M$\\n\\n------  Subtasks ------\\nSubtask #1 (45 points):\\n$N \u2264 10^{9}$\\n$M \u2264 10^{5}$\\n\\nSubtask #2 (55 points): original constraints\\n\\n----- Sample Input 1 ------ \\n3\\n\\n2 2 7\\n\\n4 3 17\\n\\n3 5 13\\n----- Sample Output 1 ------ \\n6\\n\\n-1\\n\\n28\",\n  \"Ground Truth Solution\": \"from math import gcd, sqrt\\nmodul = 998244353\\n\\ndef modiFun(a, b, p):\\n\\ta %= p\\n\\tb %= p\\n\\tif b == 1:\\n\\t\\treturn 0\\n\\t(count, t, g) = (0, 1, gcd(a, p))\\n\\twhile g != 1:\\n\\t\\tif b % g:\\n\\t\\t\\treturn -1\\n\\t\\tp = p // g\\n\\t\\tb = b // g\\n\\t\\tt = int(int(int(t * a) // g) % p)\\n\\t\\tcount += 1\\n\\t\\tif b == t:\\n\\t\\t\\treturn count\\n\\t\\tg = gcd(a, p)\\n\\t(hash, base, m) = ({}, b, int(sqrt(1.0 * p) + 1))\\n\\tfor i in range(m):\\n\\t\\thash[base] = i\\n\\t\\tbase = base * a % p\\n\\t(base, temp) = (pow(a, m, p), t)\\n\\tfor i in range(1, m + 2):\\n\\t\\ttemp = temp * base % p\\n\\t\\tif temp in hash.keys():\\n\\t\\t\\treturn i * m - hash[temp] + count\\n\\treturn -1\\nfor _ in range(int(input())):\\n\\t(n, x, m) = map(int, input().split())\\n\\tif 1 % m == x:\\n\\t\\tprint(0)\\n\\t\\tcontinue\\n\\tif x == 0 and m == 1:\\n\\t\\tprint(0)\\n\\t\\tcontinue\\n\\tif x == 0 and n != 1:\\n\\t\\tprint(1)\\n\\t\\tcontinue\\n\\tvar = (pow(2, n, m) - 1 + m) % m\\n\\tpower = modiFun(var, x, m)\\n\\tif power == -1:\\n\\t\\tprint(-1)\\n\\t\\tcontinue\\n\\tansw = pow(2, n - 1, modul) * (pow(2, power, modul) - 1 + modul) % modul % modul\\n\\tif answ == 0:\\n\\t\\tif 1 % m != x:\\n\\t\\t\\tansw = -1\\n\\tif answ == 1:\\n\\t\\tif 1 % m != x or n != -1:\\n\\t\\t\\tansw -= 1\\n\\tprint(answ)\",\n  \"LLM CoT Steps Breakdown\": \"- Understand the Problem: The beauty of a sequence is calculated by summing the XOR of all its non-empty subsequences.  The goal is to find the smallest B such that F(N, B) mod M = X.\\n- Identify Key Constraints: N can be very large (up to 10^10000), M is up to 10^9, and X is less than M. The answer must be modulo 998244353.\\n- Develop a Strategy:  The problem requires finding a specific B that satisfies a modular equation.  Since N can be extremely large, we need to use modular arithmetic to efficiently calculate powers of 2. The F(N, B) can be represented as 2^(N-1) * B. Thus, the equation to solve can be expressed as  2^(N-1) * B % M = X.  Therefore, B = X * inverse(2^(N-1)) % M, so the inverse of 2^(N-1) under modulo M needs to be computed.\\n- Consider Edge Cases: Check for cases where the inverse doesn't exist, or if the resulting B doesn't meet the problem's conditions.\",\n  \"LLM Questions\": [\n    \"What is the definition of the 'beauty' of a sequence in this problem?\",\n    \"How does the problem's constraint that N can be extremely large influence your solution?\",\n    \"How do you compute F(N, B) efficiently, considering modular arithmetic and the properties of XOR?\",\n    \"How do you find the smallest B that satisfies the given condition F(N, B) mod M = X?\",\n    \"What edge cases might exist, and how can they be handled?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The beauty of a sequence is the sum of the XORs of all its non-empty subsequences.\",\n    \"Since N can be up to 10^10000, we need to rely on modular arithmetic to compute powers of 2 and avoid very large numbers that cannot be stored directly. Large N also means that precomputation of factorials or other quantities becomes infeasible.\",\n    \"F(N, B) can be simplified to calculating  2^(N-1) * B. This can be computed using fast modular exponentiation to find 2^(N-1) mod M. Use this result to find B efficiently.\",\n    \"The required condition translates to the equation (2^(N-1) * B) % M = X. Therefore, one approach is to calculate the modular inverse of 2^(N-1) modulo M, and then compute B as (X * inverse(2^(N-1))) % M.\",\n    \"Edge cases include when M = 1, which makes X = 0 and B = 0, and when the modular inverse of 2^(N-1) does not exist modulo M, which implies that no valid B exists, so the function should return -1. Other special cases are when X = 0.  Also when N=1.  It's important to check if the computed B actually satisfies F(N,B) mod M = X.\"\n  ]\n}\n```"