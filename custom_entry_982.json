"```json\n{\n  \"Coding Problem\": \"Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\\n\\nSo imagine Monocarp got recommended $n$ songs, numbered from $1$ to $n$. The $i$-th song had its predicted rating equal to $p_i$, where $1 \\\\le p_i \\\\le n$ and every integer from $1$ to $n$ appears exactly once. In other words, $p$ is a permutation.\\n\\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string $s$, such that $s_i=0$ means that he disliked the $i$-th song, and $s_i=1$ means that he liked it.\\n\\nNow the service has to re-evaluate the song ratings in such a way that:\\n\\nthe new ratings $q_1, q_2, \\\\dots, q_n$ still form a permutation ($1 \\\\le q_i \\\\le n$; each integer from $1$ to $n$ appears exactly once);\\n\\nevery song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all $i, j$ such that $s_i=1$ and $s_j=0$, $q_i>q_j$ should hold).\\n\\nAmong all valid permutations $q$ find the one that has the smallest value of $\\\\sum\\\\limits_{i=1}^n |p_i-q_i|$, where $|x|$ is an absolute value of $x$.\\n\\nPrint the permutation $q_1, q_2, \\\\dots, q_n$. If there are multiple answers, you can print any of them.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $t$ ($1 \\\\le t \\\\le 10^4$) \u2014 the number of testcases.\\n\\nThe first line of each testcase contains a single integer $n$ ($1 \\\\le n \\\\le 2 \\\\cdot 10^5$) \u2014 the number of songs.\\n\\nThe second line of each testcase contains $n$ integers $p_1, p_2, \\\\dots, p_n$ ($1 \\\\le p_i \\\\le n$) \u2014 the permutation of the predicted ratings.\\n\\nThe third line contains a single string $s$, consisting of $n$ characters. Each character is either a $0$ or a $1$. $0$ means that Monocarp disliked the song, and $1$ means that he liked it.\\n\\nThe sum of $n$ over all testcases doesn't exceed $2 \\\\cdot 10^5$.\\n\\n\\n-----Output-----\\n\\nFor each testcase, print a permutation $q$ \u2014 the re-evaluated ratings of the songs. If there are multiple answers such that $\\\\sum\\\\limits_{i=1}^n |p_i-q_i|$ is minimum possible, you can print any of them.\\n\\n\\n-----Examples-----\\n\\nInput\\n3\\n2\\n1 2\\n10\\n3\\n3 1 2\\n111\\n8\\n2 3 1 8 5 4 7 6\\n01110001\\nOutput\\n2 1\\n3 1 2\\n1 6 5 8 3 2 4 7\\n\\n\\n-----Note-----\\n\\nIn the first testcase, there exists only one permutation $q$ such that each liked song is rating higher than each disliked song: song $1$ gets rating $2$ and song $2$ gets rating $1$. $\\\\sum\\\\limits_{i=1}^n |p_i-q_i|=|1-2|+|2-1|=2$.\\n\\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to $p$. Its cost is $0$.\",\n  \"Ground Truth Solution\": \"for _ in range(int(input())):\\n\\tn = int(input())\\n\\tp = list(map(int, input().split()))\\n\\ts = input()\\n\\tliked = []\\n\\tdisliked = []\\n\\tfor i in range(n):\\n\\t\\tif s[i] == '1':\\n\\t\\t\\tliked.append([p[i], i])\\n\\t\\telse:\\n\\t\\t\\tdisliked.append([p[i], i])\\n\\tliked.sort()\\n\\tdisliked.sort()\\n\\tperm = 1\\n\\tfinal = [0] * n\\n\\tfor _ in disliked:\\n\\t\\tfinal[_[1]] = perm\\n\\t\\tperm += 1\\n\\tfor _ in liked:\\n\\t\\tfinal[_[1]] = perm\\n\\t\\tperm += 1\\n\\tprint(*final)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires assigning new ratings to songs such that liked songs have higher ratings than disliked songs. The goal is to minimize the sum of absolute differences between old and new ratings.\\n- Identifying Constraints: The new ratings must form a permutation of numbers from 1 to n. Liked songs must have higher ratings than disliked songs. The sum of absolute differences between original and new ratings must be minimized.\\n- Algorithmic Strategy: Sort the songs into liked and disliked categories. Sort each category based on the original rating. Assign new ratings from 1 to n, giving lower ratings to disliked songs and higher ratings to liked songs. The sorted order within liked and disliked songs helps minimize the absolute differences.\\n- Edge Cases: Consider the case where all songs are liked or disliked. Ensure the correct assignment of ratings to indices.\",\n  \"LLM Questions\": [\n    \"How do you ensure that all liked songs have higher ratings than all disliked songs in the re-evaluated ratings?\",\n    \"What is the significance of sorting the liked and disliked songs by their original ratings, and how does it affect the minimization of the sum of absolute differences?\",\n    \"How do you handle the case where all songs are either liked or disliked?\",\n    \"How do you efficiently assign the new ratings (1 to n) to the songs based on their likes/dislikes and original ratings?\",\n    \"How do you reconstruct the final permutation based on the assigned ratings and original indices of the songs?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"By assigning all the lower ratings to the disliked songs and the higher ratings to the liked songs.\",\n    \"Sorting the songs by original ratings within liked and disliked categories helps ensure that songs with closer original ratings receive closer new ratings, thereby minimizing the sum of absolute differences.\",\n    \"If all songs are liked or all are disliked, any permutation is valid. Sorting based on original ratings minimizes the sum of absolute differences.\",\n    \"First, sort songs into 'liked' and 'disliked' lists based on the input string 's'. Then, sort each list by the song's original rating 'p'. Finally, iterate through disliked songs assigning ratings 1 to k and through liked songs assigning ratings k+1 to n.\",\n    \"Store the index of each song along with its original rating and like/dislike status. After assigning new ratings, use these indices to reconstruct the final permutation where the value at each index is the new rating.\"\n  ]\n}\n```"