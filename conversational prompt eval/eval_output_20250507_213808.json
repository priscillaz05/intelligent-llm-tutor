[
  {
    "problem": "There are $n$ candy boxes in front of Tania. The boxes are arranged in a row from left to right, numbered from $1$ to $n$. The $i$-th box contains $r_i$ candies, candies have the color $c_i$ (the color can take one of three values \u200b\u200b\u2014 red, green, or blue). All candies inside a single box have the same color (and it is equal to $c_i$).\n\nInitially, Tanya is next to the box number $s$. Tanya can move to the neighbor box (that is, with a number that differs by one) or eat candies in the current box. Tanya eats candies instantly, but the movement takes one second.\n\nIf Tanya eats candies from the box, then the box itself remains in place, but there is no more candies in it. In other words, Tanya always eats all the candies from the box and candies in the boxes are not refilled.\n\nIt is known that Tanya cannot eat candies of the same color one after another (that is, the colors of candies in two consecutive boxes from which she eats candies are always different). In addition, Tanya's appetite is constantly growing, so in each next box from which she eats candies, there should be strictly more candies than in the previous one.\n\nNote that for the first box from which Tanya will eat candies, there are no restrictions on the color and number of candies.\n\nTanya wants to eat at least $k$ candies. What is the minimum number of seconds she will need? Remember that she eats candies instantly, and time is spent only on movements.\n\n\n-----Input-----\n\nThe first line contains three integers $n$, $s$ and $k$ ($1 \\le n \\le 50$, $1 \\le s \\le n$, $1 \\le k \\le 2000$) \u2014 number of the boxes, initial position of Tanya and lower bound on number of candies to eat. The following line contains $n$ integers $r_i$ ($1 \\le r_i \\le 50$) \u2014 numbers of candies in the boxes. The third line contains sequence of $n$ letters 'R', 'G' and 'B', meaning the colors of candies in the correspondent boxes ('R' for red, 'G' for green, 'B' for blue). Recall that each box contains candies of only one color. The third line contains no spaces.\n\n\n-----Output-----\n\nPrint minimal number of seconds to eat at least $k$ candies. If solution doesn't exist, print \"-1\".\n\n\n-----Examples-----\nInput\n5 3 10\n1 2 3 4 5\nRGBRR\n\nOutput\n4\n\nInput\n2 1 15\n5 6\nRG\n\nOutput\n-1\n\n\n\n-----Note-----\n\nThe sequence of actions of Tanya for the first example:\n\n  move from the box $3$ to the box $2$;  eat candies from the box $2$;  move from the box $2$ to the box $3$;  eat candy from the box $3$;  move from the box $3$ to the box $4$;  move from the box $4$ to the box $5$;  eat candies from the box $5$. \n\nSince Tanya eats candy instantly, the required time is four seconds.",
    "solution": "INF = 10000000000.0\nmax_n = 50\nmax_k = 2000\n\ndef main():\n\t(n, s, k) = map(int, input().split())\n\ts -= 1\n\tbuf = [''] * (max_n + 1)\n\tdp = [[0 for i in range(max_n + 1)] for j in range(max_k + 1)]\n\tr = list(map(int, input().split()))\n\tc = input()\n\tanswer = INF\n\tfor i in range(len(c)):\n\t\tbuf[i] = c[i]\n\tfor i in range(k, -1, -1):\n\t\tfor j in range(n):\n\t\t\tdp[i][j] = INF\n\tfor j in range(n):\n\t\tvalue = abs(j - s)\n\t\tif k - r[j] <= 0:\n\t\t\tanswer = min(answer, value)\n\t\telse:\n\t\t\tdp[k - r[j]][j] = value\n\tfor i in range(k, 0, -1):\n\t\tfor j in range(n):\n\t\t\tif dp[i][j] < INF:\n\t\t\t\tfor l in range(n):\n\t\t\t\t\tif buf[j] != buf[l] and r[j] < r[l]:\n\t\t\t\t\t\tvalue = dp[i][j] + abs(j - l)\n\t\t\t\t\t\tif i - r[l] <= 0:\n\t\t\t\t\t\t\tanswer = min(answer, value)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tdp[i - r[l]][l] = min(dp[i - r[l]][l], value)\n\tif answer == INF:\n\t\tprint(-1)\n\t\treturn\n\tprint(answer)\n\ndef __starting_point():\n\tmain()\n__starting_point()\n",
    "input_output": {
      "inputs": [
        "5 3 10\n1 2 3 4 5\nRGBRR\n",
        "2 1 15\n5 6\nRG\n",
        "6 1 21\n4 2 3 5 1 6\nRGBGRB\n",
        "6 1 21\n6 5 4 3 2 1\nRGBRGB\n",
        "1 1 10\n10\nR\n",
        "2 1 10\n5 5\nRG\n",
        "2 1 10\n5 6\nRR\n",
        "5 3 10\n1 2 3 4 5\nRGBRG\n",
        "9 1 6\n1 1 1 3 3 3 2 2 2\nRGGBRRGBB\n",
        "50 39 2000\n48 43 26 24 46 37 15 30 39 34 4 14 29 34 8 18 40 8 17 37 15 29 2 23 41 7 12 13 36 11 24 22 26 46 11 31 10 46 11 35 6 41 16 50 11 1 46 20 46 28\nBGBBBBBBRGGBBBRRRRBBGRGGRBBRBBBRBBBBBRRGBGGRRRBBRB\n",
        "50 49 1000\n30 37 34 31 26 44 32 12 36 15 5 5 31 24 17 24 43 19 17 23 45 2 24 17 23 48 20 44 46 44 13 4 29 49 33 41 14 25 46 43 7 47 28 25 2 30 37 37 19 32\nGBBBRBGRBRBRGRGRBBGBGRRBGGRBGRBRRRRRRRBRGRGGGGBRGG\n",
        "50 32 600\n21 21 18 47 16 11 10 46 9 15 27 5 11 42 29 25 16 41 31 8 12 28 1 24 17 40 45 12 33 32 34 2 45 17 49 17 20 42 15 17 8 29 2 20 4 27 50 1 49 1\nBBRBBGBGBBRBGRRGRGGGBGBRRBBBGGBBBBGBGBRBBGRRGGBRGR\n",
        "50 37 500\n25 43 15 16 29 23 46 18 15 21 33 26 38 25 2 17 48 50 33 31 3 45 40 12 42 29 37 42 7 11 47 16 44 17 27 46 32 23 14 7 27 25 13 32 43 33 36 39 35 7\nGGBBRGBRRRRBBRGBRRRGGRGGRGGBRRRGBBRRGRGGRBGBGGRGBR\n",
        "50 4 200\n14 10 50 47 41 9 22 21 42 36 50 10 27 28 39 1 36 12 45 35 17 3 15 25 32 4 34 39 44 34 20 15 18 1 38 25 20 45 24 9 18 15 35 36 12 9 28 4 44 10\nBGBRRBGBRRRGRGRBRGGGRBRRGBBGGRBRRGGRGGGBRRBRGGBGBG\n",
        "50 50 1250\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGG\n",
        "30 28 208\n3 42 42 47 46 44 5 28 35 28 35 44 25 44 47 3 3 35 28 5 3 42 3 46 25 25 5 47 46 3\nBGBBGBBBBGRRGGGBRGRGRRGBBRRRRG\n",
        "39 21 282\n13 39 20 29 30 14 29 29 30 29 16 39 50 13 16 45 36 36 13 20 29 21 34 36 39 30 34 21 20 14 16 45 21 45 29 34 50 50 14\nGGGBRRGRBGBRRBRGRBRBBGBGBGRRRGGRBBRGBGB\n",
        "48 2 259\n25 31 22 30 30 17 31 50 28 30 46 43 4 6 10 22 50 14 5 46 12 6 46 3 17 12 4 28 25 14 5 5 6 14 22 12 17 43 43 10 4 3 31 3 25 28 50 10\nBBBBGGRRBRRBBRGGGBGGRGBRBGRGRGRBBRRBRRGBGBGGGRBR\n",
        "48 25 323\n39 37 32 4 4 32 18 44 49 4 12 12 12 22 22 37 38 32 24 45 44 37 18 39 45 22 24 22 45 39 4 22 24 22 12 49 4 29 18 38 29 29 38 44 12 12 49 4\nRRRRRBRRGBBRGRGGBGGBGBBBRBRGGGGBBRGRBGGGRBRBBRBG\n",
        "48 33 357\n18 37 22 21 4 17 39 32 40 43 29 29 50 21 39 43 11 11 4 50 36 40 32 50 18 32 11 36 29 36 22 21 29 43 49 18 17 29 37 40 17 37 49 4 39 49 22 29\nGRGGGGBRBRRGGRGBRGBBGRBRRGBBRRBBBGRBBBBGRGGRRBRG\n",
        "50 50 2000\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "30 28 208\n3 42 42 47 46 44 5 28 35 28 35 44 25 44 47 3 3 35 28 5 3 42 3 46 25 25 5 47 46 3\nBGBBGBBBBGRRGGGBRGRGRRGBBRRRRG\n",
        "50 39 2000\n48 43 26 24 46 37 15 30 39 34 4 14 29 34 8 18 40 8 17 37 15 29 2 23 41 7 12 13 36 11 24 22 26 46 11 31 10 46 11 35 6 41 16 50 11 1 46 20 46 28\nBGBBBBBBRGGBBBRRRRBBGRGGRBBRBBBRBBBBBRRGBGGRRRBBRB\n",
        "50 32 600\n21 21 18 47 16 11 10 46 9 15 27 5 11 42 29 25 16 41 31 8 12 28 1 24 17 40 45 12 33 32 34 2 45 17 49 17 20 42 15 17 8 29 2 20 4 27 50 1 49 1\nBBRBBGBGBBRBGRRGRGGGBGBRRBBBGGBBBBGBGBRBBGRRGGBRGR\n",
        "48 2 259\n25 31 22 30 30 17 31 50 28 30 46 43 4 6 10 22 50 14 5 46 12 6 46 3 17 12 4 28 25 14 5 5 6 14 22 12 17 43 43 10 4 3 31 3 25 28 50 10\nBBBBGGRRBRRBBRGGGBGGRGBRBGRGRGRBBRRBRRGBGBGGGRBR\n",
        "1 1 10\n10\nR\n",
        "9 1 6\n1 1 1 3 3 3 2 2 2\nRGGBRRGBB\n",
        "5 3 10\n1 2 3 4 5\nRGBRG\n",
        "6 1 21\n6 5 4 3 2 1\nRGBRGB\n",
        "2 1 10\n5 5\nRG\n",
        "2 1 10\n5 6\nRR\n",
        "50 50 2000\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "48 33 357\n18 37 22 21 4 17 39 32 40 43 29 29 50 21 39 43 11 11 4 50 36 40 32 50 18 32 11 36 29 36 22 21 29 43 49 18 17 29 37 40 17 37 49 4 39 49 22 29\nGRGGGGBRBRRGGRGBRGBBGRBRRGBBRRBBBGRBBBBGRGGRRBRG\n",
        "48 25 323\n39 37 32 4 4 32 18 44 49 4 12 12 12 22 22 37 38 32 24 45 44 37 18 39 45 22 24 22 45 39 4 22 24 22 12 49 4 29 18 38 29 29 38 44 12 12 49 4\nRRRRRBRRGBBRGRGGBGGBGBBBRBRGGGGBBRGRBGGGRBRBBRBG\n",
        "39 21 282\n13 39 20 29 30 14 29 29 30 29 16 39 50 13 16 45 36 36 13 20 29 21 34 36 39 30 34 21 20 14 16 45 21 45 29 34 50 50 14\nGGGBRRGRBGBRRBRGRBRBBGBGBGRRRGGRBBRGBGB\n",
        "50 49 1000\n30 37 34 31 26 44 32 12 36 15 5 5 31 24 17 24 43 19 17 23 45 2 24 17 23 48 20 44 46 44 13 4 29 49 33 41 14 25 46 43 7 47 28 25 2 30 37 37 19 32\nGBBBRBGRBRBRGRGRBBGBGRRBGGRBGRBRRRRRRRBRGRGGGGBRGG\n",
        "50 4 200\n14 10 50 47 41 9 22 21 42 36 50 10 27 28 39 1 36 12 45 35 17 3 15 25 32 4 34 39 44 34 20 15 18 1 38 25 20 45 24 9 18 15 35 36 12 9 28 4 44 10\nBGBRRBGBRRRGRGRBRGGGRBRRGBBGGRBRRGGRGGGBRRBRGGBGBG\n",
        "6 1 21\n4 2 3 5 1 6\nRGBGRB\n",
        "50 37 500\n25 43 15 16 29 23 46 18 15 21 33 26 38 25 2 17 48 50 33 31 3 45 40 12 42 29 37 42 7 11 47 16 44 17 27 46 32 23 14 7 27 25 13 32 43 33 36 39 35 7\nGGBBRGBRRRRBBRGBRRRGGRGGRGGBRRRGBBRRGRGGRBGBGGRGBR\n",
        "50 50 1250\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGG\n",
        "50 39 2000\n48 43 26 24 46 37 15 30 39 34 4 14 29 34 8 18 40 8 17 37 15 29 2 23 41 7 12 13 36 11 24 22 26 46 11 31 1 46 11 35 6 41 16 50 11 1 46 20 46 28\nBGBBBBBBRGGBBBRRRRBBGRGGRBBRBBBRBBBBBRRGBGGRRRBBRB\n",
        "48 2 259\n25 31 22 30 30 17 31 50 28 30 46 43 4 6 10 22 50 14 5 46 12 6 46 3 17 12 4 28 25 21 5 5 6 14 22 12 17 43 43 10 4 3 31 3 25 28 50 10\nBBBBGGRRBRRBBRGGGBGGRGBRBGRGRGRBBRRBRRGBGBGGGRBR\n",
        "9 1 6\n1 1 2 3 3 3 2 2 2\nRGGBRRGBB\n",
        "2 1 10\n9 5\nRG\n",
        "48 33 357\n18 37 22 21 4 17 39 32 40 43 29 29 50 21 39 43 11 11 4 50 36 40 32 50 18 32 11 36 29 36 22 21 29 43 49 18 17 29 37 40 17 37 2 4 39 49 22 29\nGRGGGGBRBRRGGRGBRGBBGRBRRGBBRRBBBGRBBBBGRGGRRBRG\n",
        "39 21 282\n13 39 20 29 30 14 29 29 30 29 16 39 50 13 16 45 36 36 13 10 29 21 34 36 39 30 34 21 20 14 16 45 21 45 29 34 50 50 14\nGGGBRRGRBGBRRBRGRBRBBGBGBGRRRGGRBBRGBGB\n",
        "50 37 500\n25 43 15 16 29 23 46 18 15 21 33 26 38 25 2 17 48 50 33 31 3 23 40 12 42 29 37 42 7 11 47 16 44 17 27 46 32 23 14 7 27 25 13 32 43 33 36 39 35 7\nGGBBRGBRRRRBBRGBRRRGGRGGRGGBRRRGBBRRGRGGRBGBGGRGBR\n",
        "39 36 282\n13 39 20 29 30 14 29 29 30 29 16 39 50 13 16 45 36 36 13 10 29 21 34 36 39 30 34 21 20 14 16 45 21 45 29 34 50 50 14\nGGGBRRGRBGBRRBRGRBRBBGBGBGRRRGGRBBRGBGB\n",
        "30 28 208\n3 42 42 47 46 12 5 28 35 28 35 44 25 44 47 3 3 35 28 5 3 42 3 46 25 25 5 47 46 3\nBGBBGBBBBGRRGGGBRGRGRRGBBRRRRG\n",
        "9 1 6\n1 1 1 3 3 6 2 2 2\nRGGBRRGBB\n",
        "5 3 10\n1 2 4 4 5\nRGBRG\n",
        "39 21 282\n13 39 20 29 30 14 29 29 30 29 16 39 50 13 16 45 36 36 13 20 44 21 34 36 39 30 34 21 20 14 16 45 21 45 29 34 50 50 14\nGGGBRRGRBGBRRBRGRBRBBGBGBGRRRGGRBBRGBGB\n",
        "50 4 200\n14 10 50 47 41 9 22 21 42 36 50 10 27 28 39 1 36 12 45 35 17 3 15 25 32 4 34 39 44 34 20 15 18 1 38 25 20 3 24 9 18 15 35 36 12 9 28 4 44 10\nBGBRRBGBRRRGRGRBRGGGRBRRGBBGGRBRRGGRGGGBRRBRGGBGBG\n",
        "6 1 21\n6 5 4 3 4 1\nRGBRGB\n",
        "50 50 2000\n1 3 5 7 9 11 13 15 32 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "50 49 1000\n30 37 34 31 26 44 32 12 36 15 5 5 31 24 17 24 43 19 17 23 45 2 24 17 23 48 20 44 46 44 13 4 29 49 23 41 14 25 46 43 7 47 28 25 2 30 37 37 19 32\nGBBBRBGRBRBRGRGRBBGBGRRBGGRBGRBRRRRRRRBRGRGGGGBRGG\n",
        "6 1 21\n4 2 3 5 1 6\nRGBRGB\n",
        "50 50 1250\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 11 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGG\n",
        "2 1 24\n5 6\nRG\n",
        "48 2 259\n25 31 22 30 30 17 31 50 28 30 46 43 4 6 10 22 50 27 5 46 12 6 46 3 17 12 4 28 25 21 5 5 6 14 22 12 17 43 43 10 4 3 31 3 25 28 50 10\nBBBBGGRRBRRBBRGGGBGGRGBRBGRGRGRBBRRBRRGBGBGGGRBR\n",
        "9 1 6\n1 1 2 5 3 3 2 2 2\nRGGBRRGBB\n",
        "50 50 2000\n1 3 5 7 9 11 13 15 32 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 46 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "50 49 1000\n30 37 34 31 26 44 32 12 36 15 5 5 31 24 17 24 43 19 17 23 45 2 24 17 23 48 20 44 46 44 13 4 29 49 23 15 14 25 46 43 7 47 28 25 2 30 37 37 19 32\nGBBBRBGRBRBRGRGRBBGBGRRBGGRBGRBRRRRRRRBRGRGGGGBRGG\n",
        "6 1 21\n4 2 3 5 1 6\nBGRBGR\n",
        "50 50 1250\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 11 44 42 40 38 36 34 32 44 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGG\n",
        "9 1 6\n1 1 1 5 3 3 2 2 2\nRGGBRRGBB\n",
        "50 50 2000\n1 3 5 7 9 11 13 15 32 19 21 32 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 46 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "39 36 282\n13 39 20 29 30 14 29 29 30 29 16 39 50 13 16 45 36 36 13 10 29 21 34 36 39 30 34 21 21 14 16 45 21 45 29 34 50 50 14\nGGGBRRGRBGBRRBRGRBRBBGBGBGRRRGGRBBRGBGB\n",
        "50 49 1000\n30 37 34 31 26 44 32 12 36 15 5 5 31 24 17 24 43 19 17 23 45 2 24 17 23 48 20 44 46 44 13 4 29 49 23 15 14 25 46 43 7 47 28 50 2 30 37 37 19 32\nGBBBRBGRBRBRGRGRBBGBGRRBGGRBGRBRRRRRRRBRGRGGGGBRGG\n",
        "6 1 21\n5 2 3 5 1 6\nBGRBGR\n",
        "50 50 1250\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 11 44 42 40 38 36 34 32 44 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRR\n",
        "9 1 6\n1 1 1 5 3 1 2 2 2\nRGGBRRGBB\n",
        "50 50 2000\n1 3 5 7 9 11 13 15 32 19 21 32 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 46 36 34 32 30 28 26 24 22 20 18 16 14 12 10 1 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "50 49 1000\n30 37 34 31 26 44 32 12 36 15 5 5 31 24 17 24 43 19 17 23 45 2 24 17 23 48 20 44 46 44 13 4 40 49 23 15 14 25 46 43 7 47 28 50 2 30 37 37 19 32\nGBBBRBGRBRBRGRGRBBGBGRRBGGRBGRBRRRRRRRBRGRGGGGBRGG\n",
        "50 50 1250\n1 3 5 7 9 11 13 15 17 17 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 11 44 42 40 38 36 34 32 44 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGGGGGGGGGGGGGGGGGGGGGGGGGRRRRRRRRRRRRRRRRRRRRRRRRR\n",
        "9 1 6\n1 1 1 5 3 1 4 2 2\nRGGBRRGBB\n",
        "50 50 2000\n1 3 7 7 9 11 13 15 32 19 21 32 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 46 36 34 32 30 28 26 24 22 20 18 16 14 12 10 1 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "50 50 2000\n1 3 7 7 9 11 13 15 32 19 21 32 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 46 36 34 32 30 28 26 24 22 20 18 16 14 12 10 1 10 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "50 50 2000\n1 3 7 7 9 11 13 15 32 19 21 32 25 10 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 46 36 34 32 30 28 26 24 22 20 18 16 14 12 10 1 10 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "50 50 2000\n1 3 7 7 9 11 13 15 32 19 21 32 25 10 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 46 36 34 32 30 28 26 24 22 20 18 16 14 12 10 1 10 6 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "50 39 2000\n48 43 26 24 46 37 15 30 39 34 4 14 29 34 8 18 40 8 17 40 15 29 2 23 41 7 12 13 36 11 24 22 26 46 11 31 10 46 11 35 6 41 16 50 11 1 46 20 46 28\nBGBBBBBBRGGBBBRRRRBBGRGGRBBRBBBRBBBBBRRGBGGRRRBBRB\n",
        "48 2 259\n25 31 22 30 30 17 31 50 28 30 46 43 4 6 10 22 50 14 5 46 12 6 46 4 17 12 4 28 25 14 5 5 6 14 22 12 17 43 43 10 4 3 31 3 25 28 50 10\nBBBBGGRRBRRBBRGGGBGGRGBRBGRGRGRBBRRBRRGBGBGGGRBR\n",
        "1 1 20\n10\nR\n",
        "2 1 16\n5 5\nRG\n",
        "2 1 10\n1 6\nRR\n",
        "50 50 2000\n1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 7 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nGRGRGBBGGRGGRRRGGBGGGRRRBGRRBGBRGBBGGGGRRGGBBRRRRG\n",
        "48 33 357\n18 37 22 21 4 17 39 32 40 43 29 29 50 21 39 43 11 11 4 50 36 40 32 50 18 32 11 36 29 36 22 21 29 43 49 18 17 29 37 40 17 43 49 4 39 49 22 29\nGRGGGGBRBRRGGRGBRGBBGRBRRGBBRRBBBGRBBBBGRGGRRBRG\n",
        "50 49 1000\n30 37 34 31 26 44 32 12 36 15 5 5 31 24 17 24 43 19 17 23 45 2 31 17 23 48 20 44 46 44 13 4 29 49 33 41 14 25 46 43 7 47 28 25 2 30 37 37 19 32\nGBBBRBGRBRBRGRGRBBGBGRRBGGRBGRBRRRRRRRBRGRGGGGBRGG\n",
        "6 1 21\n4 2 3 2 1 6\nRGBGRB\n",
        "50 50 1250\n1 3 5 7 9 11 13 15 17 19 21 1 25 27 29 31 33 35 37 39 41 43 45 47 49 50 48 46 44 42 40 38 36 34 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2\nRRRRRRRRRRRRRRRRRRRRRRRRRGGGGGGGGGGGGGGGGGGGGGGGGG\n",
        "2 1 15\n5 1\nRG\n",
        "50 39 2000\n48 43 26 24 46 37 15 30 36 34 4 14 29 34 8 18 40 8 17 37 15 29 2 23 41 7 12 13 36 11 24 22 26 46 11 31 1 46 11 35 6 41 16 50 11 1 46 20 46 28\nBGBBBBBBRGGBBBRRRRBBGRGGRBBRBBBRBBBBBRRGBGGRRRBBRB\n",
        "2 1 15\n5 6\nRG\n",
        "5 3 10\n1 2 3 4 5\nRGBRR\n"
      ],
      "outputs": [
        "4\n",
        "-1\n",
        "15\n",
        "10\n",
        "0\n",
        "-1\n",
        "-1\n",
        "2\n",
        "7\n",
        "-1\n",
        "-1\n",
        "185\n",
        "86\n",
        "23\n",
        "992\n",
        "20\n",
        "24\n",
        "39\n",
        "64\n",
        "63\n",
        "-1\n",
        "20\n",
        "-1\n",
        "185\n",
        "39\n",
        "0\n",
        "7\n",
        "2\n",
        "10\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "63\n",
        "64\n",
        "24\n",
        "-1\n",
        "23\n",
        "15\n",
        "86\n",
        "992",
        "-1\n",
        "39\n",
        "3\n",
        "2\n",
        "63\n",
        "24\n",
        "86\n",
        "31\n",
        "20\n",
        "5\n",
        "4\n",
        "28\n",
        "23\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "39\n",
        "3\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "3\n",
        "-1\n",
        "31\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "3\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "3\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "39\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "63\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "-1\n",
        "4\n"
      ]
    },
    "tags": [
      "Dynamic programming"
    ],
    "skill_types": [
      "Dynamic programming"
    ],
    "confusions": [
      "Could you explain the problem statement in simpler terms, perhaps with a smaller example?",
      "What is the significance of Tanya's starting position 's' in determining the minimum time?",
      "How should I represent the state of the problem in my code? What variables are important to track?",
      "Since this is a dynamic programming problem, what would be the base cases for the recursion or iteration?",
      "How do I handle the color constraint (Tanya cannot eat candies of the same color one after another)?",
      "How do I handle the increasing appetite constraint (each next box should have strictly more candies than the previous one)?",
      "What should I do if Tanya cannot eat at least 'k' candies given the constraints?",
      "Could you provide a high-level overview of the algorithm I should use?",
      "How do I efficiently explore all possible paths Tanya can take?",
      "How can I use memoization to avoid redundant calculations and improve the efficiency of the solution?",
      "What is the time complexity of the dynamic programming approach?",
      "How do I convert the sequence of R, G, B colors into a more usable data structure (e.g., an array of enums or integers)?",
      "When implementing the DP, what are the dimensions of the DP table and what do they represent?",
      "Can you give me an example of how to transition from one state to another in the DP table?",
      "How do I reconstruct the optimal path (if needed) to calculate the minimum time?",
      "If I am using recursion with memoization, how do I handle the case where no solution is possible (i.e., return -1)?",
      "How can I test my code to ensure it handles all edge cases correctly?",
      "What are some common mistakes to avoid when solving this problem?",
      "Is there a top-down (recursion with memoization) or bottom-up (iteration) approach that is better suited for this particular problem? Why?"
    ],
    "helps": [
      "Can you rephrase the problem in terms of finding the shortest path in a graph where nodes represent the current state (position, last color eaten, candies eaten, number of candies eaten)?",
      "How does the initial position affect the possible moves and the cost associated with each move?",
      "What information is essential to know at each step to determine the next valid move (e.g., current position, last color eaten, total candies eaten)?",
      "What is the minimum number of candies Tanya needs to eat to satisfy the condition, and what state would represent this condition being met?",
      "How can you use a conditional statement to check if the current candy color is different from the last candy color eaten?",
      "Before considering eating from a box, how would you verify if the number of candies in that box is greater than the number of candies in the previously eaten box?",
      "What value should you return if you explore all possible paths and still haven't found a way for Tanya to eat at least 'k' candies?",
      "Could you outline the steps needed to explore all possible move and eat combinations using a dynamic programming or recursive approach?",
      "What are the possible actions Tanya can take from each box (move left, move right, eat)? How does each action affect the state?",
      "What values are you storing in your memoization table and how can you check for a valid value that is already memoized?",
      "How many states are possible? Consider the maximum values for the number of boxes, candies to eat, and colors.",
      "How can you efficiently store the color information to allow for quick comparisons?",
      "If you were using a DP table dp[i][j], what could 'i' and 'j' represent? For example, i could represent the amount of candies eaten so far and j represent the current position.",
      "Consider you are at box x, have eaten y candies so far, and your last eaten candy color was z. If box l is your next box and you decide to eat from that box, what operations will you perform on your state and what are the values you will use to transition to your next state?",
      "How would you store the series of moves, or more importantly, how would you update your path as you move from position to position and eat candy?",
      "In a recursive function, what condition must be met for the function to return -1 (no solution)? What about the base case that satisfies the goal?",
      "Have you considered edge cases like starting at a box with a large amount of candy and not needing to move? Or cases where the candies are all too few or the same color?",
      "Think about cases where the starting position doesn't allow reaching all the boxes or the colors are arranged in a way that violates the eating rules. What are some possible corner cases?",
      "Does the recursive top-down approach allow for a more intuitive representation of the problem's constraints, or does the iterative bottom-up approach allow better tracking the number of candies eaten?"
    ]
  },
  {
    "problem": "If you visit Aizu Akabeko shrine, you will find a unique paper fortune on which a number with more than one digit is written.\n\nEach digit ranges from 1 to 9 (zero is avoided because it is considered a bad omen in this shrine). Using this string of numeric values, you can predict how many years it will take before your dream comes true. Cut up the string into more than one segment and compare their values. The difference between the largest and smallest value will give you the number of years before your wish will be fulfilled. Therefore, the result varies depending on the way you cut up the string. For example, if you are given a string 11121314 and divide it into segments, say, as 1,11,21,3,14, then the difference between the largest and smallest is 21 - 1 = 20. Another division 11,12,13,14 produces 3 (i.e. 14 - 11) years. Any random division produces a game of luck. However, you can search the minimum number of years using a program.\n\nGiven a string of numerical characters, write a program to search the minimum years before your wish will be fulfilled.\n\n\n\nInput\n\nThe input is given in the following format.\n\n\nn\n\n\nAn integer n is given. Its number of digits is from 2 to 100,000, and each digit ranges from 1 to 9.\n\nOutput\n\nOutput the minimum number of years before your wish will be fulfilled.\n\nExamples\n\nInput\n\n11121314\n\n\nOutput\n\n3\n\n\nInput\n\n123125129\n\n\nOutput\n\n6\n\n\nInput\n\n119138\n\n\nOutput\n\n5",
    "solution": "def sub(maxs, mins):\n\tfor i in range(len(maxs)):\n\t\tif maxs[i] != mins[i]:\n\t\t\tif i == len(maxs) - 1:\n\t\t\t\treturn int(maxs[i]) - int(mins[i])\n\t\t\tif i == len(maxs) - 2:\n\t\t\t\treturn int(maxs[i:i + 2]) - int(mins[i:i + 2])\n\t\t\treturn 10\n\treturn 0\n\ndef checkEqual(S):\n\tans = 8\n\tfor k in range(1, len(S)):\n\t\tif len(S) % k != 0:\n\t\t\tcontinue\n\t\tmins = maxs = S[0:k]\n\t\tfor s in range(0, len(S), k):\n\t\t\tmaxs = max(maxs, S[s:s + k])\n\t\t\tmins = min(mins, S[s:s + k])\n\t\tans = min(ans, sub(maxs, mins))\n\treturn ans\n\ndef check12(S):\n\tmaxv = 0\n\tminv = 10\n\tp = 0\n\twhile p < len(S):\n\t\tv = int(S[p])\n\t\tif S[p] == '1' and p + 1 < len(S):\n\t\t\tv = 10 + int(S[p + 1])\n\t\t\tp += 1\n\t\tmaxv = max(maxv, v)\n\t\tminv = min(minv, v)\n\t\tp += 1\n\treturn maxv - minv\nS = input()\nprint(min(checkEqual(S), check12(S)))\n",
    "input_output": {
      "inputs": [
        "9714431",
        "16612328",
        "23422731",
        "754526",
        "955577",
        "75547",
        "2112",
        "799",
        "88",
        "32523857",
        "4787",
        "1859551",
        "135661",
        "3675",
        "156692",
        "167918384",
        "83994",
        "4837847",
        "14513597",
        "15282598",
        "12659326",
        "1468417",
        "6280",
        "115464",
        "52376853",
        "2315",
        "3641224",
        "97187",
        "836",
        "195884",
        "36250",
        "2427817",
        "17598762",
        "5744554",
        "9295",
        "129848",
        "3863342",
        "3743",
        "133862",
        "1237",
        "1625",
        "1179729",
        "12651",
        "3776912",
        "4829",
        "73",
        "2228",
        "2546",
        "3136",
        "138",
        "3380",
        "4828",
        "3652",
        "5667",
        "7275",
        "774",
        "9329",
        "279",
        "15119",
        "200",
        "2461",
        "19",
        "2258",
        "31",
        "1250",
        "1216",
        "1595",
        "271",
        "236",
        "187",
        "166",
        "123",
        "231272",
        "12342923",
        "16587352",
        "32887158",
        "42478456",
        "353843",
        "1884868",
        "148239",
        "54241537",
        "213811",
        "3614",
        "1003",
        "177127860",
        "54250",
        "1720310",
        "6415742",
        "12117",
        "1293",
        "5541389",
        "44936",
        "550",
        "43448",
        "664",
        "39426",
        "5003285",
        "73925",
        "4379155",
        "2270",
        "123125129",
        "119138",
        "11121314"
      ],
      "outputs": [
        "8\n",
        "7\n",
        "6\n",
        "5\n",
        "4\n",
        "3\n",
        "1\n",
        "2\n",
        "0\n",
        "6\n",
        "4\n",
        "8\n",
        "5\n",
        "4\n",
        "8\n",
        "8\n",
        "6\n",
        "5\n",
        "8\n",
        "8\n",
        "8\n",
        "7\n",
        "8\n",
        "5\n",
        "6\n",
        "4\n",
        "5\n",
        "8\n",
        "5\n",
        "8\n",
        "6\n",
        "7\n",
        "8\n",
        "3\n",
        "3\n",
        "8\n",
        "6\n",
        "4\n",
        "7\n",
        "6\n",
        "5\n",
        "8\n",
        "5\n",
        "8\n",
        "7\n",
        "4\n",
        "6\n",
        "4\n",
        "5\n",
        "5\n",
        "8\n",
        "6\n",
        "4\n",
        "2\n",
        "3\n",
        "3\n",
        "7\n",
        "7\n",
        "6\n",
        "2\n",
        "5\n",
        "8\n",
        "6\n",
        "2\n",
        "5\n",
        "4\n",
        "8\n",
        "6\n",
        "4\n",
        "7\n",
        "5\n",
        "2\n",
        "6\n",
        "8\n",
        "7\n",
        "7\n",
        "6\n",
        "5\n",
        "7\n",
        "8\n",
        "6\n",
        "7\n",
        "5\n",
        "3\n",
        "8\n",
        "5\n",
        "7\n",
        "6\n",
        "5\n",
        "8\n",
        "8\n",
        "6\n",
        "5\n",
        "5\n",
        "2\n",
        "7\n",
        "8\n",
        "7\n",
        "8\n",
        "7\n",
        "6",
        "5",
        "3"
      ]
    },
    "tags": [],
    "skill_types": [],
    "confusions": [
      "Can you clarify the input format? Is 'n' given on a separate line from the string of digits, or are they somehow combined?",
      "When the problem states 'cut up the string into more than one segment,' does that mean each segment must have at least one digit?",
      "Are overlapping segments allowed? For example, could I consider the segments '12', '23' if the input is '123'?",
      "The problem asks for the *minimum* difference between the largest and smallest segment values. Is there an efficient way to explore all possible segmentations, or is brute-force the only option?",
      "What data type should I use to store the large numbers that might result from the segments, especially given that the input string can be quite long (up to 100,000 digits)?",
      "Could you provide a small example input and manually walk through the process of finding the optimal segmentation and the resulting minimum difference?",
      "Are there any specific edge cases I should be aware of, such as a string with repeating digits or a string that's already in ascending or descending order?",
      "How does the length of the input string (up to 100,000 digits) affect the choice of algorithm and the time complexity of my solution?",
      "Are there any known algorithm design paradigms (e.g., dynamic programming, greedy algorithms) that might be relevant to solving this problem efficiently?",
      "Could you give me a hint on how to avoid exceeding the time limit if I use a brute-force approach?"
    ],
    "helps": [
      "What does the example input show regarding the format of the input string?",
      "What's the smallest number of segments you can have if you need 'more than one segment'?",
      "Does the problem statement explicitly allow overlapping segments? What's the simplest interpretation of 'cut up the string'?",
      "How can you systematically generate all possible segmentations? Can you think of ways to optimize this process by eliminating redundant calculations or segmentations that are obviously not optimal?",
      "What is the largest possible value of a segment if each digit is between 1 and 9? Can you use integers directly, or do you need to consider other data types?",
      "Let's take the input '1234'. What are some possible segmentations? For each segmentation, what's the largest and smallest value? What's the difference?",
      "Consider a string of identical digits like '1111'. What's the minimum difference you can achieve? What about a string that is already sorted, like '1234' or '4321'?",
      "How does the number of possible segmentations grow as the string length increases? What time complexity would a brute-force approach have in the worst case?",
      "Can you decompose the problem into smaller subproblems? For example, can you compute the minimum difference for the first `k` digits and use that information to find the minimum difference for the first `k+1` digits?  Think about how overlapping subproblems can be exploited.",
      "If you need to use brute-force, how can you reduce the number of segmentations that you evaluate? Can you early exit when the difference between the current max and min is small enough?"
    ]
  },
  {
    "problem": "You have a deck of $n$ cards, and you'd like to reorder it to a new one.\n\nEach card has a value between $1$ and $n$ equal to $p_i$. All $p_i$ are pairwise distinct. Cards in a deck are numbered from bottom to top, i. e. $p_1$ stands for the bottom card, $p_n$ is the top card.\n\nIn each step you pick some integer $k > 0$, take the top $k$ cards from the original deck and place them, in the order they are now, on top of the new deck. You perform this operation until the original deck is empty. (Refer to the notes section for the better understanding.)\n\nLet's define an order of a deck as $\\sum\\limits_{i = 1}^{n}{n^{n - i} \\cdot p_i}$.\n\nGiven the original deck, output the deck with maximum possible order you can make using the operation above.\n\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 1000$) \u2014 the number of test cases.\n\nThe first line of each test case contains the single integer $n$ ($1 \\le n \\le 10^5$) \u2014 the size of deck you have.\n\nThe second line contains $n$ integers $p_1, p_2,\\dots, p_n$ ($1 \\le p_i \\le n$; $p_i \\neq p_j$ if $i \\neq j$) \u2014 values of card in the deck from bottom to top.\n\nIt's guaranteed that the sum of $n$ over all test cases doesn't exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case print the deck with maximum possible order. Print values of cards in the deck from bottom to top.\n\nIf there are multiple answers, print any of them.\n\n\n-----Examples-----\n\nInput\n4\n4\n1 2 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\nOutput\n4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n\n\n-----Note-----\n\nIn the first test case, one of the optimal strategies is the next one:\n\ntake $1$ card from the top of $p$ and move it to $p'$: $p$ becomes $[1, 2, 3]$, $p'$ becomes $[4]$;\n\ntake $1$ card from the top of $p$: $p$ becomes $[1, 2]$, $p'$ becomes $[4, 3]$;\n\ntake $1$ card from the top of $p$: $p$ becomes $[1]$, $p'$ becomes $[4, 3, 2]$;\n\ntake $1$ card from the top of $p$: $p$ becomes empty, $p'$ becomes $[4, 3, 2, 1]$.\n\nIn result, $p'$ has order equal to $4^3 \\cdot 4 + 4^2 \\cdot 3 + 4^1 \\cdot 2 + 4^0 \\cdot 1$ $=$ $256 + 48 + 8 + 1 = 313$.\n\nIn the second test case, one of the optimal strategies is:\n\ntake $4$ cards from the top of $p$ and move it to $p'$: $p$ becomes $[1]$, $p'$ becomes $[5, 2, 4, 3]$;\n\ntake $1$ card from the top of $p$ and move it to $p'$: $p$ becomes empty, $p'$ becomes $[5, 2, 4, 3, 1]$;\n\nIn result, $p'$ has order equal to $5^4 \\cdot 5 + 5^3 \\cdot 2 + 5^2 \\cdot 4 + 5^1 \\cdot 3 + 5^0 \\cdot 1$ $=$ $3125 + 250 + 100 + 15 + 1 = 3491$.\n\nIn the third test case, one of the optimal strategies is:\n\ntake $2$ cards from the top of $p$ and move it to $p'$: $p$ becomes $[4, 2, 5, 3]$, $p'$ becomes $[6, 1]$;\n\ntake $2$ cards from the top of $p$ and move it to $p'$: $p$ becomes $[4, 2]$, $p'$ becomes $[6, 1, 5, 3]$;\n\ntake $2$ cards from the top of $p$ and move it to $p'$: $p$ becomes empty, $p'$ becomes $[6, 1, 5, 3, 4, 2]$.\n\nIn result, $p'$ has order equal to $6^5 \\cdot 6 + 6^4 \\cdot 1 + 6^3 \\cdot 5 + 6^2 \\cdot 3 + 6^1 \\cdot 4 + 6^0 \\cdot 2$ $=$ $46656 + 1296 + 1080 + 108 + 24 + 2 = 49166$.",
    "solution": "import heapq\nfrom math import sqrt\nimport operator\nimport sys\ninf_var = 0\nif inf_var == 1:\n\tinf = open('input.txt', 'r')\nelse:\n\tinf = sys.stdin\ninput = inf.readline\n\ndef read_one_int():\n\treturn int(input().rstrip('\\n'))\n\ndef read_list_of_ints():\n\tres = [int(val) for val in input().rstrip('\\n').split(' ')]\n\treturn res\n\ndef read_str():\n\treturn input().rstrip()\n\ndef check_seq(deck_size, deck_cards):\n\tnew_deck = []\n\tused = [0 for i in range(deck_size)]\n\tlast_used_index = deck_size - 1\n\tprev_ind = deck_size\n\tfor i in range(deck_size - 1, -1, -1):\n\t\tif deck_cards[i] == last_used_index + 1:\n\t\t\tnew_deck += deck_cards[i:prev_ind]\n\t\t\tfor j in range(i, prev_ind):\n\t\t\t\tused[deck_cards[j] - 1] = 1\n\t\t\tprev_ind = i\n\t\t\tj = -1\n\t\t\twhile True:\n\t\t\t\tcur_ind = j + last_used_index\n\t\t\t\tif cur_ind < 0:\n\t\t\t\t\tlast_used_index = -1\n\t\t\t\t\tbreak\n\t\t\t\tif used[cur_ind]:\n\t\t\t\t\tj -= 1\n\t\t\t\t\tcontinue\n\t\t\t\telse:\n\t\t\t\t\tlast_used_index = cur_ind\n\t\t\t\t\tbreak\n\treturn ' '.join(map(str, new_deck))\n\ndef main():\n\tcnt = read_one_int()\n\tfor _ in range(cnt):\n\t\tdeck_size = read_one_int()\n\t\tdeck_cards = read_list_of_ints()\n\t\tres = check_seq(deck_size, deck_cards)\n\t\tprint(res)\nmain()\n",
    "input_output": {
      "inputs": [
        "4\n4\n1 2 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
        "4\n4\n2 1 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n",
        "4\n4\n2 1 3 4\n5\n1 5 2 4 3\n6\n2 4 5 3 6 1\n1\n1\n",
        "4\n4\n1 2 3 4\n5\n1 5 2 4 3\n6\n4 2 5 3 6 1\n1\n1\n"
      ],
      "outputs": [
        "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n",
        "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n",
        "4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n",
        "\n4 3 2 1\n5 2 4 3 1\n6 1 5 3 4 2\n1\n"
      ]
    },
    "tags": [
      "Data structures",
      "Mathematics",
      "Greedy algorithms"
    ],
    "skill_types": [
      "Data structures",
      "Greedy algorithms"
    ],
    "confusions": [
      "Could you explain the order calculation with a simpler example, maybe with n=3 and a specific deck?",
      "What does it mean for all p_i to be pairwise distinct? Does this simplify the problem or is it just a constraint?",
      "In the note, it says 'one of the optimal strategies'. Does this mean there could be multiple ways to get the maximum order?",
      "How can I tell if I'm moving the right number of cards to maximize the order in each step? What is the greedy strategy I should be following?",
      "Is there a relationship between the value of a card and where it should end up in the final deck to maximize the order?",
      "Should I be trying to place the largest numbers at the bottom of the new deck, since they have the highest weight (n^(n-i))?",
      "How can I efficiently find the optimal k (number of cards to move) in each step?",
      "Can I solve this using dynamic programming, by considering all possible subproblems (subdecks)?",
      "What are the time complexity constraints I need to consider when writing my solution? Can I afford to iterate through all possible k values in each step?",
      "Can you give me a hint about how to approach this problem without giving away the whole solution?",
      "Could you walk me through a slightly more complex example, like n=5 and the deck [2, 1, 4, 3, 5], showing each step of the optimal strategy?",
      "Are there any standard algorithms or data structures (like stacks or queues) that could be helpful in solving this problem?",
      "How does the condition 'sum of n over all test cases doesn't exceed 10^5' affect the choice of algorithm? Does this preclude an O(n^2) solution?",
      "If I sort the input deck, can I use that information to help me construct the optimal deck? How would that work?",
      "How can I efficiently keep track of the current state of the original deck and the new deck as I move cards?",
      "In terms of implementation, what's the best way to represent the decks (arrays, lists, deques)?",
      "Could you give an example of a suboptimal move and explain why it leads to a lower order?",
      "Is there a way to precompute some values that would help me quickly determine the best move in each step?",
      "Does the order calculation always result in a very large number that I need to be careful about when implementing my solution (overflow issues)?",
      "Am I understanding correctly that the final deck is built from right to left, meaning the last cards added are at the beginning/bottom of the deck?"
    ],
    "helps": [
      "For the n=3 example, how would the order change if you swapped the positions of the largest and smallest cards?",
      "What does pairwise distinct mean in the context of the card values? How would the problem change if duplicate card values were allowed?",
      "If there are multiple ways to achieve the maximum order, what does that suggest about the uniqueness of the optimal strategy at each step?",
      "What criteria could you use to decide which cards are most valuable to have in the earlier positions of the new deck?",
      "How does the value of a card relate to its contribution to the overall order? Which cards contribute the most?",
      "If you want to place the largest numbers at the bottom, how can you identify and move them as a group?",
      "Instead of iterating through all possible k values, can you identify a pattern or property of the optimal k?",
      "What are the overlapping subproblems you might encounter when trying to construct the final deck?",
      "If you have n test cases with n up to 10^5 total, what is the average n per test case? Does this change the algorithm choice?",
      "What is the key idea behind the deck's order? How can you exploit it?",
      "In this n=5 example, where should the '5' end up in the final deck, and how can you make sure it gets there efficiently?",
      "Which data structures would allow you to easily add and remove elements from both ends of a sequence?",
      "How does the constraint 'sum of n over all test cases' affect the feasibility of an O(n log n) sort within each test case?",
      "If you sorted the deck, what information would you gain about the ideal positioning of cards in the final deck?",
      "What is a simple way to track the cards remaining in the original deck and those already in the new deck?",
      "What operations will you frequently need to perform on the decks? Which data structure supports those efficiently?",
      "What happens to the overall order if you prioritize moving a smaller card when a larger card could have been moved?",
      "Can you precompute the desired location of each card in the final deck?",
      "Given the constraints, is it necessary to use 64-bit integers, or are regular integers sufficient?",
      "Consider the order calculation, does each card need to be at the top to achieve an optimal solution?"
    ]
  },
  {
    "problem": "The number obtained by multiplying 1 by 2, 3, 5 several times (0 or more times) is called the Hamming numbers. For example\n\n* 1\n* 1 x 2 x 2 = 4\n* 1 x 2 x 2 x 3 x 5 x 5 = 300\n\n\n\nEtc. are humming numbers, but 11, 13, 14 etc. are not humming numbers.\n\nAll humming numbers are divisible by a power of 60 (for example, 54 is divisible by 603 = 21600), so they have long been known as convenient numbers for sexagesimal calculations such as time. In just intonation, which is one of the scales used for tuning musical instruments, the ratio of the frequencies of the sounds is a sequence of humming numbers of 24, 27, 30, 32, 36, 40, 45, 48.\n\nCreate a program that takes integers m and n as inputs and outputs the number of humming numbers that are m or more and n or less.\n\n\n\nInput\n\nA sequence of multiple datasets is given as input. The end of the input is indicated by a single line of zeros.\n\nFor each dataset, two integers m and n (1 \u2264 m, n \u2264 1000000, m \u2264 n) are given on one line, separated by blanks.\n\nThe number of datasets does not exceed 20.\n\nOutput\n\nOutputs the number of humming numbers from m to n for each data set on one line.\n\nExample\n\nInput\n\n3 8\n1 27\n1 86\n0\n\n\nOutput\n\n5\n17\n31",
    "solution": "import sys\nfrom sys import stdin\nfrom bisect import bisect_right, bisect_left\nfrom math import ceil, log\ninput = stdin.readline\n\ndef main(args):\n\thammings = []\n\ttemp = set()\n\tfor i in range(ceil(log(1000000.0, 2)) + 1):\n\t\tfor j in range(ceil(log(1000000.0, 3)) + 1):\n\t\t\tfor k in range(ceil(log(1000000.0, 5)) + 1):\n\t\t\t\tans = 2 ** i * 3 ** j * 5 ** k\n\t\t\t\ttemp.add(ans)\n\thammings = list(temp)\n\thammings.sort()\n\twhile True:\n\t\ttry:\n\t\t\t(m, n) = map(int, input().split(' '))\n\t\texcept ValueError:\n\t\t\tbreak\n\t\ts = bisect_left(hammings, m)\n\t\tt = bisect_right(hammings, n)\n\t\tprint(t - s)\nmain(sys.argv[1:])\n",
    "input_output": {
      "inputs": [
        "3 8\n2 27\n1 86\n0",
        "3 9\n2 27\n1 86\n0",
        "3 8\n1 35\n1 86\n0",
        "5 8\n2 27\n1 86\n0",
        "3 9\n4 27\n1 86\n0",
        "3 9\n6 27\n1 86\n0",
        "3 9\n6 31\n1 86\n0",
        "3 6\n6 31\n1 86\n0",
        "3 6\n6 9\n1 86\n0",
        "3 6\n8 9\n1 86\n0",
        "3 8\n1 19\n1 86\n0",
        "3 8\n2 27\n1 140\n0",
        "5 8\n2 27\n2 86\n0",
        "3 9\n4 15\n1 86\n0",
        "6 9\n6 31\n1 86\n0",
        "3 8\n2 19\n1 86\n0",
        "3 8\n2 35\n1 140\n0",
        "5 8\n2 18\n2 86\n0",
        "6 9\n4 15\n1 86\n0",
        "6 9\n6 46\n1 86\n0",
        "3 16\n2 35\n1 140\n0",
        "6 9\n4 15\n1 43\n0",
        "6 9\n10 46\n1 86\n0",
        "3 8\n2 20\n1 19\n0",
        "6 9\n4 15\n1 79\n0",
        "6 9\n10 36\n1 86\n0",
        "3 8\n2 31\n1 19\n0",
        "6 5\n10 36\n1 86\n0",
        "3 8\n2 57\n1 19\n0",
        "3 2\n2 57\n1 19\n0",
        "3 8\n1 20\n1 86\n0",
        "3 7\n2 27\n1 86\n0",
        "3 8\n1 35\n2 86\n0",
        "5 4\n2 27\n1 86\n0",
        "3 9\n4 3\n1 86\n0",
        "3 9\n6 12\n1 86\n0",
        "3 14\n6 31\n1 86\n0",
        "3 6\n6 31\n1 141\n0",
        "2 6\n6 9\n1 86\n0",
        "3 12\n8 9\n1 86\n0",
        "5 8\n2 27\n1 140\n0",
        "5 8\n2 13\n2 86\n0",
        "6 9\n3 15\n1 86\n0",
        "6 8\n6 46\n1 86\n0",
        "3 8\n2 10\n1 86\n0",
        "6 16\n2 35\n1 140\n0",
        "6 9\n3 15\n1 43\n0",
        "6 9\n9 46\n1 86\n0",
        "3 3\n2 20\n1 19\n0",
        "9 9\n4 15\n1 79\n0",
        "6 9\n10 36\n1 172\n0",
        "3 8\n3 31\n1 19\n0",
        "3 7\n2 39\n1 86\n0",
        "6 9\n4 3\n1 86\n0",
        "3 8\n8 9\n1 86\n0",
        "5 8\n2 44\n1 140\n0",
        "6 9\n5 31\n1 119\n0",
        "5 8\n2 13\n3 86\n0",
        "10 9\n3 15\n1 86\n0",
        "6 8\n3 46\n1 86\n0",
        "3 8\n4 10\n1 86\n0",
        "6 7\n2 35\n1 140\n0",
        "6 12\n3 15\n1 43\n0",
        "3 4\n3 31\n1 19\n0",
        "6 9\n4 3\n1 123\n0",
        "5 8\n2 44\n2 140\n0",
        "6 9\n5 56\n1 119\n0",
        "5 8\n4 35\n1 173\n0",
        "10 9\n3 10\n1 86\n0",
        "1 8\n4 10\n1 86\n0",
        "6 7\n1 35\n1 140\n0",
        "6 12\n1 15\n1 43\n0",
        "5 8\n3 44\n1 140\n0",
        "1 12\n4 10\n1 86\n0",
        "6 7\n1 29\n1 140\n0",
        "6 12\n1 5\n1 43\n0",
        "6 7\n1 29\n1 128\n0",
        "6 24\n1 5\n1 43\n0",
        "6 24\n1 5\n1 1\n0",
        "3 9\n2 27\n2 86\n0",
        "3 9\n2 8\n1 86\n0",
        "3 8\n1 35\n2 99\n0",
        "3 9\n6 27\n1 16\n0",
        "3 6\n6 18\n1 86\n0",
        "3 6\n6 9\n2 86\n0",
        "3 2\n8 9\n1 86\n0",
        "2 8\n2 27\n1 140\n0",
        "5 8\n4 27\n2 86\n0",
        "3 14\n4 15\n1 86\n0",
        "6 9\n1 31\n1 86\n0",
        "3 8\n2 44\n1 140\n0",
        "6 9\n2 15\n1 86\n0",
        "2 9\n6 46\n1 86\n0",
        "3 8\n2 20\n1 31\n0",
        "3 8\n2 20\n2 19\n0",
        "2 8\n2 31\n1 19\n0",
        "3 8\n1 57\n1 19\n0",
        "3 8\n1 12\n1 86\n0",
        "6 7\n2 27\n1 86\n0",
        "2 8\n1 35\n2 86\n0",
        "3 8\n1 27\n1 86\n0"
      ],
      "outputs": [
        "5\n16\n31\n",
        "6\n16\n31\n",
        "5\n19\n31\n",
        "3\n16\n31\n",
        "6\n14\n31\n",
        "6\n12\n31\n",
        "6\n13\n31\n",
        "4\n13\n31\n",
        "4\n3\n31\n",
        "4\n2\n31\n",
        "5\n13\n31\n",
        "5\n16\n39\n",
        "3\n16\n30\n",
        "6\n8\n31\n",
        "3\n13\n31\n",
        "5\n12\n31\n",
        "5\n18\n39\n",
        "3\n12\n30\n",
        "3\n8\n31\n",
        "3\n17\n31\n",
        "10\n18\n39\n",
        "3\n8\n21\n",
        "3\n14\n31\n",
        "5\n13\n13\n",
        "3\n8\n29\n",
        "3\n12\n31\n",
        "5\n17\n13\n",
        "0\n12\n31\n",
        "5\n24\n13\n",
        "0\n24\n13\n",
        "5\n14\n31\n",
        "4\n16\n31\n",
        "5\n19\n30\n",
        "0\n16\n31\n",
        "6\n0\n31\n",
        "6\n5\n31\n",
        "8\n13\n31\n",
        "4\n13\n39\n",
        "5\n3\n31\n",
        "8\n2\n31\n",
        "3\n16\n39\n",
        "3\n9\n30\n",
        "3\n9\n31\n",
        "2\n17\n31\n",
        "5\n8\n31\n",
        "7\n18\n39\n",
        "3\n9\n21\n",
        "3\n15\n31\n",
        "1\n13\n13\n",
        "1\n8\n29\n",
        "3\n12\n43\n",
        "5\n16\n13\n",
        "4\n19\n31\n",
        "3\n0\n31\n",
        "5\n2\n31\n",
        "3\n20\n39\n",
        "3\n14\n35\n",
        "3\n9\n29\n",
        "0\n9\n31\n",
        "2\n20\n31\n",
        "5\n6\n31\n",
        "1\n18\n39\n",
        "5\n9\n21\n",
        "2\n16\n13\n",
        "3\n0\n36\n",
        "3\n20\n38\n",
        "3\n21\n35\n",
        "3\n16\n43\n",
        "0\n7\n31\n",
        "7\n6\n31\n",
        "1\n19\n39\n",
        "5\n11\n21\n",
        "3\n19\n39\n",
        "10\n6\n31\n",
        "1\n17\n39\n",
        "5\n5\n21\n",
        "1\n17\n38\n",
        "10\n5\n21\n",
        "10\n5\n1\n",
        "6\n16\n30\n",
        "6\n6\n31\n",
        "5\n19\n32\n",
        "6\n12\n12\n",
        "4\n8\n31\n",
        "4\n3\n30\n",
        "0\n2\n31\n",
        "6\n16\n39\n",
        "3\n14\n30\n",
        "8\n8\n31\n",
        "3\n18\n31\n",
        "5\n20\n39\n",
        "3\n10\n31\n",
        "7\n17\n31\n",
        "5\n13\n18\n",
        "5\n13\n12\n",
        "6\n17\n13\n",
        "5\n25\n13\n",
        "5\n10\n31\n",
        "1\n16\n31\n",
        "6\n19\n30\n",
        "5\n17\n31"
      ]
    },
    "tags": [],
    "skill_types": [],
    "confusions": [
      "What are the best data structures to efficiently store and check if a number is a Hamming number?",
      "How can I generate Hamming numbers in an increasing order to avoid checking numbers that are smaller than 'm'?",
      "Is there a way to avoid generating all possible Hamming numbers up to 'n'? Can I optimize the generation process?",
      "What's the most efficient way to determine if a number is a Hamming number, especially when dealing with a range of numbers?",
      "How does the constraint that m and n are between 1 and 1000000 affect my choice of algorithm and data structures?",
      "Can you explain more about the sexagesimal calculation and just intonation context? I'm not sure how that helps with the coding problem itself.",
      "Could you provide a more detailed example of generating Hamming numbers? Specifically, how do I ensure I'm only multiplying by 2, 3, and 5?",
      "Is it necessary to pre-calculate all Hamming numbers within the range [1, 1000000] before processing the input ranges m and n, or can I calculate them on the fly for each input?",
      "How would you approach this problem with dynamic programming? Is it a viable option?",
      "What is the time complexity you are expecting for the optimal solution? What are the possible bottlenecks in the code that I should pay attention to?"
    ],
    "helps": [
      "What factors are allowed in a Hamming number? How can you represent a Hamming number using exponents of these factors?",
      "If you generate Hamming numbers by successively multiplying by 2, 3, and 5, what should you do to ensure you generate them in increasing order? What data structure might help with maintaining sorted order?",
      "When generating, can you stop when you reach a Hamming number larger than 'n'? What would that imply for the factors you are testing?",
      "If a number is a Hamming number, what can you say about its prime factorization? Can you use this information to check if a number is a Hamming number?",
      "How does knowing the upper bound 'n' simplify the search or generation of Hamming numbers? What data types and operations are performant for values up to 1,000,000?",
      "While the context provides background, what is the core mathematical property that defines a Hamming number that you need to focus on for the code?",
      "Start with 1. What do you get when you multiply it by 2, 3, and 5? Then, what happens when you multiply *those* results by 2, 3, and 5? How do you avoid duplicates?",
      "Given the range of possible inputs for m and n, what would be the trade-offs in terms of space and time complexity between pre-calculation versus on-the-fly calculation?",
      "How could you break down the problem into smaller, overlapping subproblems? What would be the 'state' you need to remember to avoid redundant calculations? Is the problem structure suitable for leveraging previously computed results?",
      "What operations are performed repeatedly? Are there any sorting or searching algorithms used? How does the pre-calculation of Hamming numbers impact the overall runtime?"
    ]
  }
]