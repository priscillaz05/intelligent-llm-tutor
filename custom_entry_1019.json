"```json\n{\n  \"Coding Problem\": \"You are given an integer sequence of length N: A_1,A_2,...,A_N. Let us perform Q operations in order. The i-th operation is described by two integers X_i and Y_i. In this operation, we will choose one of the following two actions and perform it:\\n\\n* Swap the values of A_{X_i} and A_{Y_i}\\n* Do nothing\\n\\nThere are 2^Q ways to perform these operations. Find the sum of the inversion numbers of the final sequences for all of these ways to perform operations, modulo 10^9+7.\\n\\nHere, the inversion number of a sequence P_1,P_2,...,P_M is the number of pairs of integers (i,j) such that 1\\\\leq i < j\\\\leq M and P_i > P_j.\\n\\nConstraints\\n\\n* 1 \\\\leq N \\\\leq 3000\\n* 0 \\\\leq Q \\\\leq 3000\\n* 0 \\\\leq A_i \\\\leq 10^9(1\\\\leq i\\\\leq N)\\n* 1 \\\\leq X_i,Y_i \\\\leq N(1\\\\leq i\\\\leq Q)\\n* X_i\\\\neq Y_i(1\\\\leq i\\\\leq Q)\\n* All values in input are integers.\\n\\nInput\\n\\nInput is given from Standard Input in the following format:\\n\\n\\nN Q\\nA_1\\n:\\nA_N\\nX_1 Y_1\\n:\\nX_Q Y_Q\\n\\n\\nOutput\\n\\nPrint the sum of the inversion numbers of the final sequences, modulo 10^9+7.\\n\\nExamples\\n\\nInput\\n\\n3 2\\n1\\n2\\n3\\n1 2\\n1 3\\n\\n\\nOutput\\n\\n6\\n\\n\\nInput\\n\\n5 3\\n3\\n2\\n3\\n1\\n4\\n1 5\\n2 3\\n4 2\\n\\n\\nOutput\\n\\n36\\n\\n\\nInput\\n\\n9 5\\n3\\n1\\n4\\n1\\n5\\n9\\n2\\n6\\n5\\n3 5\\n8 9\\n7 9\\n3 2\\n3 8\\n\\n\\nOutput\\n\\n425\",\n  \"Ground Truth Solution\": \"import sys\\n(n, q) = list(map(int, input().split()))\\nMOD = 10 ** 9 + 7\\nINV2 = (MOD + 1) // 2\\nlines = sys.stdin.readlines()\\naaa = list(map(int, lines[:n]))\\nmat = [[0] * n for _ in [0] * n]\\nfor i in range(n):\\n\\tfor j in range(n):\\n\\t\\tmat[i][j] = int(aaa[i] < aaa[j])\\nfor line in lines[n:]:\\n\\t(x, y) = map(int, line.split())\\n\\tx -= 1\\n\\ty -= 1\\n\\tmat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\\n\\tfor i in range(n):\\n\\t\\tif i == x or i == y:\\n\\t\\t\\tcontinue\\n\\t\\tmat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\\n\\t\\tmat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\\nans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\\nans = (ans << q) % MOD\\nprint(ans)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks to calculate the sum of inversion numbers for all possible sequences resulting from optional swaps. Each swap can be either performed or skipped, leading to 2^Q possible sequences.\\n- Identifying Key Concepts: The core concepts are inversion number, modulo arithmetic, and the impact of optional swaps on the expected number of inversions.\\n- Algorithmic Strategy: The solution involves calculating the probability of A_i > A_j after all operations. Initially, this is either 0 or 1. Then, with each optional swap operation between A_x and A_y, the probability updates. If A_i and A_j are swapped, the probability becomes the average of the previous probabilities of A_i > A_j and A_j > A_i.\\n- Data Structures: A matrix can be used to store the probabilities of A_i > A_j for each pair of elements. This matrix is updated after each swap operation.\\n- Optimization: Modulo arithmetic needs to be applied to prevent integer overflow. Using the modular inverse of 2 is required because probabilities need to be averaged in modulo space. The final answer is the sum of all inversion counts (represented by the probabilities) multiplied by 2^Q, because each sequence has equal probability. The matrix holds values representing the expected number of inversions, and shifting the resulting expected number to the left by `q` bits effectively multiplies by 2^q.\",\n  \"LLM Questions\": [\n    \"How can you represent the probability of A_i > A_j after multiple optional swap operations?\",\n    \"What is the effect of an optional swap operation on the probability of A_i > A_j?\",\n    \"How does modulo arithmetic affect calculations, and why is the modular inverse of 2 important in this problem?\",\n    \"How does the 2^Q factor come into play in calculating the final answer, and why is it necessary?\",\n    \"Explain how the matrix 'mat' is updated and why this accurately reflects the changing probabilities of A_i > A_j after each swap operation.\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"You can use a matrix where each element mat[i][j] stores the probability that A_i > A_j. This probability is initially either 0 or 1, depending on whether A_i is initially less than or greater than A_j.\",\n    \"An optional swap operation averages the probabilities of A_i > A_j and A_j > A_i. This is because there's a 50% chance the swap happens and a 50% chance it doesn't. Therefore, the updated probability is (mat[i][j] + mat[j][i]) / 2.\",\n    \"Modulo arithmetic ensures that the calculations stay within the specified range (10^9 + 7) to prevent integer overflow. The modular inverse of 2 (INV2) is used because we need to divide by 2 in modulo space, which is equivalent to multiplying by the modular inverse.\",\n    \"Each of the 2^Q possible sequences contributes to the total inversion count. Since each sequence is equally likely, we calculate the expected number of inversions for a single sequence (represented by the sum of the probabilities in the matrix) and then multiply by 2^Q to get the total sum of inversion numbers across all sequences.\",\n    \"The matrix 'mat' is updated after each optional swap. For a swap between A_x and A_y, mat[x][y] and mat[y][x] are updated to the average of their previous values. Additionally, for all other indices i, mat[x][i] and mat[y][i] are updated to the average of their previous values, and similarly for mat[i][x] and mat[i][y]. This process reflects how the probabilities of relative order change with each optional swap.\"\n  ]\n}\n```"