"```json\n{\n  \"Coding Problem\": \"Two people are playing Nimble! The rules of the game are:\\n\\nThe game is played on a line of $n$ squares, indexed from $\\\\mbox{0}$ to $n-1$. Each square $\\\\boldsymbol{i}$ (where $0\\\\leq i<n$) contains $c_i$ coins. For example: \\n\\nThe players move in alternating turns. During each move, the current player must  remove exactly $\\\\mbox{1}$ coin from square $\\\\boldsymbol{i}$ and move it to square $j$ if and only if $0\\\\leq j<i$.\\nThe game ends when all coins are in square $\\\\mbox{0}$ and nobody can make a move. The first player to have no available move loses the game.\\n\\nGiven the value of $n$ and the number of coins in each square, determine whether the person who wins the game is the first or second person to move. Assume both players move optimally.\\n\\nInput Format\\n\\nThe first line contains an integer, $\\\\mathbf{T}$, denoting the number of test cases. \\n\\nEach of the $2T$ subsequent lines defines a test case. Each test case is described over the following two lines:\\n\\nAn integer, $n$, denoting the number of squares.\\n$n$ space-separated integers, $c_0,c_1,\\\\ldots,c_{n-1}$, where each $c_i$ describes the number of coins at square $\\\\boldsymbol{i}$.\\n\\nConstraints\\n\\n$1\\\\leq T\\\\leq10^4$\\n$1\\\\leq n\\\\leq100$\\n$0\\\\leq c_i\\\\leq10^9$\\n\\nOutput Format\\n\\nFor each test case, print the name of the winner on a new line (i.e., either $\\\\textbf{First}$ or $\\\\textbf{Second}$).\",\n  \"Ground Truth Solution\": \"test = int(input())\\nfor _ in range(test):\\n\\tn = int(input())\\n\\tar = list(map(int, input().strip().split()))\\n\\tresult = []\\n\\tfor i in range(len(ar)):\\n\\t\\tresult.append(ar[i] % 2)\\n\\txor = 0\\n\\tfor (i, n) in enumerate(result):\\n\\t\\txor = xor ^ i * n\\n\\tif xor == 0:\\n\\t\\tprint('Second')\\n\\telse:\\n\\t\\tprint('First')\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Game Rules: The game involves moving coins from higher-indexed squares to lower-indexed squares. The goal is to move all coins to square 0. The last player to make a move wins.\\n- Identifying Winning Strategy: The core idea is to recognize that this game is a variation of Nim. Each square can be considered a pile in a Nim game, and the number of coins in that square represents the number of stones in the pile. The critical difference is that a coin can only be moved to lower-indexed squares, changing the game's state.  The winning strategy involves calculating the Nim-sum (XOR sum) of the pile sizes. If the Nim-sum is non-zero, the first player can always make a move to make the Nim-sum zero, leading to a win. If the Nim-sum is zero initially, the second player will win.\\n- Mapping Game to Nim Variant:  Consider only the squares that have an odd number of coins. These squares are the only ones that contribute to the Nim-sum. If the XOR sum of the indices of these squares is zero, the second player wins; otherwise, the first player wins.\\n- Optimizing for Efficiency: The input coin values can be very large, but only their parity (whether they are even or odd) matters. This optimization significantly reduces the computational complexity by using `ar[i] % 2`.\",\n  \"LLM Questions\": [\n    \"How can the Nimble game be interpreted as a variation of the Nim game?\",\n    \"Why does only the parity of the number of coins in each square matter?\",\n    \"How can the XOR sum be calculated to determine the winner?\",\n    \"What is the significance of the XOR sum being zero or non-zero?\",\n    \"How does the constraint of moving coins only to lower-indexed squares affect the strategy?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The Nimble game can be seen as a Nim game where each square is a pile, and the number of coins in a square is the number of stones in that pile. The difference is coins can only be moved to lower index squares.\",\n    \"Only the parity matters because moving an even number of coins from one square to another does not change the outcome of the game. We are essentially concerned if there is any coin in the square at all.\",\n    \"The XOR sum can be calculated by iterating through the squares and XORing the indices of squares with an odd number of coins.\",\n    \"If the XOR sum is zero, the second player wins; if it is non-zero, the first player wins. A non-zero XOR sum means that there is an advantage that the first player can exploit.\",\n    \"The constraint of moving coins only to lower-indexed squares changes the game from a standard Nim game. The indices act as weights or restrictions on moves.\"\n  ]\n}\n```"