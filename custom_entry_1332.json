"```json\n{\n  \"Coding Problem\": \"You are given a matrix of integers $A$ with $N$ rows (numbered $1$ through $N$) and $M$ columns (numbered $1$ through $M$). Each element of this matrix is either $0$ or $1$.\\nA move consists of the following steps:\\n- Choose two different rows $r_1$ and $r_2$ or two different columns $c_1$ and $c_2$.\\n- Apply the bitwise OR operation with the second row/column on the first row/column. Formally, if you chose two rows, this means you should change $A_{r_1, k}$ to $A_{r_1, k} \\\\lor A_{r_2, k}$ for each $1 \\\\le k \\\\le M$; if you chose two columns, then you should change $A_{k, c_1}$ to $A_{k, c_1} \\\\lor A_{k, c_2}$ for each $1 \\\\le k \\\\le N$.\\nFor each element of the matrix, compute the minimum number of moves required to make it equal to $1$ or determine that it is impossible. Note that these answers are independent, i.e. we are starting with the initial matrix for each of them.\\n\\n-----Input-----\\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\\n- The first line of each test case contains two space-separated integers $N$ and $M$.\\n- $N$ lines follow. For each $i$ ($1 \\\\le i \\\\le N$), the $i$-th of these lines contains $M$ integers $A_{i, 1}, A_{i, 2}, \\\\dots, A_{i, M}$ NOT separated by spaces.\\n\\n-----Output-----\\nFor each test case, print $N$ lines. For each valid $i$, the $i$-th of these lines should contain $M$ space-separated integers; for each valid $j$, the $j$-th of these integers should be the minimum number of moves required to make $A_{i, j}$ equal to $1$, or $-1$ if it is impossible.\\n\\n-----Constraints-----\\n- $1 \\\\le T \\\\le 100$\\n- $1 \\\\le N, M \\\\le 1,000$\\n- $A_{i, j} \\\\in \\\\{0, 1\\\\}$ for each valid $i, j$\\n- the sum of $N \\\\cdot M$ for all test cases does not exceed $1,000,000$\\n\\n-----Example Input-----\\n1\\n3 3\\n010\\n000\\n001\\n\\n-----Example Output-----\\n1 0 1\\n2 1 1\\n1 1 0\",\n  \"Ground Truth Solution\": \"t = input()\\nt = int(t)\\nwhile t:\\n\\tt = t - 1\\n\\tn_m = input()\\n\\tn_m = n_m.split(' ')\\n\\tn = int(n_m[0])\\n\\tm = int(n_m[1])\\n\\tmatrix = []\\n\\tfor i in range(n):\\n\\t\\trow = input()\\n\\t\\trow = list(row)\\n\\t\\trow = list(map(int, row))\\n\\t\\tmatrix.append(row)\\n\\tv_rows = [False] * n\\n\\tv_cols = [False] * m\\n\\tans = [[-1 for j in range(m)] for i in range(n)]\\n\\texist = False\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif matrix[i][j] == 1:\\n\\t\\t\\t\\texist = True\\n\\t\\t\\t\\tv_rows[i] = True\\n\\t\\t\\t\\tv_cols[j] = True\\n\\tfor i in range(n):\\n\\t\\tfor j in range(m):\\n\\t\\t\\tif matrix[i][j] == 1:\\n\\t\\t\\t\\tans[i][j] = 0\\n\\t\\t\\telif v_rows[i] == True:\\n\\t\\t\\t\\tans[i][j] = 1\\n\\t\\t\\telif v_cols[j] == True:\\n\\t\\t\\t\\tans[i][j] = 1\\n\\t\\t\\telif exist:\\n\\t\\t\\t\\tans[i][j] = 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans[i][j] = -1\\n\\tfor i in range(n):\\n\\t\\tcol_j = ''\\n\\t\\tfor j in range(m):\\n\\t\\t\\tcol_j = col_j + str(ans[i][j]) + ' '\\n\\t\\tprint(col_j)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks for the minimum number of moves (bitwise OR operations between rows or columns) to turn each element of a binary matrix into 1. We need to calculate this independently for each element.\\n- Identifying Key Conditions: If an element is already 1, the answer is 0. If the element is 0 and there's a 1 in the same row or column, the answer is 1. If the element is 0, and there isn't a 1 in the same row or column, but there is a 1 in the matrix, then we can turn it to 1 in two moves (make its row/column have 1). If there's no 1 in the whole matrix, then it's impossible to turn any element to 1.\\n- Formulating a Strategy:  Iterate through each element. Check if the element is already 1. If not, check if there's a 1 in the same row or column. If not, check if there's any 1 in the matrix. Based on these conditions, assign the minimum moves (0, 1, or 2) or -1 if impossible.\",\n  \"LLM Questions\": [\n    \"What is the goal of the problem, and what operations are allowed?\",\n    \"What are the possible return values, and what do they represent?\",\n    \"Under what conditions is it impossible to make an element equal to 1?\",\n    \"If an element is 0, and you know there is a 1 somewhere in the matrix, how many moves are required to change this element to 1?\",\n    \"How do you handle multiple test cases in the input?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The goal is to find the minimum number of moves to change each element in the matrix to 1, using bitwise OR operations between rows or columns.\",\n    \"The possible return values are non-negative integers (0, 1, or 2) representing the minimum number of moves required or -1, representing that it is impossible to make the element equal to 1.\",\n    \"It's impossible to make an element equal to 1 if the initial matrix contains no 1s.\",\n    \"If an element is 0 and there is a 1 somewhere in the matrix, it takes exactly two moves to make it 1. First, use the row/column with the one, to make a row/column containing that one contain one in the same row/col as the zero. Second, use the row/col with the one to update the value.\",\n    \"The input starts with a number T indicating the number of test cases.  You need to process each test case independently and print the output accordingly.\"\n  ]\n}\n```"