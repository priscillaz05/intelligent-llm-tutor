"```json\n{\n  \"Coding Problem\": \"Andrey needs one more problem to conduct a programming contest. He has n friends who are always willing to help. He can ask some of them to come up with a contest problem. Andrey knows one value for each of his fiends \u2014 the probability that this friend will come up with a problem if Andrey asks him.\\n\\nHelp Andrey choose people to ask. As he needs only one problem, Andrey is going to be really upset if no one comes up with a problem or if he gets more than one problem from his friends. You need to choose such a set of people that maximizes the chances of Andrey not getting upset.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 100) \u2014 the number of Andrey's friends. The second line contains n real numbers p_{i} (0.0 \u2264 p_{i} \u2264 1.0) \u2014 the probability that the i-th friend can come up with a problem. The probabilities are given with at most 6 digits after decimal point.\\n\\n\\n-----Output-----\\n\\nPrint a single real number \u2014 the probability that Andrey won't get upset at the optimal choice of friends. The answer will be considered valid if it differs from the correct one by at most 10^{ - 9}.\\n\\n\\n-----Examples-----\\nInput\\n4\\n0.1 0.2 0.3 0.8\\n\\nOutput\\n0.800000000000\\n\\nInput\\n2\\n0.1 0.2\\n\\nOutput\\n0.260000000000\\n\\n\\n\\n-----Note-----\\n\\nIn the first sample the best strategy for Andrey is to ask only one of his friends, the most reliable one.\\n\\nIn the second sample the best strategy for Andrey is to ask all of his friends to come up with a problem. Then the probability that he will get exactly one problem is 0.1\u00b70.8 + 0.9\u00b70.2 = 0.26.\",\n  \"Ground Truth Solution\": \"import sys\\ninput()\\nps = sorted((float(p) for p in input().split()), reverse=True)\\nif 1.0 in ps:\\n\\tprint(1)\\n\\tsys.exit()\\n(a, b) = (0, 1)\\nfor p in ps:\\n\\t(c, d) = (a + p / (1 - p), b * (1 - p))\\n\\tif c * d > a * b:\\n\\t\\t(a, b) = (c, d)\\n\\telse:\\n\\t\\tbreak\\nprint('{:.9}'.format(a * b))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The goal is to find a subset of friends to ask for a problem such that the probability of getting exactly one problem is maximized. This means we don't want zero or more than one problem.\\n- Algorithmic Strategy: Consider each friend's probability of providing a problem. Sort the probabilities in descending order. Iterate through the sorted probabilities and at each step, decide whether including the current friend increases the probability of getting exactly one problem compared to the best subset found so far.\\n- Mathematical Formulation: Let 'a' be the probability of getting exactly one problem and 'b' be the probability of getting no problem when considering a subset of friends. When considering adding a new friend with probability 'p', update 'a' and 'b'. The probability of getting exactly one problem when including this friend is a new probability, 'c', which is equal to a + p/(1-p) and new probability, 'd' will be b*(1-p). Select the best probability, whether 'a\\*b' or 'c\\*d'.\\n- Edge Cases: If any friend has a probability of 1.0, then the best strategy is to only ask that friend, as the probability of exactly one problem is 1.\\n- Optimization Technique: Sort the array and use the sorted probabilities in descending order. This ensures to select the friend with highest probability.\\n- Implementation Details: Consider floating-point precision when comparing probabilities. Print the output with at least nine decimal places to satisfy the problem's accuracy requirement.\",\n  \"LLM Questions\": [\n    \"What is the meaning of maximizing the chances of Andrey not getting upset, and how does it relate to the number of problems received?\",\n    \"What is the significance of sorting the probabilities, and how does it impact the optimal solution?\",\n    \"Can you explain the mathematical relationship between the probabilities of getting exactly one problem, getting no problems, and a friend's probability of providing a problem?\",\n    \"How do you deal with the case when one of the friends has a probability of 1.0 of providing a problem?\",\n    \"What are the potential issues with floating-point arithmetic, and how can you mitigate them to achieve the required accuracy in the output?\",\n    \"How to represent a situation where we are asking 0 friends for a solution to the problem?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"It means maximizing the probability of receiving exactly one problem. Andrey is upset if he receives zero or more than one problem.\",\n    \"Sorting the probabilities in descending order helps to prioritize asking friends who are more likely to provide a problem. This greedy approach usually leads to the optimal solution, as it allows us to quickly evaluate friends in order of reliability.\",\n    \"If 'a' is the probability of getting exactly one problem, 'b' is the probability of getting no problem, and 'p' is the probability of the new friend providing a problem, then we can express updated probabilities by including this friend. Probability of getting exactly one problem is a new probability, 'c', which is equal to a + p/(1-p) and new probability, 'd' will be b*(1-p).\",\n    \"If one of the friends has a probability of 1.0, we should only ask that friend. Asking any other friend would introduce a possibility of getting more than one problem.\",\n    \"Floating-point arithmetic can introduce small errors due to limited precision. You can use formatting to display the output with the required number of decimal places and be cautious when comparing floating point numbers directly, usually using a small tolerance.\",\n    \"If we ask 0 friends for the solution to the problem, the probabilities are a=0 and b=1, where a is the probability of one solution and b is the probability of 0 solutions\"\n  ]\n}\n```"