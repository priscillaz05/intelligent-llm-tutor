"```json\n{\n  \"Coding Problem\": \"There are n rabbits, one in each of the huts numbered 0 through n \u2212 1.\\n\\nAt one point, information came to the rabbits that a secret organization would be constructing an underground passage. The underground passage would allow the rabbits to visit other rabbits' huts. I'm happy.\\n\\nThe passages can go in both directions, and the passages do not intersect. Due to various circumstances, the passage once constructed may be destroyed. The construction and destruction of the passages are carried out one by one, and each construction It is assumed that the rabbit stays in his hut.\\n\\nRabbits want to know in advance if one rabbit and one rabbit can play at some stage of construction. Rabbits are good friends, so they are free to go through other rabbit huts when they go out to play. Rabbits who like programming tried to solve a similar problem in the past, thinking that it would be easy, but they couldn't write an efficient program. Solve this problem instead of the rabbit.\\n\\n\\n\\nInput\\n\\nThe first line of input is given n and k separated by spaces. 2 \u2264 n \u2264 40 000, 1 \u2264 k \u2264 40 000\\n\\nIn the following k lines, construction information and questions are combined and given in chronological order.\\n\\n* \u201c1 u v\u201d \u2014 A passage connecting huts u and v is constructed. Appears only when there is no passage connecting huts u and v.\\n* \u201c2 u v\u201d \u2014 The passage connecting huts u and v is destroyed. Appears only when there is a passage connecting huts u and v.\\n* \u201c3 u v\u201d \u2014 Determine if the rabbits in the hut u and v can be played.\\n\\n\\n\\n0 \u2264 u <v <n\\n\\nOutput\\n\\nFor each question that appears in the input, output \\\"YES\\\" if you can play, or \\\"NO\\\" if not.\\n\\nExample\\n\\nInput\\n\\n4 10\\n1 0 1\\n1 0 2\\n3 1 2\\n2 0 1\\n1 2 3\\n3 0 1\\n1 0 1\\n2 0 2\\n1 1 3\\n3 0 2\\n\\n\\nOutput\\n\\nYES\\nNO\\nYES\",\n  \"Ground Truth Solution\": \"from collections import deque\\nimport sys\\nreadline = sys.stdin.readline\\nwrite = sys.stdout.write\\n\\ndef solve():\\n\\t(N, K) = map(int, readline().split())\\n\\tES = [list(map(int, readline().split())) for i in range(K)]\\n\\temp = {}\\n\\tsq = int(K ** 0.5) + 1\\n\\n\\tdef root(x):\\n\\t\\tif x == p[x]:\\n\\t\\t\\treturn x\\n\\t\\tp[x] = y = root(p[x])\\n\\t\\treturn y\\n\\n\\tdef unite(x, y):\\n\\t\\tpx = root(x)\\n\\t\\tpy = root(y)\\n\\t\\tif px < py:\\n\\t\\t\\tp[py] = px\\n\\t\\telse:\\n\\t\\t\\tp[px] = py\\n\\tque = deque()\\n\\tused = [0] * N\\n\\tlb = 0\\n\\tp = [0] * N\\n\\tfor i in range(sq):\\n\\t\\ts = set()\\n\\t\\tfor j in range(i * sq, min(i * sq + sq, K)):\\n\\t\\t\\t(t, a, b) = ES[j]\\n\\t\\t\\tif t == 3:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\te = (a, b)\\n\\t\\t\\tif emp.get(e, 0):\\n\\t\\t\\t\\ts.add(e)\\n\\t\\t\\temp[e] = 0\\n\\t\\tp[:] = range(N)\\n\\t\\tfor ((v, w), d) in emp.items():\\n\\t\\t\\tif d == 1:\\n\\t\\t\\t\\tunite(v, w)\\n\\t\\tG0 = [[] for i in range(N)]\\n\\t\\temp0 = {}\\n\\t\\tfor (a, b) in s:\\n\\t\\t\\tpa = root(a)\\n\\t\\t\\tpb = root(b)\\n\\t\\t\\te = (pa, pb) if pa < pb else (pb, pa)\\n\\t\\t\\tif pa == pb:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif e in emp0:\\n\\t\\t\\t\\t(e1, e2) = emp0[e]\\n\\t\\t\\t\\te1[1] = e2[1] = e1[1] + 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\te1 = [pb, 1]\\n\\t\\t\\t\\te2 = [pa, 1]\\n\\t\\t\\t\\tG0[pa].append(e1)\\n\\t\\t\\t\\tG0[pb].append(e2)\\n\\t\\t\\t\\temp0[e] = (e1, e2)\\n\\t\\tfor j in range(i * sq, min(i * sq + sq, K)):\\n\\t\\t\\t(t, a, b) = ES[j]\\n\\t\\t\\tpa = root(a)\\n\\t\\t\\tpb = root(b)\\n\\t\\t\\te = (pa, pb) if pa < pb else (pb, pa)\\n\\t\\t\\tif t == 1:\\n\\t\\t\\t\\temp[a, b] = 1\\n\\t\\t\\t\\tif pa == pb:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif e not in emp0:\\n\\t\\t\\t\\t\\te1 = [pb, 1]\\n\\t\\t\\t\\t\\te2 = [pa, 1]\\n\\t\\t\\t\\t\\tG0[pa].append(e1)\\n\\t\\t\\t\\t\\tG0[pb].append(e2)\\n\\t\\t\\t\\t\\temp0[e] = (e1, e2)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t(e1, e2) = emp0[e]\\n\\t\\t\\t\\t\\te1[1] = e2[1] = e1[1] + 1\\n\\t\\t\\telif t == 2:\\n\\t\\t\\t\\temp[a, b] = 0\\n\\t\\t\\t\\tif pa == pb:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t(e1, e2) = emp0[e]\\n\\t\\t\\t\\te1[1] = e2[1] = e1[1] - 1\\n\\t\\t\\telif t == 3:\\n\\t\\t\\t\\tif pa == pb:\\n\\t\\t\\t\\t\\twrite('YES\\\\n')\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tlb += 1\\n\\t\\t\\t\\t\\tque.append(pa)\\n\\t\\t\\t\\t\\tused[pa] = lb\\n\\t\\t\\t\\t\\twhile que:\\n\\t\\t\\t\\t\\t\\tv = que.popleft()\\n\\t\\t\\t\\t\\t\\tfor (w, d) in G0[v]:\\n\\t\\t\\t\\t\\t\\t\\tif d and used[w] != lb:\\n\\t\\t\\t\\t\\t\\t\\t\\tused[w] = lb\\n\\t\\t\\t\\t\\t\\t\\t\\tque.append(w)\\n\\t\\t\\t\\t\\tif used[pb] == lb:\\n\\t\\t\\t\\t\\t\\twrite('YES\\\\n')\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\twrite('NO\\\\n')\\n\\nsolve()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a dynamic connectivity scenario where rabbits in different huts can be connected by underground passages that can be constructed or destroyed. The task is to efficiently determine if two rabbits can 'play' together, which means they are in the same connected component.\\n- Data Structure Selection: Due to the online nature of the queries (construction, destruction, and connectivity checks intermixed), and the potentially large number of rabbits and operations (n, k <= 40000), a standard Union-Find algorithm might be slow due to linear time complexity per operation. A more efficient approach using square root decomposition in combination with Union-Find is needed.\\n- Algorithmic Strategy: Employ a combination of Union-Find with path compression and square root decomposition. Divide the k operations into blocks of sqrt(k) size. For each block, reconstruct the connected components based on the edges present at the beginning of the block. Union-Find operations are performed inside each block to efficiently handle edge additions and removals. For query operations within a block, determine connectivity based on the current state within the block.\\n- Handling Edge Cases and Constraints: The code needs to handle constraints such as n and k up to 40000. Optimize memory usage and avoid exceeding time limits. The edges are undirected, and the input is processed sequentially. Handle each query in an online manner.\\n- Optimizing for Efficiency: The key optimization is to rebuild the connectivity graph every sqrt(k) operations. This ensures that each operation can be done in at most O(sqrt(k)) time. Standard Union-Find with path compression provides additional performance gains for determining connectivity.\",\n  \"LLM Questions\": [\n    \"What is the most straightforward approach to check connectivity between two rabbits after each construction or destruction operation?\",\n    \"Expected Answer: A basic approach involves using Depth-First Search (DFS) or Breadth-First Search (BFS) to explore connected huts from one rabbit and check if the other rabbit is reachable.\",\n    \"How can Union-Find be applied to solve this connectivity problem and what are its limitations in this context?\",\n    \"Expected Answer: Union-Find can efficiently track connected components by merging huts when passages are constructed. However, basic Union-Find doesn't handle edge deletions efficiently, which are part of this problem.\",\n    \"Given that constructions and destructions happen in chronological order, is there a way to batch operations and improve efficiency?\",\n    \"Expected Answer: Yes, you can process operations in batches and rebuild the connectivity graph periodically. This amortizes the cost of recomputing connectivity.\",\n    \"How can square root decomposition be employed to balance the overhead of rebuilding the connectivity graph and answering connectivity queries?\",\n    \"Expected Answer: Square root decomposition involves dividing the operations into blocks of sqrt(k) size. Rebuild the connectivity graph at the beginning of each block and then process the operations within the block using the reconstructed graph.\",\n    \"What data structures are most suitable for efficiently tracking edges and performing Union-Find operations in each block?\",\n    \"Expected Answer: Dictionaries (or hash maps) can track edge presence or absence, and a Union-Find data structure can efficiently track connected components within each block.\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A basic approach involves using Depth-First Search (DFS) or Breadth-First Search (BFS) to explore connected huts from one rabbit and check if the other rabbit is reachable.\",\n    \"Union-Find can efficiently track connected components by merging huts when passages are constructed. However, basic Union-Find doesn't handle edge deletions efficiently, which are part of this problem.\",\n    \"Yes, you can process operations in batches and rebuild the connectivity graph periodically. This amortizes the cost of recomputing connectivity.\",\n    \"Square root decomposition involves dividing the operations into blocks of sqrt(k) size. Rebuild the connectivity graph at the beginning of each block and then process the operations within the block using the reconstructed graph.\",\n    \"Dictionaries (or hash maps) can track edge presence or absence, and a Union-Find data structure can efficiently track connected components within each block.\"\n  ]\n}\n```"