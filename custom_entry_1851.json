"```json\n{\n  \"Coding Problem\": \"We have an H \\\\times W grid, where each square is painted white or black in the initial state. Given are strings A_1, A_2, ..., A_H representing the colors of the squares in the initial state. For each pair (i, j) (1 \\\\leq i \\\\leq H, 1 \\\\leq j \\\\leq W), if the j-th character of A_i is `.`, the square at the i-th row and j-th column is painted white; if that character is `#`, that square is painted black.\\n\\nAmong the 2^{HW} ways for each square in the grid to be painted white or black, how many can be obtained from the initial state by performing the operations below any number of times (possibly zero) in any order? Find this count modulo 998,244,353.\\n\\n* Choose one row, then paint all the squares in that row white.\\n* Choose one row, then paint all the squares in that row black.\\n* Choose one column, then paint all the squares in that column white.\\n* Choose one column, then paint all the squares in that column black.\\n\\nConstraints\\n\\n* 1 \\\\leq H, W \\\\leq 10\\n* |A_i| = W (1 \\\\leq i \\\\leq H)\\n* All strings A_i consist of `.` and `#`.\\n* H and W are integers.\\n\\nInput\\n\\nInput is given from Standard Input in the following format:\\n\\n\\nH W\\nA_1\\nA_2\\n\\\\vdots\\nA_H\\n\\n\\nOutput\\n\\nPrint the answer.\\n\\nExamples\\n\\nInput\\n\\n2 2\\n#.\\n.#\\n\\n\\nOutput\\n\\n15\\n\\n\\nInput\\n\\n2 2\\n.\\n.#\\n\\n\\nOutput\\n\\n15\\n\\n\\nInput\\n\\n3 3\\n...\\n...\\n...\\n\\n\\nOutput\\n\\n230\\n\\n\\nInput\\n\\n2 4\\n...\\n...#\\n\\n\\nOutput\\n\\n150\\n\\n\\nInput\\n\\n6 7\\n.......\\n.......\\n.#.....\\n..#....\\n.#.#...\\n.......\\n\\n\\nOutput\\n\\n203949910\",\n  \"Ground Truth Solution\": \"import sys\\ninput = sys.stdin.readline\\n(H, W) = map(int, input().split())\\nA = [input().strip() for i in range(H)]\\nmod = 998244353\\nFACT = [1]\\nfor i in range(1, 21):\\n\\tFACT.append(FACT[-1] * i % mod)\\nFACT_INV = [pow(FACT[-1], mod - 2, mod)]\\nfor i in range(20, 0, -1):\\n\\tFACT_INV.append(FACT_INV[-1] * i % mod)\\nFACT_INV.reverse()\\nCOMBI = [[-1] * 21 for i in range(21)]\\n\\ndef Combi(a, b):\\n\\tif COMBI[a][b] != -1:\\n\\t\\treturn COMBI[a][b]\\n\\tif 0 <= b <= a:\\n\\t\\tCOMBI[a][b] = FACT[a] * FACT_INV[b] * FACT_INV[a - b] % mod\\n\\t\\treturn COMBI[a][b]\\n\\telse:\\n\\t\\tCOMBI[a][b] = 0\\n\\t\\treturn 0\\nM = max(H, W) + 1\\nRA = [[-1] * M for i in range(M)]\\n\\ndef rect(H, W):\\n\\tif H == W == 0:\\n\\t\\treturn 1\\n\\tif RA[H][W] != -1:\\n\\t\\treturn RA[H][W]\\n\\tDP = [[[0, 0] for j in range(W + 1)] for i in range(H + 1)]\\n\\tDP[0][0][0] = 1\\n\\tDP[0][0][1] = 1\\n\\tfor h in range(H + 1):\\n\\t\\tfor w in range(W + 1):\\n\\t\\t\\tfor nexth in range(h + 1, H + 1):\\n\\t\\t\\t\\tDP[nexth][w][0] += DP[h][w][1] * FACT_INV[nexth - h]\\n\\t\\t\\t\\tDP[nexth][w][0] %= mod\\n\\t\\t\\tfor nextw in range(w + 1, W + 1):\\n\\t\\t\\t\\tDP[h][nextw][1] += DP[h][w][0] * FACT_INV[nextw - w]\\n\\t\\t\\t\\tDP[h][nextw][1] %= mod\\n\\tRA[H][W] = RA[W][H] = sum(DP[H][W]) % mod * FACT[H] * FACT[W] % mod\\n\\treturn RA[H][W]\\nCA = [[-1] * (W + 1) for i in range(H + 1)]\\n\\ndef calc(h, w):\\n\\tif CA[h][w] != -1:\\n\\t\\treturn CA[h][w]\\n\\tRET = 0\\n\\tfor bh in range(h + 1):\\n\\t\\tfor bw in range(w + 1):\\n\\t\\t\\tRET += rect(bh, w - bw) * rect(h - bh, bw) * Combi(h, bh) * Combi(w, bw)\\n\\t\\t\\tRET %= mod\\n\\tCA[h][w] = RET % mod\\n\\treturn CA[h][w]\\nfor i in range(H + 1):\\n\\tfor j in range(W + 1):\\n\\t\\tcalc(i, j)\\nANS = rect(H, W)\\nfor i in range((1 << H) - 1):\\n\\tfor j in range((1 << W) - 1):\\n\\t\\tokflag = 1\\n\\t\\tfor h in range(H):\\n\\t\\t\\tif i & 1 << h != 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tcoinc = ''\\n\\t\\t\\tdif = 0\\n\\t\\t\\tfor w in range(W):\\n\\t\\t\\t\\tif j & 1 << w != 0:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif coinc == '':\\n\\t\\t\\t\\t\\tcoinc = A[h][w]\\n\\t\\t\\t\\telif A[h][w] != coinc:\\n\\t\\t\\t\\t\\tdif = 1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tif dif == 0:\\n\\t\\t\\t\\tokflag = 0\\n\\t\\t\\t\\tbreak\\n\\t\\tif okflag == 0:\\n\\t\\t\\tcontinue\\n\\t\\tokflag = 1\\n\\t\\tfor w in range(W):\\n\\t\\t\\tif j & 1 << w != 0:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tcoinc = ''\\n\\t\\t\\tdif = 0\\n\\t\\t\\tfor h in range(H):\\n\\t\\t\\t\\tif i & 1 << h != 0:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif coinc == '':\\n\\t\\t\\t\\t\\tcoinc = A[h][w]\\n\\t\\t\\t\\telif A[h][w] != coinc:\\n\\t\\t\\t\\t\\tdif = 1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tif dif == 0:\\n\\t\\t\\tokflag = 0\\n\\t\\t\\tbreak\\n\\t\\tif okflag == 0:\\n\\t\\t\\tcontinue\\n\\t\\tHR = WR = 0\\n\\t\\tfor h in range(H):\\n\\t\\t\\tif i & 1 << h != 0:\\n\\t\\t\\t\\tHR += 1\\n\\t\\tfor w in range(W):\\n\\t\\t\\tif j & 1 << w != 0:\\n\\t\\t\\t\\tWR += 1\\n\\t\\tANS += CA[HR][WR]\\nprint(ANS % mod)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The core task is to determine the number of achievable grid states from an initial grid, given row/column coloring operations. This involves combinatorics, specifically counting how many unique grids can be generated.\\n- Identifying Core Constraints: The small constraints (H, W <= 10) suggests that bitmasking or dynamic programming approaches could work. The modulo operation indicates the necessity to avoid integer overflow during calculation and to perform all computations modulo 998,244,353.\\n- Selecting an Algorithmic Strategy:  The problem can be approached by first considering the number of ways to create distinct sub-grids with given row/column operations, using dynamic programming or recursion, and then applying combinatorics to account for the number of ways to select row/column operations. Identify the combinations of row/column operations that lead to overlapping changes in the grid's colors, making it harder to simply sum up individual cases.\",\n  \"LLM Questions\": [\n    \"How can we represent the state of each square in the grid, and how does applying row or column operations change these states?\",\n    \"How can we avoid counting duplicate grid states caused by different sequences of row/column operations?\",\n    \"How can we efficiently count the possible configurations using dynamic programming given the constraints on H and W?\",\n    \"How do the initial grid's colors influence the overall count of obtainable grid states?\",\n    \"Can we analyze each row and column independently to determine their contribution to the final count, or are there dependencies we need to consider?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Each square can be in one of two states: white or black. Row or column operations can flip all squares in the selected row or column to either white or black. Each row and column can be considered to have 3 states: original, white, or black.\",\n    \"We need to use inclusion-exclusion or other techniques to ensure each distinct grid state is counted only once. Overlapping or dependent operations needs to be identified.\",\n    \"A dynamic programming table could track the number of ways to reach different grid states by considering the effect of each operation at each step, starting from the initial grid state. Memoization is necessary to avoid recomputation.\",\n    \"The initial grid's colors determine the starting point for the operations and constrain the possible grid states we can reach.\",\n    \"It's unlikely they can be analyzed independently due to the interaction of row and column operations. Bitmasking can be useful to represent row and column operations. Initial attempts at creating distinct grid states independently using combinations might not lead to an accurate approach.\"\n  ]\n}\n```"