"```json\n{\n  \"Coding Problem\": \"You are given an array $a$ consisting of $n$ non-negative integers. It is guaranteed that $a$ is sorted from small to large.\\n\\nFor each operation, we generate a new array $b_i=a_{i+1}-a_{i}$ for $1 \\\\le i < n$. Then we sort $b$ from small to large, replace $a$ with $b$, and decrease $n$ by $1$.\\n\\nAfter performing $n-1$ operations, $n$ becomes $1$. You need to output the only integer in array $a$ (that is to say, you need to output $a_1$).\\n\\n\\n-----Input-----\\n\\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1\\\\le t\\\\le 10^4$) \u2014 the number of test cases. The description of the test cases follows.\\n\\nThe first line of each test case contains one integer $n$ ($2\\\\le n\\\\le 10^5$) \u2014 the length of the array $a$.\\n\\nThe second line contains $n$ integers $a_1,a_2,\\\\dots,a_n$ ($0\\\\le a_1\\\\le \\\\ldots\\\\le a_n \\\\le 5\\\\cdot 10^5$) \u2014 the array $a$.\\n\\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2.5\\\\cdot 10^5$, and the sum of $a_n$ over all test cases does not exceed $5\\\\cdot 10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case, output the answer on a new line.\\n\\n\\n-----Examples-----\\n\\nInput\\n5\\n3\\n1 10 100\\n4\\n4 8 9 13\\n5\\n0 0 0 8 13\\n6\\n2 4 8 16 32 64\\n7\\n0 0 0 0 0 0 0\\nOutput\\n81\\n3\\n1\\n2\\n0\\n\\n\\n-----Note-----\\n\\nTo simplify the notes, let $\\\\operatorname{sort}(a)$ denote the array you get by sorting $a$ from small to large.\\n\\nIn the first test case, $a=[1,10,100]$ at first. After the first operation, $a=\\\\operatorname{sort}([10-1,100-10])=[9,90]$. After the second operation, $a=\\\\operatorname{sort}([90-9])=[81]$.\\n\\nIn the second test case, $a=[4,8,9,13]$ at first. After the first operation, $a=\\\\operatorname{sort}([8-4,9-8,13-9])=[1,4,4]$. After the second operation, $a=\\\\operatorname{sort}([4-1,4-4])=[0,3]$. After the last operation, $a=\\\\operatorname{sort}([3-0])=[3]$.\",\n  \"Ground Truth Solution\": \"from collections import defaultdict, OrderedDict\\nInputList = lambda Dtype: [Dtype(x) for x in input().split()]\\nimport bisect\\n\\ndef solve():\\n\\tN = int(input())\\n\\tnums = InputList(int)\\n\\tn_zeros = bisect.bisect(nums, 0)\\n\\tnums = nums[n_zeros:]\\n\\tif not nums:\\n\\t\\treturn 0\\n\\tfor _ in range(N - 1):\\n\\t\\tdiff = []\\n\\t\\tif n_zeros:\\n\\t\\t\\tdiff.append(nums[0])\\n\\t\\t\\tn_zeros -= 1\\n\\t\\tfor i in range(len(nums) - 1):\\n\\t\\t\\tcur = nums[i + 1] - nums[i]\\n\\t\\t\\tif cur:\\n\\t\\t\\t\\tdiff.append(cur)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn_zeros += 1\\n\\t\\tif not diff:\\n\\t\\t\\treturn 0\\n\\t\\tif len(diff) == 1:\\n\\t\\t\\treturn diff[0]\\n\\t\\tnums = sorted(diff)\\nReturnMode = True\\nt = None\\nif not t:\\n\\tt = int(input())\\nif ReturnMode:\\n\\tfor _ in range(t):\\n\\t\\tans = solve()\\n\\t\\tif type(ans) == list:\\n\\t\\t\\tprint(*ans)\\n\\t\\telse:\\n\\t\\t\\tprint(ans)\\nelse:\\n\\tfor _ in range(t):\\n\\t\\tsolve()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires performing a series of operations on an initially sorted array. Each operation involves computing the differences between consecutive elements, sorting these differences, and replacing the original array with the sorted differences. This is repeated `n-1` times until only one element remains.\\n- Edge Cases and Constraints: Need to handle cases where the difference array might contain zero or become empty. The initial array is sorted in non-decreasing order, and the integers are non-negative.\\n- Optimizations and Algorithm Selection: Simulate the process step by step. Consider how to efficiently compute and sort the differences, and also correctly handle scenarios with zeros in the difference array. The constraint on the size of the input array and the potential values suggests that a simple iterative approach should be sufficient.\",\n  \"LLM Questions\": [\n    \"What should the program return if the difference array becomes empty at any step?\",\n    \"How should the algorithm handle zeros that appear in the difference array?\",\n    \"What is the purpose of sorting the difference array at each step?\",\n    \"How can we efficiently compute the difference array at each step of the algorithm?\",\n    \"What are the constraints on the input array and the operations that the algorithm must handle?\",\n    \"Can you explain the problem in simpler terms, outlining the exact steps to follow?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"If the difference array becomes empty, the program should return 0.\",\n    \"Zeros should be included in the sorted difference array as needed. When constructing the differences, if a difference equals 0, count the number of zeros and use them in the next iteration.\",\n    \"Sorting the difference array ensures that the array `a` in the next iteration is also sorted from small to large as specified by the problem description.\",\n    \"The difference array can be computed by iterating through the array and taking the difference between each adjacent pair of elements.\",\n    \"The input array is guaranteed to be sorted in non-decreasing order and contains non-negative integers. Each operation involves computing differences, sorting, and replacing the array, repeating `n-1` times.\",\n    \"The problem provides a sorted array, and requires repeated replacement with an array consisting of sorted differences between adjacent elements, until a single number is left. The single remaining number is the answer.\"\n  ]\n}\n```"