"```json\n{\n  \"Coding Problem\": \"In BerSoft $n$ programmers work, the programmer $i$ is characterized by a skill $r_i$.\\n\\nA programmer $a$ can be a mentor of a programmer $b$ if and only if the skill of the programmer $a$ is strictly greater than the skill of the programmer $b$ $(r_a > r_b)$ and programmers $a$ and $b$ are not in a quarrel.\\n\\nYou are given the skills of each programmers and a list of $k$ pairs of the programmers, which are in a quarrel (pairs are unordered). For each programmer $i$, find the number of programmers, for which the programmer $i$ can be a mentor.\\n\\n\\n-----Input-----\\n\\nThe first line contains two integers $n$ and $k$ $(2 \\le n \\le 2 \\cdot 10^5$, $0 \\le k \\le \\min(2 \\cdot 10^5, \\frac{n \\cdot (n - 1)}{2}))$ \u2014 total number of programmers and number of pairs of programmers which are in a quarrel.\\n\\nThe second line contains a sequence of integers $r_1, r_2, \\\\dots, r_n$ $(1 \\le r_i \\le 10^{9})$, where $r_i$ equals to the skill of the $i$-th programmer.\\n\\nEach of the following $k$ lines contains two distinct integers $x$, $y$ $(1 \\le x, y \\le n$, $x \\\\ne y)$ \u2014 pair of programmers in a quarrel. The pairs are unordered, it means that if $x$ is in a quarrel with $y$ then $y$ is in a quarrel with $x$. Guaranteed, that for each pair $(x, y)$ there are no other pairs $(x, y)$ and $(y, x)$ in the input.\\n\\n\\n-----Output-----\\n\\nPrint $n$ integers, the $i$-th number should be equal to the number of programmers, for which the $i$-th programmer can be a mentor. Programmers are numbered in the same order that their skills are given in the input.\\n\\n\\n-----Examples-----\\nInput\\n4 2\\n10 4 10 15\\n1 2\\n4 3\\n\\nOutput\\n0 0 1 2 \\n\\nInput\\n10 4\\n5 4 1 5 4 3 7 1 2 5\\n4 6\\n2 1\\n10 8\\n3 5\\n\\nOutput\\n5 4 0 5 3 3 9 0 2 5 \\n\\n\\n-----Note-----\\n\\nIn the first example, the first programmer can not be mentor of any other (because only the second programmer has a skill, lower than first programmer skill, but they are in a quarrel). The second programmer can not be mentor of any other programmer, because his skill is minimal among others. The third programmer can be a mentor of the second programmer. The fourth programmer can be a mentor of the first and of the second programmers. He can not be a mentor of the third programmer, because they are in a quarrel.\",\n  \"Ground Truth Solution\": \"from bisect import bisect_left\\n(n, k) = map(int, input().split())\\na = [int(x) for x in input().split()]\\nsa = sorted(a)\\nans = [0] * n\\nfor i in range(k):\\n\\t(x, y) = map(int, input().split())\\n\\tx -= 1\\n\\ty -= 1\\n\\tif a[x] > a[y]:\\n\\t\\tans[x] -= 1\\n\\tif a[y] > a[x]:\\n\\t\\tans[y] -= 1\\nfor i in range(n):\\n\\tt = bisect_left(sa, a[i])\\n\\tans[i] += t\\n\\tprint(ans[i], end=' ')\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem Requirements: The problem asks to find, for each programmer, the number of other programmers they can mentor. A programmer can be a mentor if their skill is strictly greater and they are not in a quarrel.\\n- Data Structures and Input Parsing: Store the skills of programmers in an array. Use a list to store the quarrel pairs. Parse the input to populate these data structures.\\n- Algorithm Selection: For each programmer, iterate through all other programmers. Check if the skill condition is met and if they are not in a quarrel. Count the number of eligible mentees.\\n- Optimization Considerations: Sort the skills to efficiently determine the number of programmers with lower skills using binary search. Account for quarrel pairs by adjusting the count.\\n- Edge Cases and Constraints: Handle the constraint that programmers cannot mentor themselves. Consider the input size constraints and choose an appropriate time complexity.\",\n  \"LLM Questions\": [\n    \"How do you efficiently determine the number of programmers with lower skills than a given programmer?\",\n    \"How do you represent and manage the quarrel pairs to quickly check if two programmers are in a quarrel?\",\n    \"What is the time complexity of your approach, and how does it scale with the input size?\",\n    \"How do you handle the case where a programmer cannot mentor themselves?\",\n    \"How can you optimize the solution further, given the constraints on the input size?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"You can sort the skills and use binary search (bisect_left) to find the number of programmers with lower skills in O(log n) time.\",\n    \"You can use a set of tuples or a dictionary where keys are programmers to represent quarrel pairs. This allows for efficient lookup (O(1) on average) to determine if two programmers are in a quarrel.\",\n    \"The time complexity should ideally be O(n log n + k) where n is the number of programmers and k is the number of quarrels. Sorting takes O(n log n) and iterating through the quarrels takes O(k) time. Checking for potential mentees may involve iterating over all programmers.\",\n    \"Ensure that you do not include the programmer itself when counting potential mentees. The condition `if i != j` should be included in the loop.\",\n    \"Precomputing the number of programmers with lower skills, combined with fast quarrel pair lookups can lead to a faster, more efficient solution. Be mindful of the input size and choose algorithms with better asymptotic complexity.\"\n  ]\n}\n```"