"```json\n{\n  \"Coding Problem\": \"Little Artem likes electronics. He can spend lots of time making different schemas and looking for novelties in the nearest electronics store. The new control element was delivered to the store recently and Artem immediately bought it.\\n\\nThat element can store information about the matrix of integers size n \u00d7 m. There are n + m inputs in that element, i.e. each row and each column can get the signal. When signal comes to the input corresponding to some row, this row cyclically shifts to the left, that is the first element of the row becomes last element, second element becomes first and so on. When signal comes to the input corresponding to some column, that column shifts cyclically to the top, that is first element of the column becomes last element, second element becomes first and so on. Rows are numbered with integers from 1 to n from top to bottom, while columns are numbered with integers from 1 to m from left to right.\\n\\nArtem wants to carefully study this element before using it. For that purpose he is going to set up an experiment consisting of q turns. On each turn he either sends the signal to some input or checks what number is stored at some position of the matrix.\\n\\nArtem has completed his experiment and has written down the results, but he has lost the chip! Help Artem find any initial matrix that will match the experiment results. It is guaranteed that experiment data is consistent, which means at least one valid matrix exists.\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains three integers n, m and q (1 \u2264 n, m \u2264 100, 1 \u2264 q \u2264 10 000)\u00a0\u2014 dimensions of the matrix and the number of turns in the experiment, respectively.\\n\\nNext q lines contain turns descriptions, one per line. Each description starts with an integer t_{i} (1 \u2264 t_{i} \u2264 3) that defines the type of the operation. For the operation of first and second type integer r_{i} (1 \u2264 r_{i} \u2264 n) or c_{i} (1 \u2264 c_{i} \u2264 m) follows, while for the operations of the third type three integers r_{i}, c_{i} and x_{i} (1 \u2264 r_{i} \u2264 n, 1 \u2264 c_{i} \u2264 m,  - 10^9 \u2264 x_{i} \u2264 10^9) are given.\\n\\nOperation of the first type (t_{i} = 1) means that signal comes to the input corresponding to row r_{i}, that is it will shift cyclically. Operation of the second type (t_{i} = 2) means that column c_{i} will shift cyclically. Finally, operation of the third type means that at this moment of time cell located in the row r_{i} and column c_{i} stores value x_{i}.\\n\\n\\n-----Output-----\\n\\nPrint the description of any valid initial matrix as n lines containing m integers each. All output integers should not exceed 10^9 by their absolute value.\\n\\nIf there are multiple valid solutions, output any of them.\\n\\n\\n-----Examples-----\\nInput\\n2 2 6\\n2 1\\n2 2\\n3 1 1 1\\n3 2 2 2\\n3 1 2 8\\n3 2 1 8\\n\\nOutput\\n8 2 \\n1 8 \\n\\nInput\\n3 3 2\\n1 2\\n3 2 2 5\\n\\nOutput\\n0 0 0 \\n0 0 5 \\n0 0 0\",\n  \"Ground Truth Solution\": \"f = lambda : list(map(int, input().split()))\\n(n, m, q) = f()\\np = [[0] * m for j in range(n)]\\nfor t in [list(f()) for k in range(q)][::-1]:\\n\\tj = t[1] - 1\\n\\tif t[0] == 1:\\n\\t\\tp[j].insert(0, p[j].pop())\\n\\telif t[0] == 2:\\n\\t\\ts = p[-1][j]\\n\\t\\tfor i in range(n - 1, 0, -1):\\n\\t\\t\\tp[i][j] = p[i - 1][j]\\n\\t\\tp[0][j] = s\\n\\telse:\\n\\t\\tp[j][t[2] - 1] = t[3]\\nfor d in p:\\n\\tprint(*d)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires reconstructing an initial matrix state based on a series of operations. These operations involve shifting rows left, shifting columns up, and setting values at specific positions. The operations are given in reverse chronological order, meaning the last operation is applied first.\\n- Algorithm Choice: The most straightforward approach is to simulate the operations in reverse. Start with an initial matrix filled with any arbitrary value (e.g., 0). Then, iterate through the operations in reverse order. If the operation is setting a value, directly set it. If the operation is a row shift, shift the row right. If the operation is a column shift, shift the column down.\\n- Handling Shifts: Implementing the row and column shifts correctly is crucial. Since we're processing the operations in reverse, a \\\"shift left\\\" operation needs to be reversed to \\\"shift right,\\\" and a \\\"shift up\\\" operation needs to be reversed to \\\"shift down.\\\"\\n- Data Structures: A 2D list (list of lists) is suitable for representing the matrix. This will allow easy access to elements and manipulation of rows and columns.\\n- Optimization: There isn't significant room for optimization given the constraints (n, m <= 100, q <= 10000). Direct simulation should be efficient enough.\",\n  \"LLM Questions\": [\n    \"Why is it necessary to iterate through the operations in reverse order?\",\n    \"How do you reverse a \\\"shift left\\\" operation for a row and a \\\"shift up\\\" operation for a column?\",\n    \"What data structure is most appropriate for representing the matrix, and why?\",\n    \"Given the problem constraints, is there a need for any advanced optimization techniques?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Iterating in reverse order is necessary because we are trying to reconstruct the initial state of the matrix by undoing the operations. Since we are given the operations in the order they were applied, we need to reverse that order to reverse the effects of the operations.\",\n    \"To reverse a \\\"shift left\\\" operation for a row, we need to shift the row to the right. This involves moving the last element of the row to the first position. Similarly, to reverse a \\\"shift up\\\" operation for a column, we need to shift the column down, moving the last element to the first position of column.\",\n    \"A 2D list (list of lists) is most appropriate because it provides a simple and direct way to represent the matrix. It allows for easy access to elements by row and column indices and supports in-place modifications, which is crucial for simulating the shifts.\",\n    \"Given that n and m are at most 100 and q is at most 10000, a straightforward simulation without advanced optimization techniques should be efficient enough. The total number of operations is relatively small, and accessing and modifying elements in a 2D list is a fast operation for these input sizes.\"\n  ]\n}\n```"