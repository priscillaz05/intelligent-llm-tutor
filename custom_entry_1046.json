"```json\n{\n  \"Coding Problem\": \"When you look at photographs of watches and clocks, you'll find that they almost always show the time 10:10. There are lots of theories and even urban legends about this. For example, when showing 10:10, the hands look like a smile, and so you are more inclined to buy the watch or clock :D (a form of subliminal advertising).\\n\\nNow, you are given $N$ and ${M}$. You are to find the number of sequences $A_{1},A_{2},\\\\ldots,A_{N}$ such that:\\n\\n${A_1}$ is a number of the form ${1010}^K$ for some $1\\\\leq K\\\\leq M$,\\nIf $P=A_2\\\\cdot A_3\\\\cdots A_N$, then ${A_1}$ is divisible by ${P}$, and $\\\\mbox{P}$ is divisible by ${1010}$, and\\n$A_2,A_3,\\\\ldots,A_N$ are squarefree.\\n\\nSince the number can be very large, only give the number modulo ${2000003}$.\\n\\nInput Format \\n\\nThe first line of input contains a single integer ${T}$, which is the number of test cases. The following lines contain the test cases.\\n\\nEach test case consists of one line containing two integers, $N$ and ${M}$.\\n\\nConstraints \\n\\n$1\\\\leq T\\\\leq10^5$ \\n\\n$2\\\\leq N\\\\leq M\\\\leq10^{12}$  \\n\\nOutput Format \\n\\nFor each test case, output a single line containing the answer.\\n\\nSample Input  \\n\\n2\\n2 3\\n3 3\\n\\nSample Output  \\n\\n3\\n62\\n\\nExplanation \\n\\nFor the first test case, the possible sequences are: \\n\\n${1010,1010}$, \\n\\n${1020100,1010}$, \\n\\n${103031000},{1010}$\",\n  \"Ground Truth Solution\": \"import sys\\n\\ndef read_one():\\n\\treturn sys.stdin.readline().strip()\\n\\ndef read_spaced():\\n\\treturn sys.stdin.readline().strip().split()\\n\\ndef read_spaced_int():\\n\\treturn map(int, read_spaced())\\nmod = 2 * 10 ** 6 + 3\\nN_max = mod - 1\\nfac = [1] * (N_max + 1)\\ninvfac = [1] * (N_max + 1)\\ninv2 = pow(2, mod - 2, mod)\\nfor i in range(2, N_max + 1):\\n\\tfac[i] = fac[i - 1] * i % mod\\ninvfac[N_max] = pow(fac[N_max], mod - 2, mod)\\nfor i in reversed(range(2, N_max)):\\n\\tinvfac[i] = invfac[i + 1] * (i + 1) % mod\\n\\ndef binomial(n, k):\\n\\tif n < k or k < 0:\\n\\t\\treturn 0\\n\\treturn fac[n] * invfac[k] * invfac[n - k] % mod\\n\\ndef get_digits(N, B):\\n\\tD = []\\n\\twhile N:\\n\\t\\t(N, d) = divmod(N, B)\\n\\t\\tD.append(d)\\n\\treturn D\\n\\ndef catalan(N):\\n\\t(D1, D2) = (get_digits(N, mod), get_digits(2 * N, mod))\\n\\tans = 1\\n\\tfor i in range(len(D1)):\\n\\t\\tif D1[i] > D2[i]:\\n\\t\\t\\treturn 0\\n\\t\\tans = ans * binomial(D2[i], D1[i]) % mod\\n\\treturn ans\\n\\ndef S1(N):\\n\\treturn (N + 2) * pow(2, N - 1, mod) % mod\\n\\ndef S2(N):\\n\\treturn ((N + 2) * pow(2, 2 * N - 1, mod) - inv2 * N * catalan(N)) % mod\\n\\ndef S3(N):\\n\\tif N == 1:\\n\\t\\treturn 9\\n\\tc = catalan(N)\\n\\treturn ((N + 2) * pow(2, 3 * N - 1, mod) - 3 * N * c * pow(2, N - 2, mod)) % mod\\n\\ndef solve(N, M):\\n\\tans = (M - N) * pow(pow(2, N, mod) - 1, 3, mod) % mod\\n\\tans = (ans + S3(N) - 3 * S2(N) + 3 * S1(N) - N - 1) % mod\\n\\treturn ans\\nT = int(read_one())\\nfor _ in range(T):\\n\\t(N, M) = read_spaced_int()\\n\\tprint(solve(N - 1, M))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks to find the number of sequences $A_1, A_2, ..., A_N$ under specific divisibility and square-free constraints, modulo 2000003.\\n- Deconstructing the Constraints: $A_1$ must be of the form $1010^K$. The product of $A_2$ to $A_N$ must divide $A_1$ and must be divisible by 1010. $A_2$ to $A_N$ are square-free.\\n- Identifying Core Relationships: Since $A_2, ..., A_N$ are squarefree and their product P divides $A_1 = 1010^K$, each $A_i$ can only contain prime factors of 1010, i.e., 2, 5, 101.\\n- Algorithmic Strategy Selection: This problem likely requires careful combinatorial analysis and possibly dynamic programming. Considering the modulo constraint (2000003), the answer calculation may involve precomputed factorials, inverse factorials, and modular exponentiation.\\n- Mathematical Formulation: Let's denote the number of allowed sequences. Since $A_1 = 1010^k$, the product $P = A_2 \\cdot ... \\cdot A_N$ must divide $1010^k$. Also P is divisible by 1010, so it contains at least one factor of 2, 5, and 101.\\n- Modular Arithmetic Handling: Efficiently compute modulo inverses and intermediate results within the range to avoid overflow issues.\",\n  \"LLM Questions\": [\n    \"What are the prime factors of 1010, and how do they constrain the possible values of $A_2, ..., A_N$?\",\n    \"Given $A_1 = 1010^K$, how does the upper bound $M$ limit the choices for K, and how does this translate to the possible values of $A_1$?\",\n    \"How do the square-free constraints affect the possible values of the sequence $A_2, A_3, ..., A_N$, especially considering the divisibility requirement?\",\n    \"What combinatorial or dynamic programming strategies might be suitable to count the number of valid sequences, given the constraints and the modulo?\",\n    \"How can we leverage modular arithmetic to efficiently compute the answer modulo 2000003, especially when dealing with potentially large exponents and factorials?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The prime factors of 1010 are 2, 5, and 101. Because $A_2, ..., A_N$ are square-free and their product must divide $A_1 = 1010^K$, each $A_i$ can only be a product of distinct combinations of these primes.\",\n    \"Since $A_1 = 1010^K$ and $1 \\\\leq K \\\\leq M$, the choices for K are integers from 1 to M. This directly determines the possible values of $A_1$, which, in turn, limits the possible divisors $A_2 * ... * A_N$.\",\n    \"The square-free constraint implies each $A_i$ is not divisible by the square of any prime. Therefore, if $A_i$ can be represented as $2^a * 5^b * 101^c$ then $a, b, c$ can only be 0 or 1.\",\n    \"Combinatorial strategies could involve counting the possible combinations of $A_2, ..., A_N$ that satisfy the divisibility rules. Dynamic programming could be used to manage the constraints and build up the answer.\",\n    \"Modular arithmetic is essential for preventing integer overflow. Using properties like $(a * b) \\\\mod m = ((a \\\\mod m) * (b \\\\mod m)) \\\\mod m$ and Fermat's Little Theorem for modular inverses helps maintain results within the required range.  Precomputing factorials and their inverses modulo 2000003 can improve efficiency.\"\n  ]\n}\n```"