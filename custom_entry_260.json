"```json\n{\n  \"Coding Problem\": \"You are given an array of $n$ integers. You need to split all integers into two groups so that the GCD of all integers in the first group is equal to one and the GCD of all integers in the second group is equal to one.\\n\\nThe GCD of a group of integers is the largest non-negative integer that divides all the integers in the group.\\n\\nBoth groups have to be non-empty.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $n$ ($2 \\leq n \\leq 10^5$).\\n\\nThe second line contains $n$ integers $a_1$, $a_2$, $\\ldots$, $a_n$ ($1 \\leq a_i \\leq 10^9$)\u00a0\u2014 the elements of the array.\\n\\n\\n-----Output-----\\n\\nIn the first line print \\\"YES\\\" (without quotes), if it is possible to split the integers into two groups as required, and \\\"NO\\\" (without quotes) otherwise.\\n\\nIf it is possible to split the integers, in the second line print $n$ integers, where the $i$-th integer is equal to $1$ if the integer $a_i$ should be in the first group, and $2$ otherwise.\\n\\nIf there are multiple solutions, print any.\\n\\n\\n-----Examples-----\\nInput\\n4\\n2 3 6 7\\n\\nOutput\\nYES\\n2 2 1 1 \\n\\nInput\\n5\\n6 15 35 77 22\\n\\nOutput\\nYES\\n2 1 2 1 1 \\n\\nInput\\n5\\n6 10 15 1000 75\\n\\nOutput\\nNO\",\n  \"Ground Truth Solution\": \"import sys\\n\\ndef gcd(l):\\n\\tif len(l) == 0:\\n\\t\\treturn 0\\n\\tif len(l) == 1:\\n\\t\\treturn l[0]\\n\\tif len(l) == 2:\\n\\t\\tif l[1] == 0:\\n\\t\\t\\treturn l[0]\\n\\t\\treturn gcd([l[1], l[0] % l[1]])\\n\\treturn gcd([gcd(l[:-1]), l[-1]])\\n\\ndef brute_force(l1, l2, l, sol):\\n\\tif len(l) == 0:\\n\\t\\tg1 = gcd(l1)\\n\\t\\tg2 = gcd(l2)\\n\\t\\treturn (g1 == 1 and g2 == 1, sol)\\n\\t(res, s) = brute_force(l1 + [l[0]], l2, l[1:], sol + [1])\\n\\tif res:\\n\\t\\treturn (True, s)\\n\\treturn brute_force(l1, l2 + [l[0]], l[1:], sol + [2])\\n\\ndef factor(n):\\n\\tres = []\\n\\ti = 2\\n\\twhile i * i <= n:\\n\\t\\tif n % i == 0:\\n\\t\\t\\tres.append(i)\\n\\t\\twhile n % i == 0:\\n\\t\\t\\tn = int(n / i)\\n\\t\\ti += 1\\n\\tif n != 1:\\n\\t\\tres.append(n)\\n\\treturn res\\n\\ndef dumpsol(sol):\\n\\tfor v in sol:\\n\\t\\tprint(v, end=' ')\\nn = int(sys.stdin.readline())\\nl = sys.stdin.readline().strip().split(' ')[0:n]\\nl = [int(x) for x in l]\\nif n < 12:\\n\\t(ret, sol) = brute_force([], [], l, [])\\n\\tif ret:\\n\\t\\tprint('YES')\\n\\t\\tdumpsol(sol)\\n\\telse:\\n\\t\\tprint('NO')\\n\\treturn\\nfactors = {}\\nfor i in range(10):\\n\\tfor key in factor(l[i]):\\n\\t\\tfactors[key] = 0\\nflists = {}\\nfor f in factors:\\n\\tflists[f] = []\\n\\tpos = 0\\n\\tfound = False\\n\\tfor v in l:\\n\\t\\tif v % f != 0:\\n\\t\\t\\tfound = True\\n\\t\\t\\tfactors[f] += 1\\n\\t\\t\\tflists[f].append(pos)\\n\\t\\t\\tif factors[f] > 9:\\n\\t\\t\\t\\tbreak\\n\\t\\tpos += 1\\n\\tif not found:\\n\\t\\tprint('NO')\\n\\t\\treturn\\noftf = []\\nis \u09b8\u09ab\u099ftf = {}\\nfor f in factors:\\n\\tif factors[f] == 0:\\n\\t\\tprint('NO')\\n\\t\\treturn\\n\\tif factors[f] < 10:\\n\\t\\toftf.append(f)\\n\\t\\tis \u09b8\u09ab\u099ftf[f] = 1\\nsol = [1 for i in range(len(l))]\\nx = l[0]\\nsol[0] = 2\\noxf = factor(x)\\nxf = []\\nnxf = 0\\nisxoftf = {}\\nfor f in oxf:\\n\\tif f in isoftf:\\n\\t\\tnxf += 1\\n\\t\\tisxoftf[f] = 1\\n\\t\\txf.append(f)\\n\\telse:\\n\\t\\tsol[flists[f][0]] = 2\\nnonxf = []\\nfor f in oftf:\\n\\tif not f in isxoftf:\\n\\t\\tnonxf.append(f)\\nmasks = {}\\npos = 0\\nfor f in xf + nonxf:\\n\\tfor v in flists[f]:\\n\\t\\tif not v in masks:\\n\\t\\t\\tmasks[v] = 0\\n\\t\\tmasks[v] |= 1 << pos\\n\\tpos += 1\\nvals = [{} for i in range(len(masks) + 1)]\\nvals[0][0] = 0\\npos = 0\\nmlist = []\\nfor mask in masks:\\n\\tmlist.append(mask)\\n\\tcmask = masks[mask]\\n\\tcmask1 = cmask << 10\\n\\tfor v in vals[pos]:\\n\\t\\tvals[pos + 1][v | cmask] = v\\n\\t\\tif mask != 0:\\n\\t\\t\\tvals[pos + 1][v | cmask1] = v\\n\\tpos += 1\\ntest_val = (1 << len(xf)) - 1 | (1 << len(oftf)) - 1 << 10\\nfor v in vals[pos]:\\n\\tif v & test_val == test_val:\\n\\t\\tprint('YES')\\n\\t\\twhile pos != 0:\\n\\t\\t\\tnv = vals[pos][v]\\n\\t\\t\\tif nv ^ v < 1024 and nv ^ v != 0:\\n\\t\\t\\t\\tsol[mlist[pos - 1]] = 2\\n\\t\\t\\tv = nv\\n\\t\\t\\tpos -= 1\\n\\t\\tdumpsol(sol)\\n\\t\\treturn\\nprint('NO')\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires splitting an array of integers into two non-empty groups such that the GCD of each group is 1. The task is to determine if such a split is possible and, if so, to provide an example split.\\n- Identifying Potential Strategies: Given the constraint that both groups must have a GCD of 1, consider strategies based on prime factorization and divisibility. A brute-force approach may be suitable for smaller input sizes. For larger inputs, a more efficient approach is needed.\\n- Algorithmic Considerations: If any integer in the array does not share a common factor with the other integers in the array, then we can make GCD one by putting them in the first group. We can use prime factorization and bit masking techniques to arrive at a polynomial time algorithm.\\n- Edge Case Handling: Consider edge cases such as when no such split is possible (return \\\"NO\\\") or when multiple splits are possible (return any valid split).\",\n  \"LLM Questions\": [\n    \"What are the key constraints for splitting the array into two groups?\",\n    \"How does the concept of GCD apply to determining a valid split?\",\n    \"What approaches might be suitable for small vs. large input sizes?\",\n    \"How can prime factorization or divisibility properties help in finding a valid split?\",\n    \"What conditions would lead to the conclusion that no valid split is possible?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Each group must be non-empty, and the GCD of the integers in each group must be equal to 1.\",\n    \"The GCD must be computed for each group, and the groups are only valid if both have a GCD of 1.\",\n    \"For small inputs, a brute-force approach might be feasible, while larger inputs would require a more efficient approach based on prime factorization or similar techniques.\",\n    \"Prime factorization can help identify common factors among the numbers, and if numbers can be separated such that each group has no common factors other than 1, a valid split is possible.\",\n    \"If all numbers in the array share a common factor greater than 1, it is impossible to split them into two groups where each group has a GCD of 1. Another condition would be that the number of elements is less than 2, since the question indicates n >= 2.\"\n  ]\n}\n```"