"```json\n{\n  \"Coding Problem\": \"A binary string is a string that consists of characters $0$ and $1$. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\\n\\nLet $\\\\operatorname{MEX}$ of a bi-table be the smallest digit among $0$, $1$, or $2$ that does not occur in the bi-table. For example, $\\\\operatorname{MEX}$ for $\\\\begin{bmatrix} 0011\\\\\\\\ 1010 \\\\end{bmatrix}$ is $2$, because $0$ and $1$ occur in the bi-table at least once. $\\\\operatorname{MEX}$ for $\\\\begin{bmatrix} 111\\\\\\\\ 111 \\\\end{bmatrix}$ is $0$, because $0$ and $2$ do not occur in the bi-table, and $0 < 2$.\\n\\nYou are given a bi-table with $n$ columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\\n\\nWhat is the maximal sum of $\\\\operatorname{MEX}$ of all resulting bi-tables can be?\\n\\n\\n-----Input-----\\n\\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\\\le t \\\\le 10^4$) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of the description of each test case contains a single integer $n$ ($1 \\\\le n \\\\le 10^5$) \u2014 the number of columns in the bi-table.\\n\\nEach of the next two lines contains a binary string of length $n$ \u2014 the rows of the bi-table.\\n\\nIt's guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case print a single integer \u2014 the maximal sum of $\\\\operatorname{MEX}$ of all bi-tables that it is possible to get by cutting the given bi-table optimally.\\n\\n\\n-----Examples-----\\n\\nInput\\n4\\n7\\n0101000\\n1101100\\n5\\n01100\\n10101\\n2\\n01\\n01\\n6\\n000000\\n111111\\nOutput\\n8\\n8\\n2\\n12\\n\\n\\n-----Note-----\\n\\nIn the first test case you can cut the bi-table as follows:\\n\\n$\\\\begin{bmatrix} 0\\\\\\\\ 1 \\\\end{bmatrix}$, its $\\\\operatorname{MEX}$ is $2$.\\n\\n$\\\\begin{bmatrix} 10\\\\\\\\ 10 \\\\end{bmatrix}$, its $\\\\operatorname{MEX}$ is $2$.\\n\\n$\\\\begin{bmatrix} 1\\\\\\\\ 1 \\\\end{bmatrix}$, its $\\\\operatorname{MEX}$ is $0$.\\n\\n$\\\\begin{bmatrix} 0\\\\\\\\ 1 \\\\end{bmatrix}$, its $\\\\operatorname{MEX}$ is $2$.\\n\\n$\\\\begin{bmatrix} 0\\\\\\\\ 0 \\\\end{bmatrix}$, its $\\\\operatorname{MEX}$ is $1$.\\n\\n$\\\\begin{bmatrix} 0\\\\\\\\ 0 \\\\end{bmatrix}$, its $\\\\operatorname{MEX}$ is $1$.\\n\\nThe sum of $\\\\operatorname{MEX}$ is $8$.\",\n  \"Ground Truth Solution\": \"import sys\\nimport math\\nimport heapq\\nfrom collections import defaultdict as dd\\nfrom collections import OrderedDict as od\\nfrom collections import deque\\nfrom itertools import permutations as pp\\nfrom itertools import combinations as cc\\nfrom sys import stdin\\nfrom functools import cmp_to_key as ctk\\nfrom functools import lru_cache\\nfrom bisect import bisect_left as bs_l\\nfrom bisect import bisect_right as bs_r\\ninput = sys.stdin.readline\\nmod = 10 ** 9 + 7\\nsys.setrecursionlimit(10 ** 5)\\n\\ndef comparator(x, y):\\n\\tif x[0] == y[0]:\\n\\t\\treturn y[1] - x[1]\\n\\treturn True\\n\\ndef ncr(n, r):\\n\\tif n < r:\\n\\t\\treturn 0\\n\\treturn fc[n] * pow(fc[r] * fc[n - r] % mod, mod - 2, mod) % mod\\nT = int(input())\\nfor _ in range(T):\\n\\tn = int(input())\\n\\ts1 = input().strip()\\n\\ts2 = input().strip()\\n\\tans = 0\\n\\t(f0, f1) = (0, 0)\\n\\tfor i in range(n):\\n\\t\\tif s1[i] == '0' and s2[i] == '1' or (s1[i] == '1' and s2[i] == '0'):\\n\\t\\t\\tans += 2\\n\\t\\t\\tif f0:\\n\\t\\t\\t\\tans += f0\\n\\t\\t\\t(f0, f1) = (0, 0)\\n\\t\\telif s1[i] == s2[i] == '0':\\n\\t\\t\\tif f1:\\n\\t\\t\\t\\tans += 2\\n\\t\\t\\t\\t(f0, f1) = (0, 0)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tf0 += 1\\n\\t\\telif f0:\\n\\t\\t\\tans += 2\\n\\t\\t\\tf0 -= 1\\n\\t\\t\\tif f0:\\n\\t\\t\\t\\tans += f0\\n\\t\\t\\t(f0, f1) = (0, 0)\\n\\t\\telse:\\n\\t\\t\\tf1 += 1\\n\\tans += f0\\n\\tprint(ans)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires finding the maximum sum of MEX values by optimally cutting a bi-table (two rows of binary strings) into smaller bi-tables.\\n- Defining MEX: The MEX of a bi-table is the smallest digit (0, 1, or 2) that is not present in the bi-table.\\n- Identifying Optimal Cuts: The goal is to maximize the sum of MEX values for each cut bi-table. This usually involves strategically cutting to create bi-tables with high MEX values.\\n- Considering Edge Cases: Consider cases where the entire bi-table is used as a single bi-table or when cuts result in bi-tables containing only 0s or only 1s.\\n- Developing an Algorithm: Analyze adjacent columns and make cutting decisions based on whether they contain different digits or the same digits. The algorithm needs to accumulate MEX values accordingly.\",\n  \"LLM Questions\": [\n    \"What is the definition of MEX, and how is it calculated for a given bi-table?\",\n    \"How can the optimal cuts be determined to maximize the sum of MEX values?\",\n    \"What are the possible cases when comparing two columns in the bi-table, and how does each case affect the MEX value?\",\n    \"How does the algorithm handle consecutive columns with the same digits, and what is the strategy for cutting them?\",\n    \"What should be the initial state of variables before beginning iteration, and how will the variable be updated while the loop iterates through all possible scenarios.\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"MEX is the smallest non-negative integer that is not present in the bi-table. To calculate it, check for the presence of 0, 1, and 2. The smallest missing number is the MEX.\",\n    \"Optimal cuts are determined by considering the MEX value of each possible bi-table that can be created by cutting. The algorithm should aim to create bi-tables with MEX values as high as possible (ideally 2) or, when unavoidable, bi-tables with MEX values of 1.\",\n    \"The possible cases are:\\n   - Both columns contain different digits (one has 0, the other has 1). In this case, the MEX is 2.\\n   - Both columns contain only 0s. In this case, the MEX is 1.\\n   - Both columns contain only 1s. In this case, the MEX is 0.\",\n    \"Consecutive columns with the same digits need to be handled by potentially combining them into larger bi-tables. Depending on whether there are consecutive 0's or 1's, we can consider merging these columns. Accumulating these until we get to a differing digit, or the end of the bi-table.\",\n    \"Initialize f0 and f1 variables to 0 to track consecutive 0's and 1's. Initialize ans=0. Update these variables while iterating and evaluating the substrings MEX value.\"\n  ]\n}\n```"