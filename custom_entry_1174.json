"```json\n{\n  \"Coding Problem\": \"You are given a set of n points on the plane. A line containing the origin is called good, if projection of the given set to this line forms a symmetric multiset of points. Find the total number of good lines.\\n\\nMultiset is a set where equal elements are allowed.\\n\\nMultiset is called symmetric, if there is a point P on the plane such that the multiset is [centrally symmetric](https://en.wikipedia.org/wiki/Point_reflection) in respect of point P.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 2000) \u2014 the number of points in the set.\\n\\nEach of the next n lines contains two integers xi and yi ( - 106 \u2264 xi, yi \u2264 106) \u2014 the coordinates of the points. It is guaranteed that no two points coincide.\\n\\nOutput\\n\\nIf there are infinitely many good lines, print -1.\\n\\nOtherwise, print single integer \u2014 the number of good lines.\\n\\nExamples\\n\\nInput\\n\\n3\\n1 2\\n2 1\\n3 3\\n\\n\\nOutput\\n\\n3\\n\\n\\nInput\\n\\n2\\n4 3\\n1 2\\n\\n\\nOutput\\n\\n-1\\n\\nNote\\n\\nPicture to the first sample test:\\n\\n<image>\",\n  \"Ground Truth Solution\": \"from fractions import Fraction\\nimport time\\n\\nclass Point:\\n\\n\\tdef __init__(self, x, y):\\n\\t\\tself.x = x\\n\\t\\tself.y = y\\n\\n\\tdef to_tuple(self):\\n\\t\\treturn (self.x, self.y)\\n\\n\\tdef __repr__(self):\\n\\t\\treturn 'Point({}, {})'.format(self.x, self.y)\\n\\n\\tdef __eq__(self, other):\\n\\t\\treturn self.to_tuple() == other.to_tuple()\\n\\n\\tdef __hash__(self):\\n\\t\\treturn hash(self.to_tuple())\\n\\n\\tdef __neg__(self):\\n\\t\\treturn Point(-self.x, -self.y)\\n\\n\\tdef __add__(self, other):\\n\\t\\treturn Point(self.x + other.x, self.y + other.y)\\n\\n\\tdef __sub__(self, other):\\n\\t\\treturn self + -other\\n\\n\\tdef scalar_mul(self, mu):\\n\\t\\treturn Point(mu * self.x, mu * self.y)\\n\\n\\tdef int_divide(self, den):\\n\\t\\treturn Point(self.x // den, self.y // den)\\n\\nclass Line:\\n\\n\\tdef __init__(self, a, b, c):\\n\\t\\tself.a = a\\n\\t\\tself.b = b\\n\\t\\tself.c = c\\n\\n\\tdef __repr__(self):\\n\\t\\treturn '{}*x + {}*y + {} = 0'.format(self.a, self.b, self.c)\\n\\n\\t@classmethod\\n\\tdef between_two_points(cls, P, Q):\\n\\t\\treturn cls(P.y - Q.y, Q.x - P.x, P.x * Q.y - P.y * Q.x)\\n\\n\\tdef evaluate(self, P):\\n\\t\\treturn self.a * P.x + self.b * P.y + self.c\\n\\n\\tdef direction(self):\\n\\t\\tif self.a == 0:\\n\\t\\t\\treturn (0, 1)\\n\\t\\treturn (1, Fraction(self.b, self.a))\\n\\ndef abs_sgn(x):\\n\\tif x == 0:\\n\\t\\treturn (0, 0)\\n\\tif x < 0:\\n\\t\\treturn (-x, -1)\\n\\treturn (x, 1)\\n\\ndef solve(tuple_points):\\n\\tpoints = set()\\n\\tcenter = Point(0, 0)\\n\\tfor cur in tuple_points:\\n\\t\\tcur = Point(*cur).scalar_mul(2 * n)\\n\\t\\tcenter += cur\\n\\t\\tpoints.add(cur)\\n\\tcenter = center.int_divide(n)\\n\\tdcenter = center + center\\n\\tsym_points_set = set()\\n\\tfor p in points:\\n\\t\\tsym_points_set.add(dcenter - p)\\n\\tnosym = list(points - sym_points_set)\\n\\tif len(nosym) == 0:\\n\\t\\tprint(-1)\\n\\t\\texit(0)\\n\\tp0 = nosym[0]\\n\\tgood_lines = set()\\n\\tfor p in nosym:\\n\\t\\tm = (p + p0).int_divide(2)\\n\\t\\tline = Line.between_two_points(m, center)\\n\\t\\tdistances = list(map(line.evaluate, nosym))\\n\\t\\tok = True\\n\\t\\tmydict = {}\\n\\t\\tfor dd in distances:\\n\\t\\t\\t(dda, sgn) = abs_sgn(dd)\\n\\t\\t\\tif dda not in mydict:\\n\\t\\t\\t\\tmydict[dda] = sgn\\n\\t\\t\\telse:\\n\\t\\t\\t\\tmydict[dda] += sgn\\n\\t\\tfor k in mydict:\\n\\t\\t\\tif mydict[k] != 0:\\n\\t\\t\\t\\tok = False\\n\\t\\t\\t\\tbreak\\n\\t\\tif ok:\\n\\t\\t\\tgood_lines.add(line.direction())\\n\\treturn len(good_lines)\\nn = int(input())\\npts = []\\nfor i in range(n):\\n\\trow = input().split(' ')\\n\\tcur = (int(row[0]), int(row[1]))\\n\\tpts.append(cur)\\nprint(solve(pts))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: Recognize that the problem requires finding the number of \\\"good lines\\\" which are lines passing through the origin such that the projection of the given points onto the line forms a symmetric multiset.\\n- Handling Edge Cases: Identify the edge case where any line through the origin is good, which occurs when the set of points is already symmetric about the origin. In this case, output -1.\\n- Algorithmic Strategy: The core idea involves checking for symmetry after projection. This can be determined by ensuring that for each point, there exists another point such that the midpoint lies on the perpendicular line passing through origin.\\n- Implementation details: Consider using fractions to accurately calculate the slopes and avoid floating-point precision issues. Construct a line between mid point of each point and origin with respect to the center and then evaluate the other points by projecting them and checking for symmetry\",\n  \"LLM Questions\": [\n    \"What defines a 'good line' in the context of this problem, and what properties must it satisfy?\",\n    \"How should the edge case where the input points form a symmetric multiset about the origin be handled?\",\n    \"What is the underlying principle that determines whether a set of points forms a symmetric multiset after being projected onto a line through the origin?\",\n    \"In the implementation, how can you accurately compute and represent the slopes of lines to avoid precision issues, especially when dealing with integer coordinates?\",\n    \"How can the concept of projection be used to evaluate whether given lines form a symmetric multiset of points?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A 'good line' is a line that passes through the origin and, when the input points are projected onto it, the resulting multiset is symmetric around some point P on the line.\",\n    \"If the points form a symmetric multiset about the origin, any line through the origin is good and should be handled as an edge case and output -1.\",\n    \"The key is that for any point, there must be another point in the set such that their midpoint lies on the perpendicular bisector of the line passing through origin.\",\n    \"Fractions module from python allows us to define numerator and denominator.\",\n    \"We can define a line and check whether the points equidistant from line are same which gives us a symmetric multiset.\"\n  ]\n}\n```"