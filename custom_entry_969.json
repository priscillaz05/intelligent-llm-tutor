"```json\n{\n  \"Coding Problem\": \"Devu being a small kid, likes to play a lot, but he only likes to play with arrays. While playing he came up with an interesting question which he could not solve, can you please solve it for him?\\n\\nGiven an array consisting of distinct integers. Is it possible to partition the whole array into k disjoint non-empty parts such that p of the parts have even sum (each of them must have even sum) and remaining k - p have odd sum? (note that parts need not to be continuous).\\n\\nIf it is possible to partition the array, also give any possible way of valid partitioning.\\n\\n\\n-----Input-----\\n\\nThe first line will contain three space separated integers n, k, p (1 \u2264 k \u2264 n \u2264 10^5;  0 \u2264 p \u2264 k). The next line will contain n space-separated distinct integers representing the content of array a: a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9).\\n\\n\\n-----Output-----\\n\\nIn the first line print \\\"YES\\\" (without the quotes) if it is possible to partition the array in the required way. Otherwise print \\\"NO\\\" (without the quotes).\\n\\nIf the required partition exists, print k lines after the first line. The i^{th} of them should contain the content of the i^{th} part. Print the content of the part in the line in the following way: firstly print the number of elements of the part, then print all the elements of the part in arbitrary order. There must be exactly p parts with even sum, each of the remaining k - p parts must have odd sum.\\n\\nAs there can be multiple partitions, you are allowed to print any valid partition.\\n\\n\\n-----Examples-----\\nInput\\n5 5 3\\n2 6 10 5 9\\n\\nOutput\\nYES\\n1 9\\n1 5\\n1 10\\n1 6\\n1 2\\n\\nInput\\n5 5 3\\n7 14 2 9 5\\n\\nOutput\\nNO\\n\\nInput\\n5 3 1\\n1 2 3 7 5\\n\\nOutput\\nYES\\n3 5 1 3\\n1 7\\n1 2\",\n  \"Ground Truth Solution\": \"def solve():\\n\\t(n, k, p) = map(int, input().split())\\n\\ta = list(map(int, input().split()))\\n\\teven = list(filter(lambda x: x % 2 == 0, a))\\n\\todd = list(filter(lambda x: x % 2 == 1, a))\\n\\tif (len(odd) - (k - p)) % 2 != 0:\\n\\t\\tprint('NO')\\n\\t\\treturn\\n\\tans = [[] for _ in range(k)]\\n\\tfor i in range(k - p):\\n\\t\\tif odd:\\n\\t\\t\\tans[i].append(odd.pop())\\n\\t\\telse:\\n\\t\\t\\tprint('NO')\\n\\t\\t\\treturn\\n\\tfor i in range(k - p, k):\\n\\t\\tif even:\\n\\t\\t\\tans[i].append(even.pop())\\n\\t\\telif len(odd) >= 2:\\n\\t\\t\\tans[i].append(odd.pop())\\n\\t\\t\\tans[i].append(odd.pop())\\n\\t\\telse:\\n\\t\\t\\tprint('NO')\\n\\t\\t\\treturn\\n\\tans[0] += even\\n\\tans[0] += odd\\n\\tprint('YES')\\n\\tfor part in ans:\\n\\t\\tprint(len(part), ' '.join(map(str, part)))\\nsolve()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The task is to partition an array of distinct integers into k disjoint non-empty parts, where p parts have an even sum and k-p parts have an odd sum. We need to output \\\"YES\\\" if such a partition is possible and provide a valid partition, or \\\"NO\\\" if not possible.\\n- Identifying Constraints and Edge Cases: The array elements are distinct integers. The parts don't need to be continuous.  We need to handle the case where we cannot create the required number of odd or even sum partitions due to the number of odd and even numbers in the input array.\\n- Choosing an Algorithmic Strategy:  We can separate the input array into even and odd numbers. First, try to form the k-p odd sum partitions. If we run out of odd numbers, it's impossible.  Then, try to form the p even sum partitions. If we run out of even numbers, we can try using two odd numbers to create an even sum. If we still can't, it's impossible. Finally, combine the remaining numbers into one of the existing partitions.\\n- Implementation Details: Use lists to store even and odd numbers. Create a list of lists to store the partitions. First fill the odd sum partitions, then the even sum partitions, then combine remaining numbers in the first partition. Consider the case when we need to use two odd numbers to make up one even number.\",\n  \"LLM Questions\": [\n    \"How do you determine if a partition satisfying the given constraints is even possible?\",\n    \"What data structures are most suitable for storing and manipulating the even and odd numbers in the array, and why?\",\n    \"What strategy can you use to construct the partitions to satisfy the even and odd sum constraints?\",\n    \"What are the edge cases to handle in this problem, and how should they be managed to ensure correctness?\",\n    \"How would you verify the correctness of your partitioning, and how could you optimize the implementation for larger inputs?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A partition is possible if and only if the number of odd numbers is sufficient to create k - p odd sum partitions. Specifically, the number of odd numbers must be greater than or equal to k-p, and the difference between the number of odd numbers and k-p must be even to allow combining remaining odd numbers to create even sums if needed.\",\n    \"Lists are suitable for storing even and odd numbers because they allow easy appending and removal of elements. This facilitates the process of creating the partitions. Also using filter() function from python to generate lists of even and odd integers respectively will work perfectly.\",\n    \"First, prioritize forming the k-p partitions that must have an odd sum. Use one odd number for each of these partitions. Then, form the p partitions that must have an even sum. Try to use one even number for each partition. If we run out of even numbers, use two odd numbers for each of these partitions if possible. Finally, if there are remaining numbers (either even or odd), combine them into the first partition.\",\n    \"Edge cases to consider include: 1. Insufficient odd numbers to form k-p odd sum partitions. 2. Insufficient even numbers (and pairs of odd numbers) to form p even sum partitions. 3. Empty input array. These can be managed by returning 'NO' immediately if any of these occur.\",\n    \"To verify correctness, calculate the sum of elements in each partition and check if the number of partitions with even sums is equal to p and the number of partitions with odd sums is equal to k-p. Check also that all numbers from the input are indeed used in the partitions. For optimization, consider the order in which the partitions are formed.\"\n  ]\n}\n```"