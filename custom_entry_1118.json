"```json\n{\n  \"Coding Problem\": \"Uh oh! Ray lost his array yet again! However, Omkar might be able to help because he thinks he has found the OmkArray of Ray's array. The OmkArray of an array a with elements a_1, a_2, \u2026, a_{2k-1}, is the array b with elements b_1, b_2, \u2026, b_{k} such that b_i is equal to the median of a_1, a_2, \u2026, a_{2i-1} for all i. Omkar has found an array b of size n (1 \u2264 n \u2264 2 \u22c5 10^5, -10^9 \u2264 b_i \u2264 10^9). Given this array b, Ray wants to test Omkar's claim and see if b actually is an OmkArray of some array a. Can you help Ray?\\n\\nThe median of a set of numbers a_1, a_2, \u2026, a_{2i-1} is the number c_{i} where c_{1}, c_{2}, \u2026, c_{2i-1} represents a_1, a_2, \u2026, a_{2i-1} sorted in nondecreasing order. \\n\\nInput\\n\\nEach test contains multiple test cases. The first line contains a single integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains an integer n (1 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the length of the array b.\\n\\nThe second line contains n integers b_1, b_2, \u2026, b_n (-10^9 \u2264 b_i \u2264 10^9) \u2014 the elements of b.\\n\\nIt is guaranteed the sum of n across all test cases does not exceed 2 \u22c5 10^5. \\n\\nOutput\\n\\nFor each test case, output one line containing YES if there exists an array a such that b_i is the median of a_1, a_2, ..., a_{2i-1} for all i, and NO otherwise. The case of letters in YES and NO do not matter (so yEs and No will also be accepted).\\n\\nExamples\\n\\nInput\\n\\n\\n5\\n4\\n6 2 1 3\\n1\\n4\\n5\\n4 -8 5 6 -7\\n2\\n3 3\\n4\\n2 1 2 3\\n\\n\\nOutput\\n\\n\\nNO\\nYES\\nNO\\nYES\\nYES\\n\\n\\nInput\\n\\n\\n5\\n8\\n-8 2 -6 -5 -4 3 3 2\\n7\\n1 1 3 1 0 -2 -1\\n7\\n6 12 8 6 2 6 10\\n6\\n5 1 2 3 6 7\\n5\\n1 3 4 3 0\\n\\n\\nOutput\\n\\n\\nNO\\nYES\\nNO\\nNO\\nNO\\n\\nNote\\n\\nIn the second case of the first sample, the array [4] will generate an OmkArray of [4], as the median of the first element is 4.\\n\\nIn the fourth case of the first sample, the array [3, 2, 5] will generate an OmkArray of [3, 3], as the median of 3 is 3 and the median of 2, 3, 5 is 3.\\n\\nIn the fifth case of the first sample, the array [2, 1, 0, 3, 4, 4, 3] will generate an OmkArray of [2, 1, 2, 3] as \\n\\n  * the median of 2 is 2 \\n  * the median of 0, 1, 2 is 1 \\n  * the median of 0, 1, 2, 3, 4 is 2 \\n  * and the median of 0, 1, 2, 3, 3, 4, 4 is 3. \\n\\n\\n\\nIn the second case of the second sample, the array [1, 0, 4, 3, 5, -2, -2, -2, -4, -3, -4, -1, 5] will generate an OmkArray of [1, 1, 3, 1, 0, -2, -1], as \\n\\n  * the median of 1 is 1 \\n  * the median of 0, 1, 4 is 1 \\n  * the median of 0, 1, 3, 4, 5 is 3 \\n  * the median of -2, -2, 0, 1, 3, 4, 5 is 1 \\n  * the median of -4, -2, -2, -2, 0, 1, 3, 4, 5 is 0 \\n  * the median of -4, -4, -3, -2, -2, -2, 0, 1, 3, 4, 5 is -2 \\n  * and the median of -4, -4, -3, -2, -2, -2, -1, 0, 1, 3, 4, 5, 5 is -1 \\n\\n\\n\\nFor all cases where the answer is NO, it can be proven that it is impossible to find an array a such that b is the OmkArray of a.\",\n  \"Ground Truth Solution\": \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nfrom heapq import heappush, heappop\\nimport math\\nfrom collections import *\\nfrom functools import reduce, cmp_to_key, lru_cache\\nimport io, os\\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nM = mod = 10 ** 9 + 7\\n\\ndef factors(n):\\n\\treturn sorted(set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0))))\\n\\ndef inv_mod(n):\\n\\treturn pow(n, mod - 2, mod)\\n\\ndef li():\\n\\treturn [int(i) for i in input().rstrip().split()]\\n\\ndef st():\\n\\treturn str(input().rstrip())[2:-1]\\n\\ndef val():\\n\\treturn int(input().rstrip())\\n\\ndef li2():\\n\\treturn [str(i)[2:-1] for i in input().rstrip().split()]\\n\\ndef li3():\\n\\treturn [int(i) for i in st()]\\n\\nclass Bitree:\\n\\n\\tdef __init__(self):\\n\\t\\tself.bitree = []\\n\\n\\tdef getsum(self, i):\\n\\t\\ts = 0\\n\\t\\ti += 1\\n\\t\\twhile i > 0:\\n\\t\\t\\ts += self.bitree[i]\\n\\t\\t\\ti -= i & -i\\n\\t\\treturn s\\n\\n\\tdef sum(self, a, b):\\n\\t\\treturn self.getsum(b) - self.getsum(a - 1) if a else self.getsum(b)\\n\\n\\tdef update(self, i, v):\\n\\t\\ti += 1\\n\\t\\twhile i < len(self.bitree):\\n\\t\\t\\tself.bitree[i] += v\\n\\t\\t\\ti += i & -i\\n\\n\\tdef build(self, arr):\\n\\t\\tn = len(arr)\\n\\t\\tself.bitree = [0] * (n + 1)\\n\\t\\tfor i in range(n):\\n\\t\\t\\tself.update(i, arr[i])\\n\\ndef compress(l):\\n\\tindex = defaultdict(list)\\n\\tfor i in range(len(l)):\\n\\t\\tindex[l[i]].append(i)\\n\\tind = 5\\n\\tfor i in sorted(list(index)):\\n\\t\\tfor j in index[i]:\\n\\t\\t\\tl[j] = ind\\n\\t\\tind += 1\\n\\treturn l[:]\\nfor _ in range(val()):\\n\\tn = val()\\n\\tl = compress(li())\\n\\tfen = Bitree()\\n\\tfen.build([0] * (n + 50))\\n\\tfen.update(l[0], l[0])\\n\\tans = 1\\n\\tfor i in range(1, n):\\n\\t\\tprevious = l[i - 1]\\n\\t\\tcurr = l[i]\\n\\t\\tif previous > l[i]:\\n\\t\\t\\ttot = fen.sum(l[i] + 1, previous - 1)\\n\\t\\t\\tif tot:\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\t\\tbreak\\n\\t\\tif previous < l[i]:\\n\\t\\t\\ttot = fen.sum(previous + 1, l[i] - 1)\\n\\t\\t\\tif tot:\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\t\\tbreak\\n\\t\\tfen.update(curr, curr)\\n\\tprint('YES' if ans else 'NO')\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem defines an 'OmkArray' b derived from an array a, where each element b_i is the median of the first 2i-1 elements of a. The task is to determine if a given array b can be an OmkArray of some array a.\\n- Identifying Key Properties and Constraints:  The median calculation is crucial. The constraint on the array size is n <= 2 * 10^5, which suggests efficient algorithms. The values of the array elements are between -10^9 and 10^9.\\n- Choosing an Algorithmic Strategy: The provided solution uses a Fenwick tree (Binary Indexed Tree) after compressing the input array. The core idea is to check, for each pair of consecutive elements in b, whether any other previously seen medians fall between them. If such elements exist, then 'b' cannot be a valid OmkArray. The compression is done to allow efficient indexing and querying of the Fenwick tree.\\n- Implementation Details:  The compression function maps the input numbers to a smaller range of integers while preserving order. The Fenwick tree is used to keep track of the median values seen so far.  For each i, it checks if there are any previously seen medians between b[i-1] and b[i].\",\n  \"LLM Questions\": [\n    \"What is an OmkArray, and what properties must an array 'b' satisfy to be a valid OmkArray?\",\n    \"Why is compression used on the input array 'b', and how does this compression work?\",\n    \"How does the Fenwick tree contribute to determining whether an array 'b' can be a valid OmkArray?\",\n    \"Explain the logic behind checking the interval between consecutive elements b[i-1] and b[i] using the Fenwick tree. What does a non-zero sum in that interval indicate?\",\n    \"What are the time and space complexities of this solution, and why are they important given the problem constraints?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"An OmkArray 'b' of an array 'a' is derived such that each element b_i is the median of the first 2i-1 elements of 'a'. A valid OmkArray 'b' must be constructible from some 'a' based on this median definition.\",\n    \"Compression is used to reduce the range of values in the input array while preserving relative order. It is done to efficiently use a Fenwick tree for indexing. The compression maps unique elements to consecutive indices, reducing the memory footprint and query time.\",\n    \"The Fenwick tree stores the presence of previously seen median values. It allows for efficient range sum queries to determine if any previously seen medians lie between two consecutive medians in the OmkArray.\",\n    \"The solution checks if there are any previously seen median values between b[i-1] and b[i]. If the Fenwick tree's sum in that range is non-zero, it means there's a previously seen median between those two values. This contradicts the properties of OmkArray, so the answer is 'NO'.\",\n    \"The time complexity is dominated by sorting during compression which is O(n log n) and the n updates and queries on the fenwick tree which are each O(log n). Thus giving an overall time complexity of O(n log n). Space complexity is dominated by storing the compressed array and the fenwick tree, each of size O(n). Therefore, the space complexity is O(n). These complexities are sufficient given the problem's constraints, which involve handling arrays of up to 2 * 10^5 elements.\"\n  ]\n}\n```"