"```json\n{\n  \"Coding Problem\": \"Two integer sequences existed initially, one of them was strictly increasing, and another one \u2014 strictly decreasing.\\n\\nStrictly increasing sequence is a sequence of integers $[x_1 < x_2 < \\\\dots < x_k]$. And strictly decreasing sequence is a sequence of integers $[y_1 > y_2 > \\\\dots > y_l]$. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.\\n\\nElements of increasing sequence were inserted between elements of the decreasing one (and, possibly, before its first element and after its last element) without changing the order. For example, sequences $[1, 3, 4]$ and $[10, 4, 2]$ can produce the following resulting sequences: $[10, \\\\textbf{1}, \\\\textbf{3}, 4, 2, \\\\textbf{4}]$, $[\\\\textbf{1}, \\\\textbf{3}, \\\\textbf{4}, 10, 4, 2]$. The following sequence cannot be the result of these insertions: $[\\\\textbf{1}, 10, \\\\textbf{4}, 4, \\\\textbf{3}, 2]$ because the order of elements in the increasing sequence was changed.\\n\\nLet the obtained sequence be $a$. This sequence $a$ is given in the input. Your task is to find any two suitable initial sequences. One of them should be strictly increasing, and another one \u2014 strictly decreasing. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.\\n\\nIf there is a contradiction in the input and it is impossible to split the given sequence $a$ into one increasing sequence and one decreasing sequence, print \\\"NO\\\".\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains one integer $n$ ($1 \\\\le n \\\\le 2 \\\\cdot 10^5$) \u2014 the number of elements in $a$.\\n\\nThe second line of the input contains $n$ integers $a_1, a_2, \\\\dots, a_n$ ($0 \\\\le a_i \\\\le 2 \\\\cdot 10^5$), where $a_i$ is the $i$-th element of $a$.\\n\\n\\n-----Output-----\\n\\nIf there is a contradiction in the input and it is impossible to split the given sequence $a$ into one increasing sequence and one decreasing sequence, print \\\"NO\\\" in the first line.\\n\\nOtherwise print \\\"YES\\\" in the first line. In the second line, print a sequence of $n$ integers $res_1, res_2, \\\\dots, res_n$, where $res_i$ should be either $0$ or $1$ for each $i$ from $1$ to $n$. The $i$-th element of this sequence should be $0$ if the $i$-th element of $a$ belongs to the increasing sequence, and $1$ otherwise. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.\\n\\n\\n-----Examples-----\\nInput\\n9\\n5 1 3 6 8 2 9 0 10\\n\\nOutput\\nYES\\n1 0 0 0 0 1 0 1 0 \\n\\nInput\\n5\\n1 2 4 0 2\\n\\nOutput\\nNO\",\n  \"Ground Truth Solution\": \"MAX = 1 + 2 * 10 ** 5\\nMIN = -1\\nASC = 0\\nDSC = 1\\nn = int(input())\\na = list(map(int, input().split()))\\nasc = MIN\\ndsc = MAX\\nres = []\\nfor i in range(n):\\n\\tif a[i] > asc and a[i] < dsc:\\n\\t\\tif i + 1 == n:\\n\\t\\t\\tres.append(DSC)\\n\\t\\telif a[i] > a[i + 1]:\\n\\t\\t\\tres.append(DSC)\\n\\t\\t\\tdsc = a[i]\\n\\t\\telse:\\n\\t\\t\\tres.append(ASC)\\n\\t\\t\\tasc = a[i]\\n\\telif a[i] > asc:\\n\\t\\tres.append(ASC)\\n\\t\\tasc = a[i]\\n\\telif a[i] < dsc:\\n\\t\\tres.append(DSC)\\n\\t\\tdsc = a[i]\\n\\telse:\\n\\t\\tprint('NO')\\n\\t\\treturn\\nprint('YES')\\nprint(*res)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires splitting a given sequence into two subsequences: one strictly increasing and one strictly decreasing. The elements of the increasing subsequence must have been inserted into the decreasing subsequence without changing the order within each subsequence.\\n- Defining Constraints and Edge Cases: The increasing sequence must have elements such that $x_1 < x_2 < ... < x_k$, and the decreasing sequence must satisfy $y_1 > y_2 > ... > y_l$. Empty sequences or sequences with one element are valid. If the given sequence cannot be split into such subsequences, output \\\"NO\\\".\\n- Developing an Algorithm: Iterate through the input sequence. At each element, determine whether it can belong to either the increasing or decreasing subsequence. Keep track of the last elements of both subsequences. If an element can belong to both subsequences, prioritize assigning it to the decreasing subsequence if the next element in the input is smaller, or increasing if the next element is bigger. If an element can't be assigned to either subsequence (i.e., it's smaller than the last increasing element and larger than the last decreasing element), then it's impossible to split the sequence, and the answer is \\\"NO\\\".\\n- Handling Ambiguity: If an element can belong to both increasing and decreasing subsequences, a decision needs to be made. If it's the last element, assign it to the decreasing subsequence by default. Otherwise, look at the next element. If the next element is smaller, assign the current element to the decreasing sequence; otherwise, assign it to the increasing sequence. This helps to avoid blocking assignment to either subsequence.\\n- Implementation Details: Use two variables to store the last element of the increasing and decreasing subsequences. Iterate through the array, assigning each element to one of the subsequences and updating the variables. Store the assignments in a result array.\",\n  \"LLM Questions\": [\n    \"How would you keep track of the last elements of the increasing and decreasing sequences to make the decisions when splitting the sequence?\",\n    \"In the case of ambiguity, how would you decide whether to assign an element to either the increasing or decreasing subsequence?\",\n    \"What are the possible edge cases for the strictly increasing and decreasing subsequences?\",\n    \"How will you handle the condition when an element is larger than the last element in the increasing sequence and smaller than the last element in the decreasing sequence, indicating that the array cannot be split?\",\n    \"How can the algorithm be optimized to efficiently determine the split between the increasing and decreasing subsequences, especially considering large input sizes (up to 2 * 10^5)?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Use two variables: one to store the last element of the increasing subsequence and another for the last element of the decreasing subsequence. Initialize these variables to track the minimum and maximum possible value, respectively. Update these variables as new elements are assigned to each subsequence.\",\n    \"When an element can belong to either subsequence, inspect the subsequent element in the input sequence. If the next element is smaller, assign the current element to the decreasing subsequence; otherwise, assign it to the increasing subsequence. If the current element is the last element in the sequence, assign it to the decreasing sequence by default.\",\n    \"Edge cases include empty sequences and single-element sequences, both of which are valid increasing or decreasing sequences. Also, an important case is when the sequence cannot be split because an element violates the order in both increasing and decreasing subsequences.\",\n    \"If an element is larger than the last element in the increasing sequence and smaller than the last element in the decreasing sequence, it means that this element cannot be assigned to either subsequence without violating the increasing or decreasing property. In this case, output 'NO' because the sequence cannot be split.\",\n    \"The algorithm can be optimized by efficiently managing the increasing and decreasing subsequence tracking variables and by applying decision-making logic that prevents unnecessary computations. For large input sizes, it's also important to use efficient data structures to store the result array without introducing extra overhead.\"\n  ]\n}\n```"