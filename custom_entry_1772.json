"```json\n{\n  \"Coding Problem\": \"Gerald plays the following game. He has a checkered field of size n \u00d7 n cells, where m various cells are banned. Before the game, he has to put a few chips on some border (but not corner) board cells. Then for n - 1 minutes, Gerald every minute moves each chip into an adjacent cell. He moves each chip from its original edge to the opposite edge. Gerald loses in this game in each of the three cases:\\n\\n  * At least one of the chips at least once fell to the banned cell. \\n  * At least once two chips were on the same cell. \\n  * At least once two chips swapped in a minute (for example, if you stand two chips on two opposite border cells of a row with even length, this situation happens in the middle of the row). \\n\\n\\nIn that case he loses and earns 0 points. When nothing like that happened, he wins and earns the number of points equal to the number of chips he managed to put on the board. Help Gerald earn the most points.\\n\\nInput\\n\\nThe first line contains two space-separated integers n and m (2 \u2264 n \u2264 1000, 0 \u2264 m \u2264 105) \u2014 the size of the field and the number of banned cells. Next m lines each contain two space-separated integers. Specifically, the i-th of these lines contains numbers xi and yi (1 \u2264 xi, yi \u2264 n) \u2014 the coordinates of the i-th banned cell. All given cells are distinct.\\n\\nConsider the field rows numbered from top to bottom from 1 to n, and the columns \u2014 from left to right from 1 to n.\\n\\nOutput\\n\\nPrint a single integer \u2014 the maximum points Gerald can earn in this game.\\n\",\n  \"Ground Truth Solution\": \"import os\\nimport sys\\nfrom math import *\\nfrom collections import *\\nfrom bisect import *\\nfrom io import BytesIO, IOBase\\n\\ndef vsInput():\\n\\tsys.stdin = open('input.txt', 'r')\\n\\tsys.stdout = open('output.txt', 'w')\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nALPHA = 'abcdefghijklmnopqrstuvwxyz/'\\nM = 1000000007\\nEPS = 1e-06\\n\\ndef Ceil(a, b):\\n\\treturn a // b + int(a % b > 0)\\n\\ndef value():\\n\\treturn tuple(map(int, input().split()))\\n\\ndef array():\\n\\treturn [int(i) for i in input().split()]\\n\\ndef Int():\\n\\treturn int(input())\\n\\ndef Str():\\n\\treturn input()\\n\\ndef arrayS():\\n\\treturn [i for i in input().split()]\\n(n, m) = value()\\nrow_blocked = defaultdict(bool)\\ncol_blocked = defaultdict(bool)\\nfor i in range(m):\\n\\t(x, y) = value()\\n\\trow_blocked[x] = True\\n\\tcol_blocked[y] = True\\nans = 0\\nfor i in range(2, n):\\n\\tif not row_blocked[i]:\\n\\t\\tans += 1\\n\\tif not col_blocked[i]:\\n\\t\\tans += 1\\nif n % 2:\\n\\tif not row_blocked[n // 2 + 1] and (not col_blocked[n // 2 + 1]):\\n\\t\\tans -= 1\\nprint(ans)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks to maximize the number of chips placed on the border cells (excluding corners) of an n x n grid such that no chip ever lands on a banned cell, two chips are never on the same cell at any time step, and chips don't swap positions.\\n- Identifying Constraints: The key constraints are banned cells, no simultaneous occupation of cells by different chips, and no chips swapping positions during the movement.\\n- Simplifying Assumptions:  Since chips move from one edge to the opposite edge in n-1 steps, the 'swapping' condition essentially means we cannot place chips on directly opposing border cells (i.e., (1, x) and (n, x), or (x, 1) and (x, n)) unless n is odd and we are placing the chip at center most border locations. The banned cell condition blocks some cells.\\n- Selecting the Optimal Strategy: Count the number of valid cells on each border segment excluding the corners.  A valid cell is a border cell (not a corner) that is not banned. Additionally, if n is even we cannot place chips on opposing border cells to prevent chip swapping. This implies we can have at most one chip per row/column (excluding corners). If n is odd we can place two chips on opposing sides of the board if they're not banned and in the middle of the respective sides of the board.  Since we aim to maximize the number of chips, count the number of non-corner border cells that are not banned, subtracting overlapping corner cases if required.\\n- Optimizing for Edge Cases: Consider the case where n is even vs. odd. When n is odd, the middle row/column may allow two chips to be placed simultaneously.\\n\",\n  \"LLM Questions\": [\n    \"What are the specific conditions that cause Gerald to lose the game?\",\n    \"How do banned cells affect the placement of chips?\",\n    \"What does the condition about chips swapping positions imply about chip placement?\",\n    \"How does the parity of 'n' affect the strategy of chip placement?\",\n    \"What is the formula to find the middle element (row/col) of an n x n grid if n is odd?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Gerald loses if a chip lands on a banned cell, if two chips occupy the same cell at any time, or if two chips swap positions during their movement.\",\n    \"Banned cells cannot be used to place a chip. We have to make sure chips never land on banned cells.\",\n    \"This means that you cannot place chips on opposite sides of the board (same column/row) such that they will swap locations when moving.\",\n    \"If n is even you can only place one chip per row/column (excluding corners). If n is odd you can place two chips on the middle row and/or middle column if the middle position is not blocked.\",\n    \"The middle element is (n // 2) + 1. For example, if n is 5, the middle element is (5 // 2) + 1 = 2 + 1 = 3.\"\n  ]\n}\n```"