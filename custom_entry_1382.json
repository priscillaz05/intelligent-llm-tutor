"```json\n{\n  \"Coding Problem\": \"Read problems statements in Mandarin Chinese  and Russian. \\n\\nRoma gave Chef an array of intergers.\\n\\nChef wants to make all integers in the array equal to 1.\\n\\nIn a single operation, he can select a prime number p and a subset of the integers, and then divide all of the integers in the subset by p.\\n\\nChef can make this operation only if every integer in the selected subset is divisible by p.\\n\\nPlease help Chef to make all the integers in the array equal to 1 with minimum number of operations.\\n\\n------ Input ------ \\n\\nThe first line of input contains a single integer T denoting the number of test cases. The description of T test cases follows.\\nThe first line of each test case contains a single integer N denoting the length of the array that Roma gave Chef.\\nThe second line contains N space-separated integers A_{1}, A_{2}, ..., A_{N} denoting the integers in the array.\\n\\n------ Output ------ \\n\\nFor each test case, output a single line containing one integer - the minimum number of operations needed to make all numbers equal to 1.\\n\\n------ Constraints ------ \\n\\n$Subtask 1 (10 points): T = 5, 1 \u2264 N \u2264 10^{5}, 1 \u2264 A_{i} \u2264 3$\\n$Subtask 2 (40 points): T = 3, 1 \u2264 N \u2264 10, 1 \u2264 A_{i} \u2264 10^{6}$\\n$Subtask 3 (50 points): T = 3, 1 \u2264 N \u2264 10^{5}, 1 \u2264 A_{i} \u2264 10^{6}$\\n\\n----- Sample Input 1 ------ \\n1\\n3\\n1 2 4\\n----- Sample Output 1 ------ \\n2\",\n  \"Ground Truth Solution\": \"from collections import defaultdict\\nfrom sys import *\\n\\ndef input():\\n\\treturn stdin.readline()\\na = [True] * 1000100\\n\\ndef primes_sieve2(limit):\\n\\ta[0] = a[1] = False\\n\\tl = []\\n\\tfor (i, isprime) in enumerate(a):\\n\\t\\tif isprime:\\n\\t\\t\\tl.append(i)\\n\\t\\t\\tfor n in range(i * i, limit, i):\\n\\t\\t\\t\\ta[n] = False\\n\\treturn l\\nprime = primes_sieve2(1000100)\\nfac = [[] for i in range(1000100)]\\nfor i in prime:\\n\\tfor j in range(i, 1000100, i):\\n\\t\\tfac[j].append(i)\\n\\ndef get(divisors):\\n\\tdiv = fac[divisors]\\n\\tnew = defaultdict(int)\\n\\ttar = divisors\\n\\tind = 0\\n\\twhile tar > 1:\\n\\t\\tfir = div[ind]\\n\\t\\twhile tar > 1 and tar % fir == 0:\\n\\t\\t\\ttar //= fir\\n\\t\\t\\tnew[fir] += 1\\n\\t\\tind += 1\\n\\treturn new\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\tlis = [int(i) for i in input().split()]\\n\\tvis = defaultdict(list)\\n\\tit = 0\\n\\tfor i in lis:\\n\\t\\tfor (i, j) in get(i).items():\\n\\t\\t\\tvis[i].append(j)\\n\\tfor j in vis.values():\\n\\t\\tit += max(j)\\n\\tprint(it)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks for the minimum number of operations to make all elements in an array equal to 1. An operation involves selecting a prime number and a subset of integers divisible by that prime, and then dividing those integers by the prime.\\n- Identifying Key Constraints: The main constraint is that you can only divide a subset of numbers by a prime p if every number in that subset is divisible by p. The goal is to minimize the number of such operations.\\n- Devising a Strategy: To minimize operations, the core idea is to count the maximum power of each prime factor across all the numbers. The number of operations needed will be the sum of the highest power of each prime factor present in any of the numbers. If we calculate the prime factorization of each number in the array, for each unique prime factor we find, the number of operations equals the largest power of that prime that divides any of the numbers. This ensures that all instances of each prime will be removed using the minimum amount of operations\\n- Example Walkthrough: consider the input [1, 2, 4]. 1 needs no operations. 2 needs one operation (divide by 2). 4 needs two operations (divide by 2 twice). In prime factor form these are [1, 2^1, 2^2]. The highest power of 2 is 2, thus we need 2 operations. Thus the solution should return 2.\\n\",\n  \"LLM Questions\": [\n    \"What are the key properties of prime numbers that are relevant to solving this problem?\",\n    \"How can you determine the minimum number of operations for a given array of integers?\",\n    \"How do you handle cases where the same prime number appears with different powers in different integers in the array?\",\n    \"How can you optimize the prime factorization process to handle the given constraints, especially with larger numbers?\",\n    \"How does the constraint of only dividing by a prime if all numbers in a subset are divisible by it affect the overall solution strategy?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Prime numbers are fundamental because they are the smallest factors by which composite numbers can be reduced. Operations must be performed using primes, implying that the frequency and power of these primes directly determine the number of needed operations.\",\n    \"For each prime factor, you need to determine the maximum power to which it appears in any number within the array. The sum of these maximum powers for each prime provides the minimum number of operations.\",\n    \"You need to track the highest power of each prime that appears in any of the numbers. Once you've accounted for the largest power, you've effectively covered all smaller powers, so just the maximum counts towards the solution.\",\n    \"Precompute a list of primes or use a sieve method to determine primes up to the maximum possible value of the integers in the array. Use this to efficiently perform prime factorization for each number. Use memoization to store already computed prime factors to avoid redundancy.\",\n    \"This constraint implies that the prime factors must be considered for each number individually. We are essentially trying to reduce each number to 1, where we count the maximum frequency of any prime factor that exists in the input array.\"\n  ]\n}\n```"