"```json\n{\n  \"Coding Problem\": \"Yurii is sure he can do everything. Can he solve this task, though?\\n\\nHe has an array $a$ consisting of $n$ positive integers. Let's call a subarray $a[l...r]$ good if the following conditions are simultaneously satisfied:   $l+1 \\\\leq r-1$, i.\u00a0e. the subarray has length at least $3$;  $(a_l \\\\oplus a_r) = (a_{l+1}+a_{l+2}+\\\\ldots+a_{r-2}+a_{r-1})$, where $\\\\oplus$ denotes the bitwise XOR operation. \\n\\nIn other words, a subarray is good if the bitwise XOR of the two border elements is equal to the sum of the rest of the elements. \\n\\nYurii wants to calculate the total number of good subarrays. What is it equal to?\\n\\nAn array $c$ is a subarray of an array $d$ if $c$ can be obtained from $d$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $n$ ($3 \\\\leq n \\\\leq 2\\\\cdot 10^5$)\u00a0\u2014 the length of $a$. \\n\\nThe second line contains $n$ integers $a_1,a_2,\\\\ldots,a_n$ ($1 \\\\leq a_i < 2^{30}$)\u00a0\u2014 elements of $a$. \\n\\n\\n-----Output-----\\n\\nOutput a single integer\u00a0\u2014 the number of good subarrays. \\n\\n\\n-----Examples-----\\nInput\\n8\\n3 1 2 3 1 2 3 15\\n\\nOutput\\n6\\nInput\\n10\\n997230370 58052053 240970544 715275815 250707702 156801523 44100666 64791577 43523002 480196854\\n\\nOutput\\n2\\n\\n\\n-----Note-----\\n\\nThere are $6$ good subarrays in the example:   $[3,1,2]$ (twice) because $(3 \\\\oplus 2) = 1$;  $[1,2,3]$ (twice) because $(1 \\\\oplus 3) = 2$;  $[2,3,1]$ because $(2 \\\\oplus 1) = 3$;  $[3,1,2,3,1,2,3,15]$ because $(3 \\\\oplus 15) = (1+2+3+1+2+3)$.\",\n  \"Ground Truth Solution\": \"def solve(a):\\n\\tseen = set()\\n\\tfor i in range(len(a)):\\n\\t\\tc = 0\\n\\t\\tfor j in range(i + 2, len(a)):\\n\\t\\t\\tc += a[j - 1]\\n\\t\\t\\tif a[i] ^ a[j] == c:\\n\\t\\t\\t\\tseen.add((i, j))\\n\\t\\t\\tif c >= 2 * a[i]:\\n\\t\\t\\t\\tbreak\\n\\tfor i in range(len(a) - 1, -1, -1):\\n\\t\\tc = 0\\n\\t\\tfor j in range(i - 2, -1, -1):\\n\\t\\t\\tc += a[j + 1]\\n\\t\\t\\tif a[i] ^ a[j] == c:\\n\\t\\t\\t\\tseen.add((j, i))\\n\\t\\t\\tif c >= 2 * a[i]:\\n\\t\\t\\t\\tbreak\\n\\tprint(len(seen))\\nn = int(input())\\nsolve(list(map(int, input().split())))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Problem Requirements: The goal is to identify and count \\\"good\\\" subarrays within a given array. A subarray is \\\"good\\\" if it has at least 3 elements and satisfies the condition that the XOR of the first and last elements equals the sum of the remaining elements in the subarray.\\n- Identifying Potential Pitfalls: The problem involves nested loops, so efficiency is a concern. The XOR operation and sum calculation need to be handled carefully to avoid overflow or incorrect results. The condition `l+1 <= r-1` which means `r-l >= 2` must be handled properly in the loop conditions.\\n- Selecting Algorithmic Strategy: Iterate through all possible subarrays, check if each subarray has at least 3 elements, and then verify if the XOR and summation condition is met. Optimizations can be considered, such as breaking the inner loop if the sum becomes too large compared to the potential XOR result.\\n- Implementation Considerations: The code needs to efficiently calculate the XOR and sum for each subarray. It must also avoid double-counting the \\\"good\\\" subarrays. A set can be used to store the indices of the \\\"good\\\" subarrays to avoid duplicates.\",\n  \"LLM Questions\": [\n    \"What is the definition of a \\\"good\\\" subarray, and what constraints must it satisfy?\",\n    \"What is the most straightforward approach to solve this problem, and what are its potential time complexity issues?\",\n    \"How can the calculation of the sum of subarray elements be optimized to improve efficiency?\",\n    \"How can we prevent double-counting of \\\"good\\\" subarrays, and why is this important for the correctness of the solution?\",\n    \"What are the potential edge cases or input characteristics that could significantly affect the performance of the algorithm, and how can we handle them?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A \\\"good\\\" subarray must have at least 3 elements, and the XOR of its first and last elements must equal the sum of the elements in between (excluding the first and last).\",\n    \"The most straightforward approach is to iterate through all possible subarrays and check each one. However, this has a time complexity of O(n^3) or O(n^2) (if you do prefix sums), which could be too slow for large arrays.\",\n    \"Instead of recomputing the sum for each subarray, you can calculate a prefix sum array. Then, the sum of elements in a subarray can be computed in O(1) time by subtracting prefix sums.\",\n    \"To prevent double-counting, you can store the starting and ending indices of the \\\"good\\\" subarrays in a set. This ensures that each unique \\\"good\\\" subarray is counted only once.\",\n    \"Large input arrays can lead to performance issues. Also, if the array elements have large values, the sum can become large quickly, which might help in short-circuiting the inner loops and reducing computation. The code in the ground truth breaks the inner loops to avoid calculating useless entries.\"\n  ]\n}\n```"