"```json\n{\n  \"Coding Problem\": \"It's Petya's birthday party and his friends have presented him a brand new \\\"Electrician-n\\\" construction set, which they are sure he will enjoy as he always does with weird puzzles they give him.\\n\\nConstruction set \\\"Electrician-n\\\" consists of 2n - 1 wires and 2n light bulbs. Each bulb has its own unique index that is an integer from 1 to 2n, while all wires look the same and are indistinguishable. In order to complete this construction set one has to use each of the wires to connect two distinct bulbs. We define a chain in a completed construction set as a sequence of distinct bulbs of length at least two, such that every two consecutive bulbs in this sequence are directly connected by a wire. Completed construction set configuration is said to be correct if a resulting network of bulbs and wires has a tree structure, i.e. any two distinct bulbs are the endpoints of some chain.\\n\\nPetya was assembling different configurations for several days, and he noticed that sometimes some of the bulbs turn on. After a series of experiments he came up with a conclusion that bulbs indexed 2i and 2i - 1 turn on if the chain connecting them consists of exactly d_i wires. Moreover, the following important condition holds: the value of d_i is never greater than n.\\n\\nPetya did his best but was not able to find a configuration that makes all bulbs to turn on, so he seeks your assistance. Please, find out a configuration that makes all bulbs shine. It is guaranteed that such configuration always exists.\\n\\nInput\\n\\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000) \u2014 the parameter of a construction set that defines the number of bulbs and the number of wires.\\n\\nNext line contains n integers d_1, d_2, \u2026, d_n (1 \u2264 d_i \u2264 n), where d_i stands for the number of wires the chain between bulbs 2i and 2i - 1 should consist of.\\n\\nOutput\\n\\nPrint 2n - 1 lines. The i-th of them should contain two distinct integers a_i and b_i (1 \u2264 a_i, b_i \u2264 2n, a_i \u2260 b_i) \u2014 indices of bulbs connected by a wire.\\n\\nIf there are several possible valid answer you can print any of them.\\n\\nExamples\\n\\nInput\\n\\n\\n3\\n2 2 2\\n\\n\\nOutput\\n\\n\\n1 6\\n2 6\\n3 5\\n3 6\\n4 5\\n\\n\\nInput\\n\\n\\n4\\n2 2 2 1\\n\\n\\nOutput\\n\\n\\n1 6\\n1 7\\n2 6\\n3 5\\n3 6\\n4 5\\n7 8\\n\\n\\nInput\\n\\n\\n6\\n2 2 2 2 2 2\\n\\n\\nOutput\\n\\n\\n1 3\\n2 3\\n3 5\\n4 5\\n5 7\\n6 7\\n7 12\\n8 12\\n9 11\\n9 12\\n10 11\\n\\n\\nInput\\n\\n\\n2\\n1 1\\n\\n\\nOutput\\n\\n\\n1 2\\n1 4\\n3 4\\n\\nNote\\n\\n<image> Answer for the first sample test.  <image> Answer for the second sample test.\",\n  \"Ground Truth Solution\": \"n = int(input())\\nd = map(int, input().split())\\nd = [[2 * i + 1, di] for (i, di) in enumerate(d)]\\nd = sorted(d, key=lambda x: x[1], reverse=True)\\nedge = []\\narr = [x[0] for x in d]\\nfor (i, [x, d_]) in enumerate(d):\\n\\tif i + d_ - 1 == len(arr) - 1:\\n\\t\\tarr.append(x + 1)\\n\\tedge.append([arr[i + d_ - 1], x + 1])\\nfor (u, v) in zip(d[:-1], d[1:]):\\n\\tedge.append([u[0], v[0]])\\nans = '\\\\n'.join([str(u) + ' ' + str(v) for (u, v) in edge])\\nprint(ans)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a construction set with bulbs and wires. Each pair of bulbs (2i-1, 2i) should be connected by a chain of d_i wires. The task is to find a configuration where all such bulb pairs are connected by chains of the specified length, forming a tree structure. Essentially, we need to output the wiring connections to satisfy these constraints.\\n- Data Structures and Initialization:  The code first reads the input `n` and the array `d`. It then transforms `d` into a list of lists, where each inner list contains the starting bulb index (2*i + 1) and the desired chain length d_i. The list is then sorted in descending order based on the chain length d_i.\\n- Building the Tree Structure: The code uses a clever approach to construct the tree.  The core idea revolves around using the sorted list of bulbs and their desired chain lengths. It maintains an `arr` list and an `edge` list to store the constructed tree's nodes and edges, respectively.\\n- Connecting Bulbs According to Chain Lengths: For each bulb, the code finds a suitable node in `arr` to connect to such that the distance between the bulb and that node is d_i. The connection happens via adding edges to the `edge` list. If necessary (when `i + d_ - 1 == len(arr) - 1`), a new node (x + 1) is added to `arr` to facilitate the connections. After creating edges with distance constraint the bulbs close to each other gets connected to create a tree structure. Zipping adjacent bulbs creates the connection between them.\\n- Outputting the Result: The resulting edges (pairs of connected bulbs) are then formatted and printed to the console.\",\n  \"LLM Questions\": [\n    \"What does it mean for the completed construction set configuration to be correct?\",\n    \"What is the significance of sorting the d_i values in reverse order?\",\n    \"Can you explain the logic behind adding the `x + 1` node to the `arr` list?\",\n    \"Why are adjacent elements in sorted 'd' array are getting zipped?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A correct configuration means the network of bulbs and wires forms a tree structure, ensuring any two distinct bulbs are endpoints of some chain.\",\n    \"Sorting the d_i values in reverse order seems to prioritize creating the longest chains first, which might help in satisfying the tree structure constraint more easily.  It appears to be a key step in the construction algorithm.\",\n    \"The `x + 1` node is added when the current chain being formed requires a connection to a node outside the existing set of nodes in `arr`.  This ensures that the chain of the specified length d_i can be created for the bulb.\",\n    \"The adjacent elements are getting zipped so the connection between them in the sorted list can be created to complete the construction set by building a tree.\"\n  ]\n}\n```"