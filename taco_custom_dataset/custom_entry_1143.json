"```json\n{\n  \"Coding Problem\": \"Chef has an array A of length N.\\n\\nIn one operation, Chef can choose any two distinct indices i, j (1 \u2264 i, j \u2264 N, i \\\\neq j) and either change A_{i} to A_{j} or change A_{j} to A_{i}.\\n\\nFind the minimum number of operations required to make all the elements of the array equal.\\n\\n------ Input Format ------ \\n\\n- First line will contain T, number of test cases. Then the test cases follow.\\n- First line of each test case consists of an integer N - denoting the size of array A.\\n- Second line of each test case consists of N space-separated integers A_{1}, A_{2}, \\\\dots, A_{N} - denoting the array A.\\n\\n------ Output Format ------ \\n\\nFor each test case, output the minimum number of operations required to make all the elements equal.\\n\\n------ Constraints ------ \\n\\n$1 \u2264 T \u2264 100$\\n$2 \u2264 N \u2264 1000$\\n$1 \u2264 A_{i} \u2264 1000$\\n\\n----- Sample Input 1 ------ \\n4\\n3\\n1 2 3\\n4\\n5 5 5 5\\n4\\n2 2 1 1\\n3\\n1 1 2\\n\\n----- Sample Output 1 ------ \\n2\\n0\\n2\\n1\\n\\n----- explanation 1 ------ \\nTest Case $1$: You can make all the elements equal in $2$ operations. In the first operation, you can choose indices $1, 2$ and convert $A_{1}$ to $A_{2}$. So the array becomes $[2, 2, 3]$. Now you can choose indices $1, 3$ and convert $A_{3}$ to $A_{1}$, so the final array becomes $[2, 2, 2]$.\\n\\nTest Case $2$: Since all the elements are already equal there is no need to perform any operation.\\n\\nTest Case $3$: You can make all the elements equal in $2$ operations. In the first operation, you can choose indices $1, 3$ and convert $A_{1}$ to $A_{3}$. So the array becomes $[1, 2, 1, 1]$. Now you can choose indices $1, 2$ and convert $A_{2}$ to $A_{1}$, so the final array becomes $[1, 1, 1, 1]$.\\n\\nTest Case $4$: You can make all the elements equal in $1$ operation. You can pick indices $2, 3$ and convert $A_{3}$ to $A_{2}$ after which the array becomes $[1, 1, 1]$.\",\n  \"Ground Truth Solution\": \"from statistics import mode\\nt = int(input())\\nfor i in range(t):\\n\\tn = int(input())\\n\\ta = list(map(int, input().split()))\\n\\tcount = 0\\n\\tm = mode(a)\\n\\tfor i in range(n):\\n\\t\\tif a[i] != m:\\n\\t\\t\\tcount += 1\\n\\tprint(count)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the problem: The problem asks to find the minimum number of operations to make all elements in an array equal. An operation involves choosing two distinct indices and changing the value at one index to the value at the other.\\n- Identifying key insights: The minimum number of operations will be the number of elements that are not equal to the most frequent element in the array. Therefore, identifying the mode (most frequent element) is crucial.\\n- Algorithm selection: Count the occurrences of each element and identify the element that appears most often (the mode). Then, count how many elements are *not* equal to the mode. This count will be the minimum number of operations.\\n- Edge Cases: Consider the case where all elements are the same. In this case, the number of operations should be 0.\",\n  \"LLM Questions\": [\n    \"What is the minimum number of operations if all the elements of the array are the same?\",\n    \"How do you identify the element that needs to be the target value for all other elements?\",\n    \"If you know the element that should be the target, how do you determine how many operations are needed?\",\n    \"What is the time complexity of determining the most frequent element?\",\n    \"What is the time complexity of the overall algorithm, considering finding the mode and iterating to count differences?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"If all elements are the same, the minimum number of operations is 0.\",\n    \"You identify the target value by finding the element that appears most frequently in the array (the mode).\",\n    \"Once you have the target element (mode), you iterate through the array and count how many elements are not equal to the mode. This count represents the number of operations needed.\",\n    \"The time complexity of determining the most frequent element in an unsorted array is typically O(n) if you use a hash map to count frequencies, or O(n log n) if you sort the array first.\",\n    \"The overall time complexity is dominated by the mode-finding step and the iteration to count differences. If you use a hash map for mode finding (O(n)) and then iterate once (O(n)), the overall complexity is O(n).\"\n  ]\n}\n```"