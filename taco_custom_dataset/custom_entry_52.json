"```json\n{\n  \"Coding Problem\": \"We have a tree with N vertices numbered 1 to N. The i-th edge in this tree connects Vertex a_i and b_i.\\nFor each k=1, ..., N, solve the problem below:\\n - Consider writing a number on each vertex in the tree in the following manner:\\n - First, write 1 on Vertex k.\\n - Then, for each of the numbers 2, ..., N in this order, write the number on the vertex chosen as follows:\\n - Choose a vertex that still does not have a number written on it and is adjacent to a vertex with a number already written on it. If there are multiple such vertices, choose one of them at random.\\n - Find the number of ways in which we can write the numbers on the vertices, modulo (10^9+7).\\n\\n-----Constraints-----\\n - 2 \\\\leq N \\\\leq 2 \\\\times 10^5\\n - 1 \\\\leq a_i,b_i \\\\leq N\\n - The given graph is a tree.\\n\\n-----Input-----\\nInput is given from Standard Input in the following format:\\nN\\na_1 b_1\\n:\\na_{N-1} b_{N-1}\\n\\n-----Output-----\\nFor each k=1, 2, ..., N in this order, print a line containing the answer to the problem.\\n\\n-----Sample Input-----\\n3\\n1 2\\n1 3\\n\\n-----Sample Output-----\\n2\\n1\\n1\\n\\nThe graph in this input is as follows:\\n\\nFor k=1, there are two ways in which we can write the numbers on the vertices, as follows:\\n - Writing 1, 2, 3 on Vertex 1, 2, 3, respectively\\n - Writing 1, 3, 2 on Vertex 1, 2, 3, respectively\",\n  \"Ground Truth Solution\": \"import sys\\nfrom functools import reduce\\n\\ndef rerooting(N, adj, merge, finalize, identity):\\n\\torder = [None] * N\\n\\tparent = [None] * N\\n\\tparent[0] = -1\\n\\tstack = [0]\\n\\tfor i in range(N):\\n\\t\\tv = stack.pop()\\n\\t\\torder[i] = v\\n\\t\\tfor u in adj[v]:\\n\\t\\t\\tif parent[u] is None:\\n\\t\\t\\t\\tparent[u] = v\\n\\t\\t\\t\\tstack.append(u)\\n\\tdp_down = [None] * N\\n\\tfor v in reversed(order[1:]):\\n\\t\\tp = parent[v]\\n\\t\\tdp_down[v] = finalize(reduce(merge, (dp_down[c] for c in adj[v] if c != p), identity))\\n\\tdp_up = [None] * N\\n\\tdp_up[0] = identity\\n\\tfor v in order:\\n\\t\\tif len(adj[v]) == 1 and adj[v][0] == parent[v]:\\n\\t\\t\\tcontinue\\n\\t\\tp = parent[v]\\n\\t\\tleft = [dp_up[v]]\\n\\t\\tfor u in adj[v]:\\n\\t\\t\\tif u != p:\\n\\t\\t\\t\\tleft.append(merge(left[-1], dp_down[u]))\\n\\t\\tright = [identity]\\n\\t\\tfor u in reversed(adj[v]):\\n\\t\\t\\tif u != p:\\n\\t\\t\\t\\tright.append(merge(dp_down[u], right[-1]))\\n\\t\\ti = 0\\n\\t\\tfor u in adj[v]:\\n\\t\\t\\tif u != p:\\n\\t\\t\\t\\tdp_up[u] = finalize(merge(left[i], right[-i - 2]))\\n\\t\\t\\ti += 1\\n\\tfor (v, l) in enumerate(adj):\\n\\t\\torder[v] = reduce(merge, (dp_down[u] for u in adj[v] if u != parent[v]), identity)\\n\\t\\torder[v] = finalize(merge(order[v], dp_up[v]))\\n\\treturn order\\n\\ndef solve(N, edges):\\n\\tMOD = 10 ** 9 + 7\\n\\tfactorio = [1] * (N + 1)\\n\\tt = 1\\n\\tfor i in range(1, N + 1):\\n\\t\\tt *= i\\n\\t\\tt %= MOD\\n\\t\\tfactorio[i] = t\\n\\tadj = [[] for _ in range(N)]\\n\\tfor (a, b) in edges:\\n\\t\\tadj[a].append(b)\\n\\t\\tadj[b].append(a)\\n\\n\\tdef func(x, y):\\n\\t\\t(cx, nx) = x\\n\\t\\t(cy, ny) = y\\n\\t\\tc = cx * cy * factorio[nx + ny] * pow(factorio[nx] * factorio[ny], MOD - 2, MOD)\\n\\t\\tc %= MOD\\n\\t\\tn = nx + ny\\n\\t\\treturn (c, n)\\n\\n\\tdef func2(x):\\n\\t\\t(c, n) = x\\n\\t\\treturn (c, n + 1)\\n\\tidentity = (1, 0)\\n\\tres = rerooting(N, adj, func, func2, identity)\\n\\tfor (k, n) in res:\\n\\t\\tprint(k)\\nread = sys.stdin.buffer.read\\nreadline = sys.stdin.buffer.readline\\nreadlines = sys.stdin.buffer.readlines\\nN = int(readline())\\nm = map(int, read().split())\\nedges = tuple(((a - 1, b - 1) for (a, b) in zip(m, m)))\\nsolve(N, edges)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks for the number of ways to label the vertices of a tree with numbers 1 to N, where the labeling starts from a given vertex k with the number 1. The remaining numbers are assigned sequentially to adjacent, unlabeled vertices chosen at random.\\n- Identifying Key Constraints: The graph is a tree, which means there are no cycles. We need to calculate the number of possible labelings for each possible starting vertex k from 1 to N. The answer needs to be modulo (10^9+7).\\n- Choosing an Algorithm: The problem can be solved using dynamic programming, specifically a rerooting DP approach. This involves first rooting the tree arbitrarily, then computing the number of ways to label the subtree rooted at each node. Then, we reroot the tree at each node k and recompute the number of ways to label the tree starting from k.\\n- Handling Edge Cases: Consider edge cases such as small trees (N=2, N=3) and ensure that the algorithm works correctly for them. Also, need to handle the modulo operation correctly during the calculations.\\n- Implementation Details: Need to construct the adjacency list representation of the tree. The rerooting DP involves a merge operation to combine the number of labelings from subtrees, and a finalize operation to add the current node to the labeling. The `identity` element represents the base case when there are no subtrees.  The time complexity of this approach is O(N).\",\n  \"LLM Questions\": [\n    \"What does it mean to write numbers on the vertices 'in order', and how does this affect the possible labelings?\",\n    \"Since the given graph is a tree, what properties of trees are relevant to consider for this problem?\",\n    \"How can we use dynamic programming to compute the number of possible labelings of the tree?\",\n    \"What is rerooting DP, and why is it suitable for this problem?\",\n    \"How would you define the 'merge' and 'finalize' operations for this particular rerooting DP problem?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Writing numbers 'in order' means labeling vertices sequentially from 2 to N, each time choosing an unlabeled vertex adjacent to a labeled one. This restricts the possible labelings and defines the problem's constraints.\",\n    \"Since the graph is a tree, there is a unique path between any two vertices.  This simplifies the problem as we don't have to deal with cycles.  We can also use tree-specific algorithms like tree traversals (DFS, BFS) and tree dynamic programming techniques.\",\n    \"We can use dynamic programming to store the number of possible labelings for subtrees rooted at each node. This can be calculated recursively, combining the number of labelings for each child node.\",\n    \"Rerooting DP is a technique where we compute a value for each node in a tree as if it were the root. We start by rooting the tree at an arbitrary node, compute values for all nodes, then efficiently update these values for each possible root by propagating information up and down the tree. It is suitable because we need to find the solution for each node as the starting vertex (root).\",\n    \"The 'merge' operation combines the number of ways to label two subtrees into a larger subtree. It should involve multiplying the number of ways to label each subtree, accounting for the different ways to interleave the numbering of the two subtrees (using combinatorics). The 'finalize' operation adds the current node to the labeling, incrementing the number of labelled nodes in the process. It essentially finalizes the counts by merging the counts from each subtree.\"\n  ]\n}\n```"