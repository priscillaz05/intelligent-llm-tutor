"```json\n{\n  \"Coding Problem\": \"A new agent called Killjoy invented a virus COVID-2069 that infects accounts on Codeforces. Each account has a rating, described by an integer (it can possibly be negative or very large).\\n\\nKilljoy's account is already infected and has a rating equal to $x$. Its rating is constant. There are $n$ accounts except hers, numbered from $1$ to $n$. The $i$-th account's initial rating is $a_i$. Any infected account (initially the only infected account is Killjoy's) instantly infects any uninfected account if their ratings are equal. This can happen at the beginning (before any rating changes) and after each contest. If an account is infected, it can not be healed.\\n\\nContests are regularly held on Codeforces. In each contest, any of these $n$ accounts (including infected ones) can participate. Killjoy can't participate. After each contest ratings are changed this way: each participant's rating is changed by an integer, but the sum of all changes must be equal to zero. New ratings can be any integer.\\n\\nFind out the minimal number of contests needed to infect all accounts. You can choose which accounts will participate in each contest and how the ratings will change.\\n\\nIt can be proven that all accounts can be infected in some finite number of contests.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $t$ $(1 \\\\le t \\\\le 100)$\u00a0\u2014 the number of test cases. The next $2t$ lines contain the descriptions of all test cases.\\n\\nThe first line of each test case contains two integers $n$ and $x$ ($2 \\\\le n \\\\le 10^3$, $-4000 \\\\le x \\\\le 4000$)\u00a0\u2014 the number of accounts on Codeforces and the rating of Killjoy's account.\\n\\nThe second line of each test case contains $n$ integers $a_1, a_2, \\\\dots, a_n$ $(-4000 \\\\le a_i \\\\le 4000)$\u00a0\u2014 the ratings of other accounts.\\n\\n\\n-----Output-----\\n\\nFor each test case output the minimal number of contests needed to infect all accounts.\\n\\n\\n-----Example-----\\nInput\\n3\\n2 69\\n68 70\\n6 4\\n4 4 4 4 4 4\\n9 38\\n-21 83 50 -59 -77 15 -71 -78 20\\n\\nOutput\\n1\\n0\\n2\\n\\n\\n\\n-----Note-----\\n\\nIn the first test case it's possible to make all ratings equal to $69$. First account's rating will increase by $1$, and second account's rating will decrease by $1$, so the sum of all changes will be equal to zero.\\n\\nIn the second test case all accounts will be instantly infected, because all ratings (including Killjoy's account's rating) are equal to $4.\",\n  \"Ground Truth Solution\": \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nt = int(input())\\nfor _ in range(t):\\n\\t(n, x) = list(map(int, input().rstrip().split(' ')))\\n\\ta = list(map(int, input().rstrip().split(' ')))\\n\\tz = set(a)\\n\\tif x in z:\\n\\t\\tif len(z) == 1:\\n\\t\\t\\tprint(0)\\n\\t\\telse:\\n\\t\\t\\tprint(1)\\n\\telse:\\n\\t\\tnetChange = 0\\n\\t\\tfor ele in a:\\n\\t\\t\\tnetChange += ele - x\\n\\t\\tif netChange == 0:\\n\\t\\t\\tprint(1)\\n\\t\\telse:\\n\\t\\t\\tprint(2)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Problem Constraints: Identify that Killjoy's rating, $x$, is constant, and there are $n$ other accounts with initial ratings $a_i$. Understand that infection spreads instantly if any uninfected account has the same rating as an infected one. Contests change ratings, but the sum of all rating changes must be zero.\\n- Identifying Potential Pitfalls: Consider cases where all accounts are already infected (all $a_i = x$). Consider the case where some accounts have rating $x$, but not all. Consider cases where no accounts have rating $x$. Recognize that the sum of differences between ratings and $x$ being zero is a crucial condition.\\n- Selecting an Algorithmic Strategy: Check if any account has rating $x$. If all accounts have rating $x$, then no contests are needed. If some accounts have rating $x$, then one contest is sufficient to make all other accounts have rating $x$. If no account has rating $x$, check if the sum of the differences between each rating and $x$ is zero. If it is, one contest is sufficient. Otherwise, two contests are needed.\\n- Implementation Considerations: Iterate through the given ratings and check if any of them are equal to $x$. Calculate the sum of differences between each $a_i$ and $x$.\",\n  \"LLM Questions\": [\n    \"What are the conditions required for an account to be infected without any contests?\",\n    \"Expected Answer: All accounts must have the same rating as Killjoy's rating $x$ initially.\",\n    \"If some accounts have the same rating as Killjoy's rating, what is the minimum number of contests needed?\",\n    \"Expected Answer: One contest. The contest can be designed so all non-infected account ratings are changed to Killjoy's rating and therefore, they become infected\",\n    \"If no accounts have the same rating as Killjoy's rating, how can you decide the minimum number of contests needed?\",\n    \"Expected Answer: Check if the sum of the differences between each account's rating and Killjoy's rating is equal to zero. If so, one contest will suffice; otherwise, two contests are needed.\",\n    \"Why is the sum of changes after a contest always zero?\",\n    \"Expected Answer: The problem statement specifies that the sum of all changes to ratings after each contest must be equal to zero.\",\n    \"If no initial rating equals Killjoy's rating and the sum of differences isn't zero, why are exactly two contests required?\",\n    \"Expected Answer: The first contest can modify the ratings such that the sum of differences becomes zero. Then, the second contest can make all ratings equal to Killjoy's rating.\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"All accounts must have the same rating as Killjoy's rating $x$ initially.\",\n    \"One contest. The contest can be designed so all non-infected account ratings are changed to Killjoy's rating and therefore, they become infected\",\n    \"Check if the sum of the differences between each account's rating and Killjoy's rating is equal to zero. If so, one contest will suffice; otherwise, two contests are needed.\",\n    \"The problem statement specifies that the sum of all changes to ratings after each contest must be equal to zero.\",\n    \"The first contest can modify the ratings such that the sum of differences becomes zero. Then, the second contest can make all ratings equal to Killjoy's rating.\"\n  ]\n}\n```"