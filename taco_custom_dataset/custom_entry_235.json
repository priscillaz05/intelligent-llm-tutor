"```json\n{\n  \"Coding Problem\": \"Given an array arr[] of size N and an integer K. Find the maximum for each and every contiguous subarray of size K.\\nExample 1:\\nInput:\\nN = 9, K = 3\\narr[] = 1 2 3 1 4 5 2 3 6\\nOutput: \\n3 3 4 5 5 5 6 \\nExplanation: \\n1st contiguous subarray = {1 2 3} Max = 3\\n2nd contiguous subarray = {2 3 1} Max = 3\\n3rd contiguous subarray = {3 1 4} Max = 4\\n4th contiguous subarray = {1 4 5} Max = 5\\n5th contiguous subarray = {4 5 2} Max = 5\\n6th contiguous subarray = {5 2 3} Max = 5\\n7th contiguous subarray = {2 3 6} Max = 6\\nExample 2:\\nInput:\\nN = 10, K = 4\\narr[] = 8 5 10 7 9 4 15 12 90 13\\nOutput: \\n10 10 10 15 15 90 90\\nExplanation: \\n1st contiguous subarray = {8 5 10 7}, Max = 10\\n2nd contiguous subarray = {5 10 7 9}, Max = 10\\n3rd contiguous subarray = {10 7 9 4}, Max = 10\\n4th contiguous subarray = {7 9 4 15}, Max = 15\\n5th contiguous subarray = {9 4 15 12}, \\nMax = 15\\n6th contiguous subarray = {4 15 12 90},\\nMax = 90\\n7th contiguous subarray = {15 12 90 13}, \\nMax = 90\\nYour Task:  \\nYou dont need to read input or print anything. Complete the function max_of_subarrays() which takes the array, N and K as input parameters and returns a list of integers denoting the maximum of every contiguous subarray of size K.\\nExpected Time Complexity: O(N)\\nExpected Auxiliary Space: O(k)\\nConstraints:\\n1 \u2264 N \u2264 10^{5}\\n1 \u2264 K \u2264 N\\n0 \u2264 arr[i] \u2264 10^{7}\",\n  \"Ground Truth Solution\": \"class Solution:\\n\\n\\tdef max_of_subarrays(self, arr, n, k):\\n\\t\\tans = []\\n\\t\\tQ = deque([])\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif Q and Q[0] <= i - k:\\n\\t\\t\\t\\tQ.popleft()\\n\\t\\t\\twhile Q and arr[Q[-1]] <= arr[i]:\\n\\t\\t\\t\\tQ.pop()\\n\\t\\t\\tQ.append(i)\\n\\t\\t\\tif i >= k - 1:\\n\\t\\t\\t\\tans.append(arr[Q[0]])\\n\\t\\treturn ans\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks us to find the maximum element in each contiguous subarray of size K within a given array arr of size N.\\n- Data Structure Selection: A deque (double-ended queue) can efficiently store indices of potentially maximum elements within the current window. The front of the deque will always hold the index of the maximum element in the current window.\\n- Algorithm Steps: Iterate through the array. For each element:\\n    - Remove indices from the front of the deque that are out of the current window.\\n    - Remove indices from the back of the deque that correspond to elements smaller than the current element (since they can't be the maximum in any future window).\\n    - Add the current element's index to the back of the deque.\\n    - If the window size is reached, add the maximum element of the current window (at the front of the deque) to the result.\\n- Optimizations: The deque ensures that the algorithm has O(N) time complexity, as each element is added and removed from the deque at most once. Also uses O(K) space\",\n  \"LLM Questions\": [\n    \"What is a contiguous subarray and how do you identify them?\",\n    \"How can a deque help to efficiently find the maximum in each subarray?\",\n    \"How do you ensure the algorithm runs in O(N) time complexity?\",\n    \"How do you manage the indices in the deque to keep track of the elements within the current window?\",\n    \"What are the advantages of using a deque compared to other data structures like a list or a heap?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A contiguous subarray is a sequence of elements from the array that are adjacent to each other.  They are identified by sliding a window of size K across the array, one element at a time.\",\n    \"A deque helps because it allows efficient addition and removal of elements from both ends.  This allows us to maintain a sorted list of potentially maximum elements within the current window, so the front of the queue will contain the largest value.\",\n    \"The algorithm runs in O(N) time complexity because each element of the input array is visited and processed at most a constant number of times (added to and removed from the deque at most once).\",\n    \"The deque stores indices of the array elements. When an element's index is outside the current window (i.e., index < i - K + 1 where 'i' is the current index), it's removed from the front of the deque.\",\n    \"The deque provides O(1) time complexity for adding and removing elements from both ends, making it ideal for maintaining the window's maximum. A list would require O(K) to find the maximum in each window. A heap would provide the maximum but might require O(log K) for insertion/deletion in each window, increasing overall complexity.\"\n  ]\n}\n```"