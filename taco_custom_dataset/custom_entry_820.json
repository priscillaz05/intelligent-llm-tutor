"```json\n{\n  \"Coding Problem\": \"Peter wrote on the board a strictly increasing sequence of positive integers a_1, a_2, ..., a_{n}. Then Vasil replaced some digits in the numbers of this sequence by question marks. Thus, each question mark corresponds to exactly one lost digit.\\n\\nRestore the the original sequence knowing digits remaining on the board.\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains integer n (1 \u2264 n \u2264 10^5) \u2014 the length of the sequence. Next n lines contain one element of the sequence each. Each element consists only of digits and question marks. No element starts from digit 0. Each element has length from 1 to 8 characters, inclusive.\\n\\n\\n-----Output-----\\n\\nIf the answer exists, print in the first line \\\"YES\\\" (without the quotes). Next n lines must contain the sequence of positive integers \u2014 a possible variant of Peter's sequence. The found sequence must be strictly increasing, it must be transformed from the given one by replacing each question mark by a single digit. All numbers on the resulting sequence must be written without leading zeroes. If there are multiple solutions, print any of them.\\n\\nIf there is no answer, print a single line \\\"NO\\\" (without the quotes).\\n\\n\\n-----Examples-----\\nInput\\n3\\n?\\n18\\n1?\\n\\nOutput\\nYES\\n1\\n18\\n19\\n\\nInput\\n2\\n??\\n?\\n\\nOutput\\nNO\\n\\nInput\\n5\\n12224\\n12??5\\n12226\\n?0000\\n?00000\\n\\nOutput\\nYES\\n12224\\n12225\\n12226\\n20000\\n100000\",\n  \"Ground Truth Solution\": \"def solve(s, t, i, l):\\n\\tif i == l:\\n\\t\\treturn False\\n\\tif s[i] == '?':\\n\\t\\tif solve(s, t, i + 1, l):\\n\\t\\t\\ts[i] = t[i]\\n\\t\\t\\treturn True\\n\\t\\telif t[i] == '9':\\n\\t\\t\\treturn False\\n\\t\\ts[i] = nxt[t[i]]\\n\\t\\tfor j in range(i, l):\\n\\t\\t\\tif s[j] == '?':\\n\\t\\t\\t\\ts[j] = '0'\\n\\t\\treturn True\\n\\telif s[i] > t[i]:\\n\\t\\tfor j in range(i, l):\\n\\t\\t\\tif s[j] == '?':\\n\\t\\t\\t\\ts[j] = '0'\\n\\t\\treturn True\\n\\telif s[i] < t[i]:\\n\\t\\treturn False\\n\\telse:\\n\\t\\treturn solve(s, t, i + 1, l)\\nn = int(input())\\na = [list(input()) for _ in range(n)]\\np = ['0']\\nnxt = {str(x): str(x + 1) for x in range(9)}\\nfor (i, ai) in enumerate(a):\\n\\tif len(p) > len(ai):\\n\\t\\tprint('NO')\\n\\t\\tbreak\\n\\tif len(p) < len(ai):\\n\\t\\tif a[i][0] == '?':\\n\\t\\t\\ta[i][0] = '1'\\n\\t\\tfor j in range(len(ai)):\\n\\t\\t\\tif a[i][j] == '?':\\n\\t\\t\\t\\ta[i][j] = '0'\\n\\telif not solve(a[i], p, 0, len(ai)):\\n\\t\\tprint('NO')\\n\\t\\tbreak\\n\\tp = a[i]\\nelse:\\n\\tprint('YES')\\n\\tprint('\\\\n'.join((''.join(line) for line in a)))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Problem Constraints: The input is a sequence of strings, some of which contain question marks that need to be replaced with digits. The resulting sequence must be strictly increasing. Numbers must be positive integers and cannot start with '0'. The length of the numbers can range from 1 to 8. Need to handle cases where a solution may not exist.\\n- Identifying Potential Pitfalls: The primary challenge lies in ensuring the strictly increasing condition is always met while replacing '?' with digits. Need to handle leading zeros carefully, especially when the length of current number is greater than previous number. Edge cases exist when no solution is possible (return 'NO'). Need to decide how to choose digits for '?' to guarantee the increasing order.\\n- Selecting an Algorithmic Strategy: Iterate through the input list of strings. Keep track of the previously generated number. Compare the length of the current string and previous number. If the current string has more digits, fill all the '?' in current string with 0s, but if the first digit is a '?', change it to '1'. If the lengths are equal, compare from left to right. If the current number is smaller than or equal to previous, it is impossible to generate a solution. Implement a recursive solve function that checks to find a solution, incrementing the string at the first '?' that doesn't exceed the prev string.\",\n  \"LLM Questions\": [\n    \"What are the constraints on the sequence of numbers that need to be generated?\",\n    \"How do you handle the condition that the numbers must be strictly increasing?\",\n    \"How do you decide on the values to substitute for the question marks in the input strings?\",\n    \"What are the edge cases and how do you handle them? (e.g., no solution exists, numbers starting with leading zeroes)\",\n    \"How does the length of the current number, compared to the previous number in the sequence, affect the replacement of question marks?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The numbers must be positive integers, without leading zeroes, and the sequence must be strictly increasing.\",\n    \"When the current number has the same number of digits as the previous, you need to ensure that the current number is strictly greater than the previous.  When the current number has more digits than the previous number, the current number is guaranteed to be larger.\",\n    \"You replace question marks with digits in such a way as to ensure the strictly increasing sequence condition is always met.  Also ensure that you do not generate leading zeros.\",\n    \"Edge cases to consider are: when the number of digits is less than the last number which is invalid.  When you cannot increment the current number because it would result in a number greater than the maximum 8-digit number.  Leading zeroes must not be generated.\",\n    \"If the current number has more digits than the previous number, then all question marks can be replaced with 0s, except potentially the leading digit that should be set to 1 if it is a question mark. If the current number has the same number of digits as the previous number, then you have to make sure to increment to the minimum possible value that is greater than the previous number.\"\n  ]\n}\n```"