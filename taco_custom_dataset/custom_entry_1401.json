"```json\n{\n  \"Coding Problem\": \"You are given an array a of length n that consists of zeros and ones.\\n\\nYou can perform the following operation multiple times. The operation consists of two steps: \\n\\n  1. Choose three integers 1 \u2264 x < y < z \u2264 n, that form an arithmetic progression (y - x = z - y). \\n  2. Flip the values a_x, a_y, a_z (i.e. change 1 to 0, change 0 to 1). \\n\\n\\nDetermine if it is possible to make all elements of the array equal to zero. If yes, print the operations that lead the the all-zero state. Your solution should not contain more than (\u230a n/3 \u230b + 12) operations. Here \u230a q \u230b denotes the number q rounded down. We can show that it is possible to make all elements equal to zero in no more than this number of operations whenever it is possible to do so at all.\\n\\nInput\\n\\nThe first line contains a single integer n (3 \u2264 n \u2264 10^5) \u2014 the length of the array.\\n\\nThe second line contains n integers a_1, a_2, \u2026, a_n (0 \u2264 a_i \u2264 1) \u2014 the elements of the array.\\n\\nOutput\\n\\nPrint \\\"YES\\\" (without quotes) if the answer exists, otherwise print \\\"NO\\\" (without quotes). You can print each letter in any case (upper or lower).\\n\\nIf there is an answer, in the second line print an integer m (0 \u2264 m \u2264 (\u230a n/3 \u230b + 12)) \u2014 the number of operations in your answer.\\n\\nAfter that in (i + 2)-th line print the i-th operations \u2014 the integers x_i, y_i, z_i. You can print them in arbitrary order.\\n\\nExamples\\n\\nInput\\n\\n5\\n1 1 0 1 1\\n\\n\\nOutput\\n\\nYES\\n2\\n1 3 5\\n2 3 4\\n\\n\\nInput\\n\\n3\\n0 1 0\\n\\n\\nOutput\\n\\nNO\\n\\nNote\\n\\nIn the first sample the shown output corresponds to the following solution: \\n\\n  * 1 1 0 1 1 (initial state); \\n  * 0 1 1 1 0 (the flipped positions are the first, the third and the fifth elements); \\n  * 0 0 0 0 0 (the flipped positions are the second, the third and the fourth elements). \\n\\n\\n\\nOther answers are also possible. In this test the number of operations should not exceed \u230a 5/3 \u230b + 12 = 1 + 12 = 13.\\n\\nIn the second sample the only available operation is to flip all the elements. This way it is only possible to obtain the arrays 0 1 0 and 1 0 1, but it is impossible to make all elements equal to zero.\",\n  \"Ground Truth Solution\": \"def solve(a):\\n\\tl = len(a)\\n\\td = sum((a[i] * 2 ** i for i in range(l)))\\n\\tif d == 0:\\n\\t\\treturn []\\n\\tusable = []\\n\\tif l >= 3:\\n\\t\\tfor i in range(l - 2):\\n\\t\\t\\tusable.append(7 << i)\\n\\tif l >= 5:\\n\\t\\tfor i in range(l - 4):\\n\\t\\t\\tusable.append(21 << i)\\n\\tif l >= 7:\\n\\t\\tfor i in range(l - 6):\\n\\t\\t\\tusable.append(73 << i)\\n\\tul = len(usable)\\n\\tbest_answer = None\\n\\tfor mask in range(1 << ul):\\n\\t\\tstart = 0\\n\\t\\tclone = mask\\n\\t\\tcnt = 0\\n\\t\\twhile clone:\\n\\t\\t\\tif clone % 2 == 1:\\n\\t\\t\\t\\tstart ^= usable[cnt]\\n\\t\\t\\tclone //= 2\\n\\t\\t\\tcnt += 1\\n\\t\\tif start == d:\\n\\t\\t\\tanswer = []\\n\\t\\t\\tclone = mask\\n\\t\\t\\tcnt = 0\\n\\t\\t\\twhile clone:\\n\\t\\t\\t\\tif clone % 2 == 1:\\n\\t\\t\\t\\t\\tanswer.append([])\\n\\t\\t\\t\\t\\tused = usable[cnt]\\n\\t\\t\\t\\t\\tcnt2 = 1\\n\\t\\t\\t\\t\\twhile used:\\n\\t\\t\\t\\t\\t\\tif used % 2 == 1:\\n\\t\\t\\t\\t\\t\\t\\tanswer[-1].append(cnt2)\\n\\t\\t\\t\\t\\t\\tcnt2 += 1\\n\\t\\t\\t\\t\\t\\tused //= 2\\n\\t\\t\\t\\tclone //= 2\\n\\t\\t\\t\\tcnt += 1\\n\\t\\t\\tif best_answer is None or len(best_answer) > len(answer):\\n\\t\\t\\t\\tbest_answer = answer\\n\\treturn best_answer\\nn = int(input())\\na = list(map(int, input().split()))\\nif len(a) <= 10:\\n\\tsol = solve(a)\\n\\tif sol is None:\\n\\t\\tprint('NO')\\n\\t\\texit(0)\\n\\tprint('YES')\\n\\tprint(len(sol))\\n\\tfor t in sol:\\n\\t\\tprint(' '.join(map(str, t)))\\n\\texit(0)\\noperations = []\\nwhile len(a) > 10:\\n\\tl = len(a)\\n\\tlast = a[-3:]\\n\\tif last == [1, 1, 1]:\\n\\t\\toperations.append([l - 2, l - 1, l])\\n\\telif last == [1, 1, 0]:\\n\\t\\toperations.append([l - 3, l - 2, l - 1])\\n\\t\\ta[-4] ^= 1\\n\\telif last == [1, 0, 1]:\\n\\t\\toperations.append([l - 4, l - 2, l])\\n\\t\\ta[-5] ^= 1\\n\\telif last == [0, 1, 1]:\\n\\t\\tnxt = a[-6:-3]\\n\\t\\tif nxt == [1, 1, 1]:\\n\\t\\t\\toperations.append([l - 8, l - 4, l])\\n\\t\\t\\toperations.append([l - 5, l - 3, l - 1])\\n\\t\\t\\ta[-9] ^= 1\\n\\t\\telif nxt == [1, 1, 0]:\\n\\t\\t\\toperations.append([l - 8, l - 4, l])\\n\\t\\t\\toperations.append([l - 9, l - 5, l - 1])\\n\\t\\t\\ta[-9] ^= 1\\n\\t\\t\\ta[-10] ^= 1\\n\\t\\telif nxt == [1, 0, 1]:\\n\\t\\t\\toperations.append([l - 6, l - 3, l])\\n\\t\\t\\toperations.append([l - 9, l - 5, l - 1])\\n\\t\\t\\ta[-7] ^= 1\\n\\t\\t\\ta[-10] ^= 1\\n\\t\\telif nxt == [0, 1, 1]:\\n\\t\\t\\toperations.append([l - 6, l - 3, l])\\n\\t\\t\\toperations.append([l - 7, l - 4, l - 1])\\n\\t\\t\\ta[-7] ^= 1\\n\\t\\t\\ta[-8] ^= 1\\n\\t\\telif nxt == [1, 0, 0]:\\n\\t\\t\\toperations.append([l - 2, l - 1, l])\\n\\t\\t\\toperations.append([l - 8, l - 5, l - 2])\\n\\t\\t\\ta[-9] ^= 1\\n\\t\\telif nxt == [0, 1, 0]:\\n\\t\\t\\toperations.append([l - 2, l - 1, l])\\n\\t\\t\\toperations.append([l - 6, l - 4, l - 2])\\n\\t\\t\\ta[-7] ^= 1\\n\\t\\telif nxt == [0, 0, 1]:\\n\\t\\t\\toperations.append([l - 10, l - 5, l])\\n\\t\\t\\toperations.append([l - 5, l - 3, l - 1])\\n\\t\\t\\ta[-11] ^= 1\\n\\t\\telif nxt == [0, 0, 0]:\\n\\t\\t\\toperations.append([l - 8, l - 4, l])\\n\\t\\t\\toperations.append([l - 7, l - 4, l - 1])\\n\\t\\t\\ta[-9] ^= 1\\n\\t\\t\\ta[-8] ^= 1\\n\\t\\ta.pop()\\n\\t\\ta.pop()\\n\\t\\ta.pop()\\n\\telif last == [1, 0, 0]:\\n\\t\\toperations.append([l - 4, l - 3, l - 2])\\n\\t\\ta[-5] ^= 1\\n\\t\\ta[-4] ^= 1\\n\\telif last == [0, 1, 0]:\\n\\t\\toperations.append([l - 5, l - 3, l - 1])\\n\\t\\ta[-6] ^= 1\\n\\t\\ta[-4] ^= 1\\n\\telif last == [0, 0, 1]:\\n\\t\\toperations.append([l - 6, l - 3, l])\\n\\t\\ta[-7] ^= 1\\n\\t\\ta[-4] ^= 1\\n\\ta.pop()\\n\\ta.pop()\\n\\ta.pop()\\nwhile len(a) < 8:\\n\\ta.append(0)\\nsol = solve(a)\\nprint('YES')\\nsol = operations + sol\\nprint(len(sol))\\nfor t in sol:\\n\\tprint(' '.join(map(str, t)))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the problem: The core task is to transform an array of 0s and 1s into an array of all 0s using specific 'flip' operations on arithmetic progressions of indices.\\n- Identifying Constraints:  The array length is limited (3 \u2264 n \u2264 10^5). Operations must be arithmetic progressions of length 3 (x, y, z where y-x = z-y). Solution must exist and have limited operations (\u230a n/3 \u230b + 12).\\n- Algorithmic Strategy: A combination of two approaches appears suitable. First, reduce the problem size by iteratively applying a set of reduction rules to convert the end of the array into zeros while storing the operations performed. After the reduction steps the problem can be solved using exhaustive search with bitmasking for the remaining smaller part of the array (n <= 10).\\n- Edge Cases and Special Conditions: Initial check if the sum of the array represented as powers of 2 equals 0, if it is, return empty set of operation.\\n- Implementation details: In the bitmask approach the goal is to find a combination of bitmasks (usable operations) that, when XORed together, result in the bitmask representation of the input array.\",\n  \"LLM Questions\": [\n    \"How can we represent the initial array and the operations in a numerical format suitable for computation?\",\n    \"How does the constraint on the maximum number of operations guide the algorithmic approach?\",\n    \"What specific patterns at the end of the array allow for reduction steps, and how does each reduction step affect the operations to be performed?\",\n    \"What is the computational complexity of using bitmasking to solve the problem for small arrays, and why is this approach feasible for n <= 10?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The array can be treated as a binary number where each element's index determines its power of 2 (e.g., [1, 0, 1] = 1 * 2^0 + 0 * 2^1 + 1 * 2^2 = 5). The arithmetic progression flips can be represented as XOR operations with bitmasks that have 1s at the positions of the progression (e.g., flipping indices 1, 3, 5 corresponds to bitmask 2^0 + 2^2 + 2^4 = 21).\",\n    \"The limit on the number of operations forces the strategy of reducing the problem size before resorting to computationally expensive methods. Therefore, reduction strategies (converting last 3 elements of array to 0s) should be favored where possible.\",\n    \"Specific patterns like [1, 1, 1], [1, 1, 0], etc., at the end of the array can be converted to zeros by performing certain operations. Each reduction step involves recording the operation and sometimes affecting elements earlier in the array. This is done until array length becomes small enough.\",\n    \"The computational complexity of using bitmasking is O(2^k), where k is the number of possible operations and k is small. For n <= 10, all usable operations can be generated, and there are at most 7 + 5 + 3 + 1 operations so k will be a small constant.\"\n  ]\n}\n```"