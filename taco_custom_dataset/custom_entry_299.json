"```json\n{\n  \"Coding Problem\": \"Lets call a string which is composed of only 4 and 7 a Lucky String. For example,\\n47, 444, 44744 are all Lucky Strings of length 2, 3 and 5 respectively, while 45, 767  are not Lucky Strings. Now, consider a sorted list of all the Lucky Strings that can be formed where the sorting is done by the following rule: \\nA string a comes before string b if either length(a) < length(b) or,\\nlength(a)==length(b)  and a comes lexicographically before b.\\nThe first few elements in the list are as follows:\\n                              L = [ 4, 7, 44, 47, 74, 77, 444, 447, 474, 477, ....]\\n\\nNow, given an index K, your objective is to print the K th element in the list L. Consider \\n1 based indexing.\\n\\nInput:\\n\\nThe first line starts with a single integer T, the number of test cases.\\nT lines follow each containing a single integer K denoting an index of the list L.\\n\\nOutput:\\n\\nOutput T lines each containing the Lucky String at the K th index corresponding to each\\ntest case.\\n\\nConstraints:\\n\\n1 \u2264 T \u2264 100000 \\n1 \u2264 K \u2264 10^18\\n\\nSAMPLE INPUT\\n3\\n1\\n5\\n11\\n\\nSAMPLE OUTPUT\\n4\\n74\\n744\\n\\nExplanation\\n\\nIt is easy to see that 1st and 5th element in the list are as in list given in the problem\\nstatement. The 10th element in the list being 477, the next Lucky String is 744.\",\n  \"Ground Truth Solution\": \"'''\\n# Read input from stdin and provide input before running code\\n\\nname = raw_input('What is your name?\\\\n')\\nprint 'Hi, %s.' % name\\n'''\\n#print 'Hello World!'\\nt=eval(input())\\nwhile t>0:\\n\\tt-=1\\n\\tn=eval(input())\\n\\tl=1\\n\\twhile (n>(2**l)):\\n\\t\\tn-=(2**l)\\n\\t\\tl+=1\\n\\tn-=1\\n\\tx=bin(n)\\n\\tx=x[2:]\\n\\tx=x.replace(\\\"0\\\",\\\"4\\\")\\n\\tx=x.replace(\\\"1\\\",\\\"7\\\")\\n\\tp=\\\"4\\\"*(l-len(x))\\n\\tprint(p+x)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem Requirements: The problem defines \\\"Lucky Strings\\\" as those composed only of '4' and '7'. The task is to find the K-th Lucky String in a sorted list where sorting is based on length first, then lexicographically.\\n- Determining the Length of the K-th Lucky String: The length of the K-th string can be determined by observing that strings of length 1 have 2^1 combinations, strings of length 2 have 2^2 combinations, and so on. Therefore, iterate through lengths until we find the length l such that the sum of 2^1 + 2^2 + ... + 2^l >= K. This tells the length of the target string.\\n- Calculating the Index Within the Length: Once the length l is determined, adjust K by subtracting the number of lucky strings with lengths less than l. Then, K is effectively the index of our target string among all strings of length l.\\n- Converting the Index to Binary and Mapping to '4' and '7': Convert K-1 (since we want 0 based index) to its binary representation. Replace all the '0's in the binary string by '4' and '1's by '7'. This effectively gives us the K-th string of length l, lexicographically ordered using '4' and '7'. Pad the binary string with '4's to the left to match the length l.\",\n  \"LLM Questions\": [\n    \"What defines a 'Lucky String,' and how is the list of these strings sorted?\",\n    \"How can you determine the length of the K-th lucky string without generating all lucky strings up to K?\",\n    \"Once you know the length of the K-th lucky string, how do you find the exact string?\",\n    \"Why do we subtract 1 from K before converting it to binary?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A 'Lucky String' consists only of the characters '4' and '7'. The strings are sorted first by length (shorter strings come before longer strings) and then lexicographically within the same length.\",\n    \"We can calculate the number of lucky strings for each length (2^length) and accumulate these counts until the sum is greater than or equal to K.  The length at which this occurs is the length of the K-th lucky string.\",\n    \"After determining the length l and adjusting K (K = K - (2^1 + 2^2 + ... + 2^(l-1))), convert K-1 to its binary representation. Replace '0's with '4's and '1's with '7's. Pad the resulting string with leading '4's to achieve length l.\",\n    \"We subtract 1 to convert to a 0-based index, which is necessary because the binary conversion starts from 0. Without subtracting 1, the algorithm would generate the (K+1)-th lucky string.\"\n  ]\n}\n```"