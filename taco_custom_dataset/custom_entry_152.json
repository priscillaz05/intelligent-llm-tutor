"```json\n{\n  \"Coding Problem\": \"There was an epidemic in Monstropolis and all monsters became sick. To recover, all monsters lined up in queue for an appointment to the only doctor in the city.\\n\\nSoon, monsters became hungry and began to eat each other. \\n\\nOne monster can eat other monster if its weight is strictly greater than the weight of the monster being eaten, and they stand in the queue next to each other. Monsters eat each other instantly. There are no monsters which are being eaten at the same moment. After the monster A eats the monster B, the weight of the monster A increases by the weight of the eaten monster B. In result of such eating the length of the queue decreases by one, all monsters after the eaten one step forward so that there is no empty places in the queue again. A monster can eat several monsters one after another. Initially there were n monsters in the queue, the i-th of which had weight a_{i}.\\n\\nFor example, if weights are [1, 2, 2, 2, 1, 2] (in order of queue, monsters are numbered from 1 to 6 from left to right) then some of the options are:  the first monster can't eat the second monster because a_1 = 1 is not greater than a_2 = 2;  the second monster can't eat the third monster because a_2 = 2 is not greater than a_3 = 2;  the second monster can't eat the fifth monster because they are not neighbors;  the second monster can eat the first monster, the queue will be transformed to [3, 2, 2, 1, 2]. \\n\\nAfter some time, someone said a good joke and all monsters recovered. At that moment there were k (k \u2264 n) monsters in the queue, the j-th of which had weight b_{j}. Both sequences (a and b) contain the weights of the monsters in the order from the first to the last.\\n\\nYou are required to provide one of the possible orders of eating monsters which led to the current queue, or to determine that this could not happen. Assume that the doctor didn't make any appointments while monsters were eating each other.\\n\\n\\n-----Input-----\\n\\nThe first line contains single integer n (1 \u2264 n \u2264 500)\\u00a0\u2014 the number of monsters in the initial queue.\\n\\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^6)\\u00a0\u2014 the initial weights of the monsters.\\n\\nThe third line contains single integer k (1 \u2264 k \u2264 n)\\u00a0\u2014 the number of monsters in the queue after the joke. \\n\\nThe fourth line contains k integers b_1, b_2, ..., b_{k} (1 \u2264 b_{j} \u2264 5\u00b710^8)\\u00a0\u2014 the weights of the monsters after the joke. \\n\\nMonsters are listed in the order from the beginning of the queue to the end.\\n\\n\\n-----Output-----\\n\\nIn case if no actions could lead to the final queue, print \\\"NO\\\" (without quotes) in the only line. \\n\\nOtherwise print \\\"YES\\\" (without quotes) in the first line. In the next n - k lines print actions in the chronological order. In each line print x\\u00a0\u2014 the index number of the monster in the current queue which eats and, separated by space, the symbol 'L' if the monster which stays the x-th in the queue eats the monster in front of him, or 'R' if the monster which stays the x-th in the queue eats the monster behind him. After each eating the queue is enumerated again. \\n\\nWhen one monster eats another the queue decreases. If there are several answers, print any of them.\\n\\n\\n-----Examples-----\\nInput\\n6\\n1 2 2 2 1 2\\n2\\n5 5\\n\\nOutput\\nYES\\n2 L\\n1 R\\n4 L\\n3 L\\n\\nInput\\n5\\n1 2 3 4 5\\n1\\n15\\n\\nOutput\\nYES\\n5 L\\n4 L\\n3 L\\n2 L\\n\\nInput\\n5\\n1 1 1 3 3\\n3\\n2 1 6\\n\\nOutput\\nNO\\n\\n\\n-----Note-----\\n\\nIn the first example, initially there were n = 6 monsters, their weights are [1, 2, 2, 2, 1, 2] (in order of queue from the first monster to the last monster). The final queue should be [5, 5]. The following sequence of eatings leads to the final queue:  the second monster eats the monster to the left (i.e. the first monster), queue becomes [3, 2, 2, 1, 2];  the first monster (note, it was the second on the previous step) eats the monster to the right (i.e. the second monster), queue becomes [5, 2, 1, 2];  the fourth monster eats the mosnter to the left (i.e. the third monster), queue becomes [5, 2, 3];  the finally, the third monster eats the monster to the left (i.e. the second monster), queue becomes [5, 5]. \\n\\nNote that for each step the output contains numbers of the monsters in their current order in the queue.\",\n  \"Ground Truth Solution\": \"na = int(input())\\na = list(map(int, input().split()))\\nnb = int(input())\\nb = list(map(int, input().split()))\\n\\ndef judge(na, a, nb, b):\\n\\tans = []\\n\\tif sum(a) != sum(b):\\n\\t\\treturn (False, None)\\n\\tcur = 0\\n\\tind = -1\\n\\tj = 0\\n\\tfor (i, x) in enumerate(a):\\n\\t\\tcur += x\\n\\t\\tif cur < b[j]:\\n\\t\\t\\tpass\\n\\t\\telif cur == b[j]:\\n\\t\\t\\tbegin = ind + 1\\n\\t\\t\\tend = i\\n\\t\\t\\tinterval = a[begin:end + 1]\\n\\t\\t\\tif len(interval) > 1 and all((val == a[begin] for val in interval)):\\n\\t\\t\\t\\treturn (False, None)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(interval)\\n\\t\\t\\tind = i\\n\\t\\t\\tcur = 0\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\treturn (False, None)\\n\\t\\tif j >= len(b):\\n\\t\\t\\tbreak\\n\\treturn (True, ans)\\n\\ndef PrintAns(ans):\\n\\tfor ii in range(len(ans)):\\n\\t\\tnum = ans[ii]\\n\\t\\tbegin = end = 0\\n\\t\\tmaxn = max(num)\\n\\t\\tlenn = len(num)\\n\\t\\tfor i in range(lenn):\\n\\t\\t\\tif num[i] == maxn and (i > 0 and num[i] > num[i - 1] or (i < lenn - 1 and num[i] > num[i + 1])):\\n\\t\\t\\t\\tbegin = end = i\\n\\t\\t\\t\\tbreak\\n\\t\\twhile begin > 0 or end < lenn - 1:\\n\\t\\t\\tif begin > 0 and num[begin] > num[begin - 1]:\\n\\t\\t\\t\\tPrintOne(begin, ii, 'L')\\n\\t\\t\\t\\tbegin -= 1\\n\\t\\t\\t\\tnum[begin] += num[begin + 1]\\n\\t\\t\\t\\tnum[end] = num[begin]\\n\\t\\t\\telif end < len(num) - 1 and num[end] > num[end + 1]:\\n\\t\\t\\t\\tPrintOne(begin, ii, 'R')\\n\\t\\t\\t\\tend += 1\\n\\t\\t\\t\\tnum[end] += num[end - 1]\\n\\t\\t\\t\\tnum[begin] = num[end]\\n\\ndef PrintOne(ind, offset, op):\\n\\tprint(ind + offset + 1, op)\\n(ret, ans) = judge(na, a, nb, b)\\nif ret:\\n\\tprint('YES')\\n\\tPrintAns(ans)\\nelse:\\n\\tprint('NO')\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a scenario where monsters in a queue eat each other based on weight and position. The goal is to determine if a given final queue of monsters could result from the initial queue and, if so, to provide a sequence of eating actions.\\n- Identifying Constraints: A monster can only eat a neighbor if it is strictly heavier. When a monster eats another, its weight increases by the eaten monster's weight, and the queue length decreases.\\n- Devising a Strategy: The overall strategy is to check whether the sum of initial weights equals the sum of final weights. If not, it's impossible to reach the final state. If the sums are equal, attempt to reconstruct the eating sequence or determine that it's impossible. The judge function aims to break down the initial queue into sub-queues whose sums equal the final weights. The PrintAns function finds the largest monster (with preference to those with neighbors it can eat) and has it eat its neighbors until each sub-queue boils down to a single monster in the final queue.\\n- Implementation Details: The code includes functions to judge the possibility of reaching the final state, to construct the eating sequence, and to print the sequence of eatings in the required format.\\n- Potential Pitfalls: Edge cases, such as all monsters in a sub-queue having the same weights which can loop indefinitely.\",\n  \"LLM Questions\": [\n    \"How can you verify if the given final queue is reachable from the initial queue?\",\n    \"What conditions must be met for a monster to eat another monster?\",\n    \"How do you decide which monster should eat, especially when multiple options are available?\",\n    \"How does the eating process change the queue's composition and monster indexing?\",\n    \"What kind of edge cases can make it impossible to reach a final queue, even if the total weight is conserved?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"First, you must verify if the sum of the weights of the monsters in the initial queue is equal to the sum of the weights of the monsters in the final queue. If these sums are not equal, the final queue is unreachable. If they are equal, you must attempt to reverse the eating process, which involves finding a sequence of eatings that transforms the initial queue into the final queue.\",\n    \"A monster can eat another monster only if the following two conditions are met: the monster's weight must be strictly greater than the weight of the monster being eaten, and they must be neighbors in the queue.\",\n    \"When deciding which monster should eat, prioritize the monster with the largest weight in a segment of the queue that sums to a final value. If there are multiple largest monsters, prioritize the monster that can eat either its left or right neighbor.\",\n    \"Each time a monster eats another, the queue decreases in length by one. The eating monster's weight increases by the weight of the eaten monster. The indexes of the monsters to the right of the eaten monster shift one position to the left.\",\n    \"An edge case that can make it impossible is a sub-queue of monsters having the same weights, that sums to a final monster weight. Since each monster has the same weight, it can create an infinite loop of eating and can never boil down to the expected single number in the final queue.\"\n  ]\n}\n```"