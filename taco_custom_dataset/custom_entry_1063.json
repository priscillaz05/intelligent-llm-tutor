"```json\n{\n  \"Coding Problem\": \"You are given an array a of length 2n. Consider a partition of array a into two subsequences p and q of length n each (each element of array a should be in exactly one subsequence: either in p or in q).\\n\\nLet's sort p in non-decreasing order, and q in non-increasing order, we can denote the sorted versions by x and y, respectively. Then the cost of a partition is defined as f(p, q) = \u2211_{i = 1}^n |x_i - y_i|.\\n\\nFind the sum of f(p, q) over all correct partitions of array a. Since the answer might be too big, print its remainder modulo 998244353.\\n\\nInput\\n\\nThe first line contains a single integer n (1 \u2264 n \u2264 150 000).\\n\\nThe second line contains 2n integers a_1, a_2, \u2026, a_{2n} (1 \u2264 a_i \u2264 10^9) \u2014 elements of array a.\\n\\nOutput\\n\\nPrint one integer \u2014 the answer to the problem, modulo 998244353.\\n\\nExamples\\n\\nInput\\n\\n\\n1\\n1 4\\n\\n\\nOutput\\n\\n\\n6\\n\\nInput\\n\\n\\n2\\n2 1 2 1\\n\\n\\nOutput\\n\\n\\n12\\n\\nInput\\n\\n\\n3\\n2 2 2 2 2 2\\n\\n\\nOutput\\n\\n\\n0\\n\\nInput\\n\\n\\n5\\n13 8 35 94 9284 34 54 69 123 846\\n\\n\\nOutput\\n\\n\\n2588544\\n\\nNote\\n\\nTwo partitions of an array are considered different if the sets of indices of elements included in the subsequence p are different.\\n\\nIn the first example, there are two correct partitions of the array a:\\n\\n  1. p = [1], q = [4], then x = [1], y = [4], f(p, q) = |1 - 4| = 3; \\n  2. p = [4], q = [1], then x = [4], y = [1], f(p, q) = |4 - 1| = 3. \\n\\n\\n\\nIn the second example, there are six valid partitions of the array a: \\n\\n  1. p = [2, 1], q = [2, 1] (elements with indices 1 and 2 in the original array are selected in the subsequence p); \\n  2. p = [2, 2], q = [1, 1]; \\n  3. p = [2, 1], q = [1, 2] (elements with indices 1 and 4 are selected in the subsequence p); \\n  4. p = [1, 2], q = [2, 1]; \\n  5. p = [1, 1], q = [2, 2]; \\n  6. p = [2, 1], q = [2, 1] (elements with indices 3 and 4 are selected in the subsequence p).\\n\",\n  \"Ground Truth Solution\": \"def ncr(n, r, p):\\n\\tnum = den = 1\\n\\tfor i in range(r):\\n\\t\\tnum = num * (n - i) % p\\n\\t\\tden = den * (i + 1) % p\\n\\treturn num * pow(den, p - 2, p) % p\\nn = int(input())\\na = sorted(list(map(int, input().split())))\\nans = 0\\nfor i in range(n):\\n\\tans += abs(a[i] - a[2 * n - 1 - i])\\nfac = ncr(2 * n, n, 998244353)\\nprint(fac * ans % 998244353)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem Requirements: Recognize that the array of length 2n needs to be partitioned into two subsequences p and q each of length n. The subsequences p and q are then sorted in non-decreasing and non-increasing order, respectively, denoted by x and y. The cost of partition f(p, q) is the sum of absolute differences between corresponding elements in x and y.\\n- Identifying Key Calculation Components: The task is to calculate the sum of f(p, q) over all possible correct partitions. This involves calculating the cost for each possible partition and summing them up modulo 998244353.\\n- Choosing an Algorithmic Strategy: The core observation is that sorting the original array `a` allows us to pair the smallest element with the largest, the second smallest with the second largest, and so on. The sum of absolute differences of these pairs constitutes a base value. Then, we need to multiply this value by the number of possible partitions which is given by the binomial coefficient C(2n, n), which can be calculated by nCr where n = 2n and r = n.\\n- Implementation Details: Ensure that the array `a` is sorted before calculating the differences. Implement the binomial coefficient calculation efficiently, using modular arithmetic to avoid overflow and satisfy the modulo constraint. Use Fermat's Little Theorem to compute the modular inverse for calculating nCr.\\n- Optimizations and Edge Cases: Check the constraints (1 \u2264 n \u2264 150000 and 1 \u2264 a_i \u2264 10^9). Consider the case where all a_i are the same; in such cases, the answer would be 0 because the differences would be 0.\",\n  \"LLM Questions\": [\n    \"What is a correct partition in the context of this problem, and how does it affect the calculation of f(p, q)?\",\n    \"How can you efficiently calculate the number of possible partitions of the array, and why is this important for the overall solution?\",\n    \"Given that the answer should be modulo 998244353, how does modular arithmetic play a crucial role in preventing overflow and ensuring the correctness of your calculations?\",\n    \"Can you explain the core insight that allows us to simplify the calculation of the sum of absolute differences by sorting the array and pairing the elements appropriately?\",\n    \"How does Fermat's Little Theorem help in calculating the modular inverse, and why is the modular inverse needed for computing the binomial coefficient?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A correct partition divides the original array into two subsequences p and q, each of length n, where every element from the original array belongs to exactly one subsequence. This partition defines the two sorted arrays x and y used in computing the cost f(p, q).\",\n    \"The number of possible partitions is given by the binomial coefficient C(2n, n), which represents the number of ways to choose n elements from a set of 2n elements. This value is crucial because the sum of differences we calculate needs to be multiplied by the number of such partitions.\",\n    \"Modular arithmetic is essential because the intermediate and final results can become very large, potentially leading to overflow. By applying the modulo operation (998244353) at each step, we ensure that the results remain within manageable bounds without affecting the final answer's correctness.\",\n    \"Sorting the array allows us to pair the smallest element with the largest, the second smallest with the second largest, and so on. The sum of absolute differences between these pairs gives us the total difference that needs to be multiplied by the number of partitions.\",\n    \"Fermat's Little Theorem states that if p is a prime number, then for any integer a not divisible by p, a^(p-1) is congruent to 1 modulo p.  The modular inverse of a number 'a' modulo 'p' is a^(p-2) mod p. This inverse is necessary for calculating the binomial coefficient C(n, r) = n! / (r! * (n-r)!), as division in modular arithmetic is performed by multiplying with the modular inverse.\"\n  ]\n}\n```"