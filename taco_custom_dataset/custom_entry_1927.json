"```json\n{\n  \"Coding Problem\": \"You have two friends. You want to present each of them several positive integers. You want to present cnt_1 numbers to the first friend and cnt_2 numbers to the second friend. Moreover, you want all presented numbers to be distinct, that also means that no number should be presented to both friends.\\n\\nIn addition, the first friend does not like the numbers that are divisible without remainder by prime number x. The second one does not like the numbers that are divisible without remainder by prime number y. Of course, you're not going to present your friends numbers they don't like.\\n\\nYour task is to find such minimum number v, that you can form presents using numbers from a set 1, 2, ..., v. Of course you may choose not to present some numbers at all.\\n\\nA positive integer number greater than 1 is called prime if it has no positive divisors other than 1 and itself.\\n\\n\\n-----Input-----\\n\\nThe only line contains four positive integers cnt_1, cnt_2, x, y (1 \u2264 cnt_1, cnt_2 < 10^9; cnt_1 + cnt_2 \u2264 10^9; 2 \u2264 x < y \u2264 3\u00b710^4)\u00a0\u2014 the numbers that are described in the statement. It is guaranteed that numbers x, y are prime.\\n\\n\\n-----Output-----\\n\\nPrint a single integer \u2014 the answer to the problem.\\n\\n\\n-----Examples-----\\nInput\\n3 1 2 3\\n\\nOutput\\n5\\n\\nInput\\n1 3 2 3\\n\\nOutput\\n4\\n\\n\\n-----Note-----\\n\\nIn the first sample you give the set of numbers {1, 3, 5} to the first friend and the set of numbers {2} to the second friend. Note that if you give set {1, 3, 5} to the first friend, then we cannot give any of the numbers 1, 3, 5 to the second friend. \\n\\nIn the second sample you give the set of numbers {3} to the first friend, and the set of numbers {1, 2, 4} to the second friend. Thus, the answer to the problem is 4.\",\n  \"Ground Truth Solution\": \"(c1, c2, x, y) = list(map(int, input().split()))\\n\\ndef get(n):\\n\\tif n - n // (x * y) >= c1 + c2 and n - n // x >= c1 and (n - n // y >= c2):\\n\\t\\treturn True\\n\\telse:\\n\\t\\treturn False\\nl = 0\\nr = c1 * x + c2 * y\\nwhile r - l > 1:\\n\\tm = (l + r) // 2\\n\\tif get(m):\\n\\t\\tr = m\\n\\telse:\\n\\t\\tl = m\\nprint(r)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires finding the minimum integer 'v' such that we can allocate 'cnt_1' distinct integers to the first friend (not divisible by 'x') and 'cnt_2' distinct integers to the second friend (not divisible by 'y'), from the range 1 to 'v'.\\n- Key Constraints: The problem has constraints on distinct numbers and divisibility rules. Numbers should be distinct across both friends, and each friend has numbers they don't like (divisible by their respective prime numbers).\\n- Algorithmic Approach: A binary search approach can be applied to efficiently find the minimum 'v'. We search for 'v' in the range [0, c1*x + c2*y].\\n- Binary Search Condition: For a given 'v', we check if it's possible to allocate the numbers as required. The condition involves checking if 'v' minus numbers divisible by both 'x' and 'y' is greater than or equal to the total number of presents (cnt_1 + cnt_2). Also, 'v' minus the numbers divisible by 'x' should be at least 'cnt_1' and 'v' minus the numbers divisible by 'y' should be at least 'cnt_2'.\\n- Optimization: Correctly calculating the counts using integer division (n // x) to determine the number of multiples of x within 'n'.\",\n  \"LLM Questions\": [\n    \"What is the range within which the minimum value 'v' can be found, and how can you determine that range?\",\n    \"How can you verify if a given value 'v' is a valid solution, ensuring that both friends receive the desired number of presents and the divisibility constraints are met?\",\n    \"Can you explain the significance of using n // x to calculate the number of integers divisible by 'x' within the range [1, n]?\",\n    \"Why is binary search an efficient approach for solving this problem, and what are the time complexity implications?\",\n    \"What are the edge cases or potential pitfalls that should be considered when implementing the binary search and checking the validity of a given 'v'?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The minimum value 'v' can be found within the range [0, c1*x + c2*y]. The upper bound is derived from a simple allocation scheme where we prioritize giving multiples of 'x' to the second friend and multiples of 'y' to the first friend.\",\n    \"To verify if a given 'v' is a valid solution, you need to check three conditions: 1) v - v // (x * y) >= cnt_1 + cnt_2, 2) v - v // x >= cnt_1, and 3) v - v // y >= cnt_2. These conditions ensure that there are enough valid numbers for both friends considering the divisibility constraints.\",\n    \"Using n // x gives the integer part of the division, which represents the number of multiples of 'x' present in the range [1, n]. This is important because it accurately tells us how many numbers are divisible by 'x', which the first friend doesn't like.\",\n    \"Binary search is efficient because it reduces the search space by half at each step, resulting in a logarithmic time complexity (O(log N)). It's suitable for this problem because the feasibility condition for 'v' is monotonic; if 'v' works, any 'v' greater than that will also work.\",\n    \"Edge cases or potential pitfalls include ensuring the binary search is implemented correctly (e.g., handling the 'l' and 'r' updates), correctly accounting for the number of integers divisible by 'x', 'y', and both 'x' and 'y', and handling cases where no solution exists (though the problem guarantees a solution exists).\"\n  ]\n}\n```"