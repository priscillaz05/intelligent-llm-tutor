"```json\n{\n  \"Coding Problem\": \"You are given a sequence A, where its elements are either in the form + x or -, where x is an integer.\\n\\nFor such a sequence S where its elements are either in the form + x or -, define f(S) as follows:\\n\\n  * iterate through S's elements from the first one to the last one, and maintain a multiset T as you iterate through it. \\n  * for each element, if it's in the form + x, add x to T; otherwise, erase the smallest element from T (if T is empty, do nothing). \\n  * after iterating through all S's elements, compute the sum of all elements in T. f(S) is defined as the sum. \\n\\nThe sequence b is a subsequence of the sequence a if b can be derived from a by removing zero or more elements without changing the order of the remaining elements. For all A's subsequences B, compute the sum of f(B), modulo 998 244 353.\\n\\nInput\\n\\nThe first line contains an integer n (1\u2264 n\u2264 500) \u2014 the length of A.\\n\\nEach of the next n lines begins with an operator + or -. If the operator is +, then it's followed by an integer x (1\u2264 x<998 244 353). The i-th line of those n lines describes the i-th element in A.\\n\\nOutput\\n\\nPrint one integer, which is the answer to the problem, modulo 998 244 353.\\n\\nExamples\\n\\nInput\\n\\n\\n4\\n-\\n+ 1\\n+ 2\\n-\\n\\n\\nOutput\\n\\n\\n16\\n\\nInput\\n\\n\\n15\\n+ 2432543\\n-\\n+ 4567886\\n+ 65638788\\n-\\n+ 578943\\n-\\n-\\n+ 62356680\\n-\\n+ 711111\\n-\\n+ 998244352\\n-\\n-\\n\\n\\nOutput\\n\\n\\n750759115\\n\\nNote\\n\\nIn the first example, the following are all possible pairs of B and f(B):\\n\\n  * B= {}, f(B)=0. \\n  * B= {-}, f(B)=0. \\n  * B= {+ 1, -}, f(B)=0. \\n  * B= {-, + 1, -}, f(B)=0. \\n  * B= {+ 2, -}, f(B)=0. \\n  * B= {-, + 2, -}, f(B)=0. \\n  * B= {-}, f(B)=0. \\n  * B= {-, -}, f(B)=0. \\n  * B= {+ 1, + 2}, f(B)=3. \\n  * B= {+ 1, + 2, -}, f(B)=2. \\n  * B= {-, + 1, + 2}, f(B)=3. \\n  * B= {-, + 1, + 2, -}, f(B)=2. \\n  * B= {-, + 1}, f(B)=1. \\n  * B= {+ 1}, f(B)=1. \\n  * B= {-, + 2}, f(B)=2. \\n  * B= {+ 2}, f(B)=2. \\n\\n\\nThe sum of these values is 16.\",\n  \"Ground Truth Solution\": \"MOD = 998244353\\n\\ndef solve():\\n\\tn = int(input())\\n\\tans = 0\\n\\tarr = []\\n\\tfor i in range(n):\\n\\t\\ta = list(input().split())\\n\\t\\tif len(a) == 2:\\n\\t\\t\\tarr.append(int(a[1]))\\n\\t\\telse:\\n\\t\\t\\tarr.append(0)\\n\\tfor cur in range(n):\\n\\t\\tif arr[cur]:\\n\\t\\t\\tdp = [0] * (n + 1)\\n\\t\\t\\tdp[0] = 1\\n\\t\\t\\tfor (j, a) in enumerate(arr):\\n\\t\\t\\t\\tif j == cur:\\n\\t\\t\\t\\t\\tdp = [0] + dp[:n]\\n\\t\\t\\t\\telif a == 0:\\n\\t\\t\\t\\t\\tdp[0] = (2 * dp[0] + dp[1]) % MOD\\n\\t\\t\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\t\\t\\tdp[i] = (dp[i] + dp[i + 1]) % MOD\\n\\t\\t\\t\\telif a < arr[cur] or (a == arr[cur] and j < cur):\\n\\t\\t\\t\\t\\tif j < cur:\\n\\t\\t\\t\\t\\t\\tfor i in range(n, 0, -1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = (dp[i - 1] + dp[i]) % MOD\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tfor i in range(n, 1, -1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i] = (dp[i - 1] + dp[i]) % MOD\\n\\t\\t\\t\\t\\t\\tdp[0] = dp[0] * 2 % MOD\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp = [d * 2 % MOD for d in dp]\\n\\t\\t\\tans = (ans + (sum(dp) - dp[0]) * arr[cur]) % MOD\\n\\treturn ans\\nimport sys\\ninput = lambda : sys.stdin.readline().rstrip()\\nprint(solve())\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires calculating the sum of f(B) for all subsequences B of a given sequence A. f(B) is defined as the sum of elements in a multiset T after iterating through B. If an element is '+ x', add x to T; if it's '-', remove the smallest element from T.\\n- Identifying the Core Logic: The key is to iterate through all possible subsequences and calculate f(B) for each one, then sum those values modulo 998244353.\\n- Optimizing the Subsequence Generation: Generating all subsequences directly would be inefficient. Dynamic programming can be leveraged to avoid explicitly generating and iterating through each subsequence. Instead, focus on counting how many times each '+ x' contributes to the final sum across all subsequences.\\n- Developing a Dynamic Programming Approach: For each '+ x', count the number of subsequences that include it and have more '+ y' (where y < x) than '-' before it. Then calculate the contribution of that '+ x' as the number of such subsequences times x.  For each '+ x' at position i, consider subsequences that include it, and the cases where x will be present in the final multiset T.\\n- Handling the Modulo: Apply the modulo operator after each arithmetic operation to prevent overflow.\",\n  \"LLM Questions\": [\n    \"How can we generate all possible subsequences of the given sequence?\",\n    \"How can we calculate f(S) for a given sequence S efficiently?\",\n    \"How to optimize the subsequence generation process to avoid timeouts?\",\n    \"How to determine if a specific '+ x' element will contribute to the final sum?\",\n    \"Given that we need to calculate the result modulo 998244353, how do we handle the modulo operations throughout the calculations?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Subsequences can be generated recursively by either including or excluding each element of the original sequence.\",\n    \"Iterate through the sequence S, maintain a multiset T, and follow the given rules (+x adds x to T, - removes the smallest element). The sum of the elements in T after processing S is f(S).\",\n    \"Dynamic programming can be used to count the number of relevant subsequences without generating them explicitly, thus preventing timeouts.\",\n    \"A '+ x' element will contribute to the final sum if, in the subsequence considered, it is not 'canceled out' by '-' operations. The number of preceding '+' elements larger than or equal to x, must exceed the number of preceding '-' operations.\",\n    \"Apply the modulo operator (%) after each addition, subtraction, and multiplication to keep the intermediate results within the modulo range and prevent integer overflow.\"\n  ]\n}\n```"