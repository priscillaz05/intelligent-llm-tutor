"```json\n{\n  \"Coding Problem\": \"Monk visits the land of Islands.  There are a total of N islands numbered from 1 to N.  Some pairs of islands are connected to each other by Bidirectional bridges running over water.\\nMonk hates to cross these bridges as they require a lot of efforts. He is standing at Island #1 and wants to reach the Island #N. Find the minimum the number of bridges that he shall have to cross, if he takes the optimal route.   \\n\\nInput:\\nFirst line contains T. T testcases follow.\\nFirst line of each test case contains two space-separated integers N, M.\\nEach of the next M lines contains two space-separated integers X and Y , denoting that there is a bridge between Island X and Island Y.  \\n\\nOutput:\\nPrint the answer to each test case in a new line.\\n\\nConstraints:\\n1 \u2264 T \u2264 10\\n1 \u2264 N \u2264 10^4\\n1 \u2264 M \u2264 10^5\\n1 \u2264 X, Y \u2264 N\\n\\nSAMPLE INPUT\\n2\\n3 2\\n1 2\\n2 3\\n4 4\\n1 2\\n2 3\\n3 4\\n4 2\\n\\nSAMPLE OUTPUT\\n2\\n2\",\n  \"Ground Truth Solution\": \"from collections import deque\\n\\n#code to fin level of a node\\nt = int(input())\\nwhile t>0:\\n\\tnodes,edges = list(map(int,input().split()))\\n\\t\\n\\tvisited = [False for i in range(nodes+1)]\\n\\t\\n\\tlevel = [0 for i in range(nodes+1)]\\n\\t\\n\\tdef bfs(graph,s):\\n\\t\\tq = deque()\\n\\t\\tq.append(s)\\n\\t\\tvisited[s] = True\\n\\t\\twhile len(q)!=0:\\n\\t\\t\\tp = q[0]\\n\\t\\t\\tq.popleft()\\n\\t\\t\\tfor i in range(len(graph[p])):\\n\\t\\t\\t\\tif visited[graph[p][i]] == False:\\n\\t\\t\\t\\t\\tlevel[graph[p][i]] = level[p] + 1\\n\\t\\t\\t\\t\\tq.append(graph[p][i])\\n\\t\\t\\t\\t\\tvisited[graph[p][i]] = True\\n\\t\\n\\t\\n\\t\\n\\tgraph = {}\\n\\t\\n\\tfor i in range(1,nodes+1):\\n\\t\\tgraph.update({i : []})\\n\\t\\n\\tfor i in range(edges):\\n\\t\\tx,y = list(map(int,input().split()))\\n\\t\\tgraph[x].append(y)\\n\\t\\tgraph[y].append(x)\\n\\t\\n\\t#connected  = 0\\n\\t\\n\\tbfs(graph,1)\\n\\t\\n\\tprint(level[nodes])\\t\\n\\tt-=1\\n#print connected\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The task is to find the minimum number of bridges Monk needs to cross to reach Island N from Island 1. This is a shortest path problem on a graph where islands are nodes and bridges are edges.\\n- Data Structures: Represent the islands and bridges using a graph data structure. An adjacency list is suitable for storing the connections between islands.\\n- Algorithm Selection: Breadth-First Search (BFS) is an ideal algorithm for finding the shortest path in an unweighted graph. BFS explores the graph layer by layer, ensuring that the first time a node is reached, it's through the shortest path.\\n- Implementation Details: Use a queue to implement BFS. Keep track of visited islands to avoid cycles. The level of each island in the BFS tree will represent the minimum number of bridges needed to reach that island from Island 1.\",\n  \"LLM Questions\": [\n    \"How should the graph be represented, and why is an adjacency list a good choice?\",\n    \"Why is BFS suitable for finding the shortest path in this problem?\",\n    \"How do you handle multiple test cases efficiently?\",\n    \"How do you keep track of the number of bridges crossed to reach each island?\",\n    \"What are the potential edge cases, and how would they affect the solution?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The graph can be represented using an adjacency list where each island (node) is associated with a list of its neighboring islands. An adjacency list is efficient because it only stores the actual edges present in the graph.\",\n    \"BFS guarantees finding the shortest path in an unweighted graph because it explores the graph layer by layer. This ensures that when an island is first visited, it is reached via the path with the fewest bridges.\",\n    \"To handle multiple test cases, loop through the test cases, reading the input and solving the problem independently for each case. Clear data structures (graph, visited array, level array) at the beginning of each test case.\",\n    \"During BFS, maintain a 'level' or 'distance' array that stores the number of bridges crossed to reach each island from the starting island (Island 1). Each time you move to a neighboring island, increment the level by 1.\",\n    \"Edge cases include: Island N not being reachable from Island 1 (in which case BFS will not visit Island N), and the graph being empty or having only one island (handle these cases by returning 0 if N is 1 or Island N is not reachable).\"\n  ]\n}\n```"