"```json\n{\n  \"Coding Problem\": \"You are given an undirected graph with n vertices. There are no edge-simple cycles with the even length in it. In other words, there are no cycles of even length that pass each edge at most once. Let's enumerate vertices from 1 to n. \\n\\nYou have to answer q queries. Each query is described by a segment of vertices [l; r], and you have to count the number of its subsegments [x; y] (l \u2264 x \u2264 y \u2264 r), such that if we delete all vertices except the segment of vertices [x; y] (including x and y) and edges between them, the resulting graph is bipartite.\\n\\nInput\\n\\nThe first line contains two integers n and m (1 \u2264 n \u2264 3\u00b7105, 1 \u2264 m \u2264 3\u00b7105) \u2014 the number of vertices and the number of edges in the graph.\\n\\nThe next m lines describe edges in the graph. The i-th of these lines contains two integers ai and bi (1 \u2264 ai, bi \u2264 n; ai \u2260 bi), denoting an edge between vertices ai and bi. It is guaranteed that this graph does not contain edge-simple cycles of even length.\\n\\nThe next line contains a single integer q (1 \u2264 q \u2264 3\u00b7105) \u2014 the number of queries.\\n\\nThe next q lines contain queries. The i-th of these lines contains two integers li and ri (1 \u2264 li \u2264 ri \u2264 n) \u2014 the query parameters.\\n\\nOutput\\n\\nPrint q numbers, each in new line: the i-th of them should be the number of subsegments [x; y] (li \u2264 x \u2264 y \u2264 ri), such that the graph that only includes vertices from segment [x; y] and edges between them is bipartite.\\n\\nExamples\\n\\nInput\\n\\n6 6\\n1 2\\n2 3\\n3 1\\n4 5\\n5 6\\n6 4\\n3\\n1 3\\n4 6\\n1 6\\n\\n\\nOutput\\n\\n5\\n5\\n14\\n\\n\\nInput\\n\\n8 9\\n1 2\\n2 3\\n3 1\\n4 5\\n5 6\\n6 7\\n7 8\\n8 4\\n7 2\\n3\\n1 8\\n1 4\\n3 8\\n\\n\\nOutput\\n\\n27\\n8\\n19\\n\\nNote\\n\\nThe first example is shown on the picture below:\\n\\n<image>\\n\\nFor the first query, all subsegments of [1; 3], except this segment itself, are suitable.\\n\\nFor the first query, all subsegments of [4; 6], except this segment itself, are suitable.\\n\\nFor the third query, all subsegments of [1; 6] are suitable, except [1; 3], [1; 4], [1; 5], [1; 6], [2; 6], [3; 6], [4; 6].\\n\\nThe second example is shown on the picture below:\\n\\n<image>\",\n  \"Ground Truth Solution\": \"def divisors(M):\\n\\td = []\\n\\ti = 1\\n\\twhile M >= i ** 2:\\n\\t\\tif M % i == 0:\\n\\t\\t\\td.append(i)\\n\\t\\t\\tif i ** 2 != M:\\n\\t\\t\\t\\td.append(M // i)\\n\\t\\ti = i + 1\\n\\treturn d\\n\\ndef popcount(x):\\n\\tx = x - (x >> 1 & 1431655765)\\n\\tx = (x & 858993459) + (x >> 2 & 858993459)\\n\\tx = x + (x >> 4) & 252645135\\n\\tx = x + (x >> 8)\\n\\tx = x + (x >> 16)\\n\\treturn x & 127\\n\\ndef eratosthenes(n):\\n\\tres = [0 for i in range(n + 1)]\\n\\tprime = set([])\\n\\tfor i in range(2, n + 1):\\n\\t\\tif not res[i]:\\n\\t\\t\\tprime.add(i)\\n\\t\\t\\tfor j in range(1, n // i + 1):\\n\\t\\t\\t\\tres[i * j] = 1\\n\\treturn prime\\n\\ndef factorization(n):\\n\\tres = []\\n\\tfor p in prime:\\n\\t\\tif n % p == 0:\\n\\t\\t\\twhile n % p == 0:\\n\\t\\t\\t\\tn //= p\\n\\t\\t\\tres.append(p)\\n\\tif n != 1:\\n\\t\\tres.append(n)\\n\\treturn res\\n\\ndef euler_phi(n):\\n\\tres = n\\n\\tfor x in range(2, n + 1):\\n\\t\\tif x ** 2 > n:\\n\\t\\t\\tbreak\\n\\t\\tif n % x == 0:\\n\\t\\t\\tres = res // x * (x - 1)\\n\\t\\t\\twhile n % x == 0:\\n\\t\\t\\t\\tn //= x\\n\\tif n != 1:\\n\\t\\tres = res // n * (n - 1)\\n\\treturn res\\n\\ndef ind(b, n):\\n\\tres = 0\\n\\twhile n % b == 0:\\n\\t\\tres += 1\\n\\t\\tn //= b\\n\\treturn res\\n\\ndef isPrimeMR(n):\\n\\td = n - 1\\n\\td = d // (d & -d)\\n\\tL = [2, 3, 5, 7, 11, 13, 17]\\n\\tfor a in L:\\n\\t\\tt = d\\n\\t\\ty = pow(a, t, n)\\n\\t\\tif y == 1:\\n\\t\\t\\tcontinue\\n\\t\\twhile y != n - 1:\\n\\t\\t\\ty = y * y % n\\n\\t\\t\\tif y == 1 or t == n - 1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tt <<= 1\\n\\treturn 1\\n\\ndef findFactorRho(n):\\n\\tfrom math import gcd\\n\\tm = 1 << n.bit_length() // 8\\n\\tfor c in range(1, 99):\\n\\t\\tf = lambda x: (x * x + c) % n\\n\\t\\t(y, r, q, g) = (2, 1, 1, 1)\\n\\t\\twhile g == 1:\\n\\t\\t\\tx = y\\n\\t\\t\\tfor i in range(r):\\n\\t\\t\\t\\ty = f(y)\\n\\t\\t\\tk = 0\\n\\t\\t\\twhile k < r and g == 1:\\n\\t\\t\\t\\tys = y\\n\\t\\t\\t\\tfor i in range(min(m, r - k)):\\n\\t\\t\\t\\t\\ty = f(y)\\n\\t\\t\\t\\t\\tq = q * abs(x - y) % n\\n\\t\\t\\t\\tg = gcd(q, n)\\n\\t\\t\\t\\tk += m\\n\\t\\t\\tr <<= 1\\n\\t\\tif g == n:\\n\\t\\t\\tg = 1\\n\\t\\t\\twhile g == 1:\\n\\t\\t\\t\\tys = f(ys)\\n\\t\\t\\t\\tg = gcd(abs(x - ys), n)\\n\\t\\tif g < n:\\n\\t\\t\\tif isPrimeMR(g):\\n\\t\\t\\t\\treturn g\\n\\t\\t\\telif isPrimeMR(n // g):\\n\\t\\t\\t\\treturn n // g\\n\\t\\t\\treturn findFactorRho(g)\\n\\ndef primeFactor(n):\\n\\ti = 2\\n\\tret = {}\\n\\trhoFlg = 0\\n\\twhile i * i <= n:\\n\\t\\tk = 0\\n\\t\\twhile n % i == 0:\\n\\t\\t\\tn //= i\\n\\t\\t\\tk += 1\\n\\t\\tif k:\\n\\t\\t\\tret[i] = k\\n\\t\\ti += 1 + i % 2\\n\\t\\tif i == 101 and n >= 2 ** 20:\\n\\t\\t\\twhile n > 1:\\n\\t\\t\\t\\tif isPrimeMR(n):\\n\\t\\t\\t\\t\\t(ret[n], n) = (1, 1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\trhoFlg = 1\\n\\t\\t\\t\\t\\tj = findFactorRho(n)\\n\\t\\t\\t\\t\\tk = 0\\n\\t\\t\\t\\t\\twhile n % j == 0:\\n\\t\\t\\t\\t\\t\\tn //= j\\n\\t\\t\\t\\t\\t\\tk += 1\\n\\t\\t\\t\\t\\tret[j] = k\\n\\tif n > 1:\\n\\t\\tret[n] = 1\\n\\tif rhoFlg:\\n\\t\\tret = {x: ret[x] for x in sorted(ret)}\\n\\treturn ret\\n\\ndef divisors(n):\\n\\tres = [1]\\n\\tprime = primeFactor(n)\\n\\tfor p in prime:\\n\\t\\tnewres = []\\n\\t\\tfor d in res:\\n\\t\\t\\tfor j in range(prime[p] + 1):\\n\\t\\t\\t\\tnewres.append(d * p ** j)\\n\\t\\tres = newres\\n\\tres.sort()\\n\\treturn res\\n\\ndef xorfactorial(num):\\n\\tif num == 0:\\n\\t\\treturn 0\\n\\telif num == 1:\\n\\t\\treturn 1\\n\\telif num == 2:\\n\\t\\treturn 3\\n\\telif num == 3:\\n\\t\\treturn 0\\n\\telse:\\n\\t\\tx = baseorder(num)\\n\\t\\treturn 2 ** x * ((num - 2 ** x + 1) % 2) + function(num - 2 ** x)\\n\\ndef xorconv(n, X, Y):\\n\\tif n == 0:\\n\\t\\tres = [X[0] * Y[0] % mod]\\n\\t\\treturn res\\n\\tx = [X[i] + X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\\n\\ty = [Y[i] + Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\\n\\tz = [X[i] - X[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\\n\\tw = [Y[i] - Y[i + 2 ** (n - 1)] for i in range(2 ** (n - 1))]\\n\\tres1 = xorconv(n - 1, x, y)\\n\\tres2 = xorconv(n - 1, z, w)\\n\\tformer = [(res1[i] + res2[i]) * inv for i in range(2 ** (n - 1))]\\n\\tlatter = [(res1[i] - res2[i]) * inv for i in range(2 ** (n - 1))]\\n\\tformer = list(map(lambda x: x % mod, former))\\n\\tlatter = list(map(lambda x: x % mod, latter))\\n\\treturn former + latter\\n\\ndef merge_sort(A, B):\\n\\t(pos_A, pos_B) = (0, 0)\\n\\t(n, m) = (len(A), len(B))\\n\\tres = []\\n\\twhile pos_A < n and pos_B < m:\\n\\t\\t(a, b) = (A[pos_A], B[pos_B])\\n\\t\\tif a < b:\\n\\t\\t\\tres.append(a)\\n\\t\\t\\tpos_A += 1\\n\\t\\telse:\\n\\t\\t\\tres.append(b)\\n\\t\\t\\tpos_B += 1\\n\\tres += A[pos_A:]\\n\\tres += B[pos_B:]\\n\\treturn res\\n\\nclass UnionFindVerSize:\\n\\n\\tdef __init__(self, N):\\n\\t\\tself._parent = [n for n in range(0, N)]\\n\\t\\tself._size = [1] * N\\n\\t\\tself.group = N\\n\\n\\tdef find_root(self, x):\\n\\t\\tif self._parent[x] == x:\\n\\t\\t\\treturn x\\n\\t\\tself._parent[x] = self.find_root(self._parent[x])\\n\\t\\tstack = [x]\\n\\t\\twhile self._parent[stack[-1]] != stack[-1]:\\n\\t\\t\\tstack.append(self._parent[stack[-1]])\\n\\t\\tfor v in stack:\\n\\t\\t\\tself._parent[v] = stack[-1]\\n\\t\\treturn self._parent[x]\\n\\n\\tdef unite(self, x, y):\\n\\t\\tgx = self.find_root(x)\\n\\t\\tgy = self.find_root(y)\\n\\t\\tif gx == gy:\\n\\t\\t\\treturn\\n\\t\\tself.group -= 1\\n\\t\\tif self._size[gx] < self._size[gy]:\\n\\t\\t\\tself._parent[gx] = gy\\n\\t\\t\\tself._size[gy] += self._size[gx]\\n\\t\\telse:\\n\\t\\t\\tself._parent[gy] = gx\\n\\t\\t\\tself._size[gx] += self._size[gy]\\n\\n\\tdef get_size(self, x):\\n\\t\\treturn self._size[self.find_root(x)]\\n\\n\\tdef is_same_group(self, x, y):\\n\\t\\treturn self.find_root(x) == self.find_root(y)\\n\\nclass WeightedUnionFind:\\n\\n\\tdef __init__(self, N):\\n\\t\\tself.parent = [i for i in range(N)]\\n\\t\\tself.size = [1 for i in range(N)]\\n\\t\\tself.val = [0 for i in range(N)]\\n\\t\\tself.flag = True\\n\\t\\tself.edge = [[] for i in range(N)]\\n\\n\\tdef dfs(self, v, pv):\\n\\t\\tstack = [(v, pv)]\\n\\t\\tnew_parent = self.parent[pv]\\n\\t\\twhile stack:\\n\\t\\t\\t(v, pv) = stack.pop()\\n\\t\\t\\tself.parent[v] = new_parent\\n\\t\\t\\tfor (nv, w) in self.edge[v]:\\n\\t\\t\\t\\tif nv != pv:\\n\\t\\t\\t\\t\\tself.val[nv] = self.val[v] + w\\n\\t\\t\\t\\t\\tstack.append((nv, v))\\n\\n\\tdef unite(self, x, y, w):\\n\\t\\tif not self.flag:\\n\\t\\t\\treturn\\n\\t\\tif self.parent[x] == self.parent[y]:\\n\\t\\t\\tself.flag = self.val[x] - self.val[y] == w\\n\\t\\t\\treturn\\n\\t\\tif self.size[self.parent[x]] > self.size[self.parent[y]]:\\n\\t\\t\\tself.edge[x].append((y, -w))\\n\\t\\t\\tself.edge[y].append((x, w))\\n\\t\\t\\tself.size[x] += self.size[y]\\n\\t\\t\\tself.val[y] = self.val[x] - w\\n\\t\\t\\tself.dfs(y, x)\\n\\t\\telse:\\n\\t\\t\\tself.edge[x].append((y, -w))\\n\\t\\t\\tself.edge[y].append((x, w))\\n\\t\\t\\tself.size[y] += self.size[x]\\n\\t\\t\\tself.val[x] = self.val[y] + w\\n\\t\\t\\tself.dfs(x, y)\\n\\nclass Dijkstra:\\n\\n\\tclass Edge:\\n\\n\\t\\tdef __init__(self, _to, _cost):\\n\\t\\t\\tself.to = _to\\n\\t\\t\\tself.cost = _cost\\n\\n\\tdef __init__(self, V):\\n\\t\\tself.G = [[] for i in range(V)]\\n\\t\\tself._E = 0\\n\\t\\tself._V = V\\n\\n\\t@property\\n\\tdef E(self):\\n\\t\\treturn self._E\\n\\n\\t@property\\n\\tdef V(self):\\n\\t\\treturn self._V\\n\\n\\tdef add_edge(self, _from, _to, _cost):\\n\\t\\tself.G[_from].append(self.Edge(_to, _cost))\\n\\t\\tself._E += 1\\n\\n\\tdef shortest_path(self, s):\\n\\t\\timport heapq\\n\\t\\tque = []\\n\\t\\td = [10 ** 15] * self.V\\n\\t\\td[s] = 0\\n\\t\\theapq.heappush(que, (0, s))\\n\\t\\twhile len(que) != 0:\\n\\t\\t\\t(cost, v) = heapq.heappop(que)\\n\\t\\t\\tif d[v] < cost:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tfor i in range(len(self.G[v])):\\n\\t\\t\\t\\te = self.G[v][i]\\n\\t\\t\\t\\tif d[e.to] > d[v] + e.cost:\\n\\t\\t\\t\\t\\td[e.to] = d[v] + e.cost\\n\\t\\t\\t\\t\\theapq.heappush(que, (d[e.to], e.to))\\n\\t\\treturn d\\n\\ndef Z_algorithm(s):\\n\\tN = len(s)\\n\\tZ_alg = [0] * N\\n\\tZ_alg[0] = N\\n\\ti = 1\\n\\tj = 0\\n\\twhile i < N:\\n\\t\\twhile i + j < N and s[j] == s[i + j]:\\n\\t\\t\\tj += 1\\n\\t\\tZ_alg[i] = j\\n\\t\\tif j == 0:\\n\\t\\t\\ti += 1\\n\\t\\t\\tcontinue\\n\\t\\tk = 1\\n\\t\\twhile i + k < N and k + Z_alg[k] < j:\\n\\t\\t\\tZ_alg[i + k] = Z_alg[k]\\n\\t\\t\\tk += 1\\n\\t\\ti += k\\n\\t\\tj -= k\\n\\treturn Z_alg\\n\\nclass BIT:\\n\\n\\tdef __init__(self, n, mod=0):\\n\\t\\tself.BIT = [0] * (n + 1)\\n\\t\\tself.num = n\\n\\t\\tself.mod = mod\\n\\n\\tdef query(self, idx):\\n\\t\\tres_sum = 0\\n\\t\\tmod = self.mod\\n\\t\\twhile idx > 0:\\n\\t\\t\\tres_sum += self.BIT[idx]\\n\\t\\t\\tif mod:\\n\\t\\t\\t\\tres_sum %= mod\\n\\t\\t\\tidx -= idx & -idx\\n\\t\\treturn res_sum\\n\\n\\tdef update(self, idx, x):\\n\\t\\tmod = self.mod\\n\\t\\twhile idx <= self.num:\\n\\t\\t\\tself.BIT[idx] += x\\n\\t\\t\\tif mod:\\n\\t\\t\\t\\tself.BIT[idx] %= mod\\n\\t\\t\\tidx += idx & -idx\\n\\t\\treturn\\n\\nclass dancinglink:\\n\\n\\tdef __init__(self, n, debug=False):\\n\\t\\tself.n = n\\n\\t\\tself.debug = debug\\n\\t\\tself._left = [i - 1 for i in range(n)]\\n\\t\\tself._right = [i + 1 for i in range(n)]\\n\\t\\tself.exist = [True for i in range(n)]\\n\\n\\tdef pop(self, k):\\n\\t\\tif self.debug:\\n\\t\\t\\tassert self.exist[k]\\n\\t\\tL = self._left[k]\\n\\t\\tR = self._right[k]\\n\\t\\tif L != -1:\\n\\t\\t\\tif R != self.n:\\n\\t\\t\\t\\t(self._right[L], self._left[R]) = (R, L)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself._right[L] = self.n\\n\\t\\telif R != self.n:\\n\\t\\t\\tself._left[R] = -1\\n\\t\\tself.exist[k] = False\\n\\n\\tdef left(self, idx, k=1):\\n\\t\\tif self.debug:\\n\\t\\t\\tassert self.exist[idx]\\n\\t\\tres = idx\\n\\t\\twhile k:\\n\\t\\t\\tres = self._left[res]\\n\\t\\t\\tif res == -1:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tk -= 1\\n\\t\\treturn res\\n\\n\\tdef right(self, idx, k=1):\\n\\t\\tif self.debug:\\n\\t\\t\\tassert self.exist[idx]\\n\\t\\tres = idx\\n\\t\\twhile k:\\n\\t\\t\\tres = self._right[res]\\n\\t\\t\\tif res == self.n:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tk -= 1\\n\\t\\treturn res\\n\\nclass SparseTable:\\n\\n\\tdef __init__(self, A, merge_func, ide_ele):\\n\\t\\tN = len(A)\\n\\t\\tn = N.bit_length()\\n\\t\\tself.table = [[ide_ele for i in range(n)] for i in range(N)]\\n\\t\\tself.merge_func = merge_func\\n\\t\\tfor i in range(N):\\n\\t\\t\\tself.table[i][0] = A[i]\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tfor i in range(0, N - 2 ** j + 1):\\n\\t\\t\\t\\tf = self.table[i][j - 1]\\n\\t\\t\\t\\ts = self.table[i + 2 ** (j - 1)][j - 1]\\n\\t\\t\\t\\tself.table[i][j] = self.merge_func(f, s)\\n\\n\\tdef query(self, s, t):\\n\\t\\tb = t - s + 1\\n\\t\\tm = b.bit_length() - 1\\n\\t\\treturn self.merge_func(self.table[s][m], self.table[t - 2 ** m + 1][m])\\n\\nclass BinaryTrie:\\n\\n\\tclass node:\\n\\n\\t\\tdef __init__(self, val):\\n\\t\\t\\tself.left = None\\n\\t\\t\\tself.right = None\\n\\t\\t\\tself.max = val\\n\\n\\tdef __init__(self):\\n\\t\\tself.root = self.node(-10 ** 15)\\n\\n\\tdef append(self, key, val):\\n\\t\\tpos = self.root\\n\\t\\tfor i in range(29, -1, -1):\\n\\t\\t\\tpos.max = max(pos.max, val)\\n\\t\\t\\tif key >> i & 1:\\n\\t\\t\\t\\tif pos.right is None:\\n\\t\\t\\t\\t\\tpos.right = self.node(val)\\n\\t\\t\\t\\t\\tpos = pos.right\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpos = pos.right\\n\\t\\t\\telif pos.left is None:\\n\\t\\t\\t\\tpos.left = self.node(val)\\n\\t\\t\\t\\tpos = pos.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpos = pos.left\\n\\t\\tpos.max = max(pos.max, val)\\n\\n\\tdef search(self, M, xor):\\n\\t\\tres = -10 ** 15\\n\\t\\tpos = self.root\\n\\t\\tfor i in range(29, -1, -1):\\n\\t\\t\\tif pos is None:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tif M >> i & 1:\\n\\t\\t\\t\\tif xor >> i & 1:\\n\\t\\t\\t\\t\\tif pos.right:\\n\\t\\t\\t\\t\\t\\tres = max(res, pos.right.max)\\n\\t\\t\\t\\t\\tpos = pos.left\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif pos.left:\\n\\t\\t\\t\\t\\t\\tres = max(res, pos.left.max)\\n\\t\\t\\t\\t\\tpos = pos.right\\n\\t\\t\\telif xor >> i & 1:\\n\\t\\t\\t\\tpos = pos.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpos = pos.left\\n\\t\\tif pos:\\n\\t\\t\\tres = max(res, pos.max)\\n\\t\\treturn res\\n\\ndef solveequation(edge, ans, n, m):\\n\\tx = [0] * m\\n\\tused = [False] * n\\n\\tfor v in range(n):\\n\\t\\tif used[v]:\\n\\t\\t\\tcontinue\\n\\t\\ty = dfs(v)\\n\\t\\tif y != 0:\\n\\t\\t\\treturn False\\n\\treturn x\\n\\n\\tdef dfs(v):\\n\\t\\tused[v] = True\\n\\t\\tr = ans[v]\\n\\t\\tfor (to, dire, id) in edge[v]:\\n\\t\\t\\tif used[to]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\ty = dfs(to)\\n\\t\\t\\tif dire == -1:\\n\\t\\t\\t\\tx[id] = y\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx[id] = -y\\n\\t\\t\\tr += y\\n\\t\\treturn r\\n\\nclass SegmentTree:\\n\\n\\tdef __init__(self, init_val, segfunc, ide_ele):\\n\\t\\tn = len(init_val)\\n\\t\\tself.segfunc = segfunc\\n\\t\\tself.ide_ele = ide_ele\\n\\t\\tself.num = 1 << (n - 1).bit_length()\\n\\t\\tself.tree = [ide_ele] * 2 * self.num\\n\\t\\tself.size = n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tself.tree[self.num + i] = init_val[i]\\n\\t\\tfor i in range(self.num - 1, 0, -1):\\n\\t\\t\\tself.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\\n\\n\\tdef update(self, k, x):\\n\\t\\tk += self.num\\n\\t\\tself.tree[k] = x\\n\\t\\twhile k > 1:\\n\\t\\t\\tself.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\\n\\t\\t\\tk >>= 1\\n\\n\\tdef query(self, l, r):\\n\\t\\tif r == self.size:\\n\\t\\t\\tr = self.num\\n\\t\\tres = self.ide_ele\\n\\t\\tl += self.num\\n\\t\\tr += self.num\\n\\t\\twhile l < r:\\n\\t\\t\\tif l & 1:\\n\\t\\t\\t\\tres = self.segfunc(res, self.tree[l])\\n\\t\\t\\t\\tl += 1\\n\\t\\t\\tif r & 1:\\n\\t\\t\\t\\tres = self.segfunc(res, self.tree[r - 1])\\n\\t\\t\\tl >>= 1\\n\\t\\t\\tr >>= 1\\n\\t\\treturn res\\n\\n\\tdef bisect_l(self, l, r, x):\\n\\t\\tl += self.num\\n\\t\\tr += self.num\\n\\t\\tLmin = -1\\n\\t\\tRmin = -1\\n\\t\\twhile l < r:\\n\\t\\t\\tif l & 1:\\n\\t\\t\\t\\tif self.tree[l] <= x and Lmin == -1:\\n\\t\\t\\t\\t\\tLmin = l\\n\\t\\t\\t\\tl += 1\\n\\t\\t\\tif r & 1:\\n\\t\\t\\t\\tif self.tree[r - 1] <= x:\\n\\t\\t\\t\\t\\tRmin = r - 1\\n\\t\\t\\tl >>= 1\\n\\t\\t\\tr >>= 1\\n\\t\\tif Lmin != -1:\\n\\t\\t\\tpos = Lmin\\n\\t\\t\\twhile pos < self.num:\\n\\t\\t\\t\\tif self.tree[2 * pos] <= x:\\n\\t\\t\\t\\t\\tpos = 2 * pos\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpos = 2 * pos + 1\\n\\t\\t\\treturn pos - self.num\\n\\t\\telif Rmin != -1:\\n\\t\\t\\tpos = Rmin\\n\\t\\t\\twhile pos < self.num:\\n\\t\\t\\t\\tif self.tree[2 * pos] <= x:\\n\\t\\t\\t\\t\\tpos = 2 * pos\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpos = 2 * pos + 1\\n\\t\\t\\treturn pos - self.num\\n\\t\\telse:\\n\\t\\t\\treturn -1\\nimport sys, random, bisect\\nfrom collections import deque, defaultdict\\nfrom heapq import heapify, heappop, heappush\\nfrom itertools import permutations\\nfrom math import gcd, log\\nimport io, os\\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\\nmi = lambda : map(int, input().split())\\nli = lambda : list(mi())\\n(n, m) = mi()\\nedge = [[] for i in range(n)]\\nfor _ in range(m):\\n\\t(u, v) = mi()\\n\\tedge[u - 1].append(v - 1)\\n\\tedge[v - 1].append(u - 1)\\nparent = [-1 for i in range(n)]\\ndepth = [0 for i in range(n)]\\ncnt = [0 for i in range(n)]\\nres = [n for i in range(n"