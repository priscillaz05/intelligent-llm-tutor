"```json\n{\n  \"Coding Problem\": \"Student Vladislav came to his programming exam completely unprepared as usual. He got a question about some strange algorithm on a graph \u2014 something that will definitely never be useful in real life. He asked a girl sitting next to him to lend him some cheat papers for this questions and found there the following definition:\\n\\nThe minimum spanning tree T of graph G is such a tree that it contains all the vertices of the original graph G, and the sum of the weights of its edges is the minimum possible among all such trees.\\n\\nVladislav drew a graph with n vertices and m edges containing no loops and multiple edges. He found one of its minimum spanning trees and then wrote for each edge its weight and whether it is included in the found tree or not. Unfortunately, the piece of paper where the graph was painted is gone and the teacher is getting very angry and demands to see the original graph. Help Vladislav come up with a graph so that the information about the minimum spanning tree remains correct.\\n\\nInput\\n\\nThe first line of the input contains two integers n and m (<image>) \u2014 the number of vertices and the number of edges in the graph.\\n\\nEach of the next m lines describes an edge of the graph and consists of two integers aj and bj (1 \u2264 aj \u2264 109, bj = {0, 1}). The first of these numbers is the weight of the edge and the second number is equal to 1 if this edge was included in the minimum spanning tree found by Vladislav, or 0 if it was not.\\n\\nIt is guaranteed that exactly n - 1 number {bj} are equal to one and exactly m - n + 1 of them are equal to zero.\\n\\nOutput\\n\\nIf Vladislav has made a mistake and such graph doesn't exist, print  - 1.\\n\\nOtherwise print m lines. On the j-th line print a pair of vertices (uj, vj) (1 \u2264 uj, vj \u2264 n, uj \u2260 vj), that should be connected by the j-th edge. The edges are numbered in the same order as in the input. The graph, determined by these edges, must be connected, contain no loops or multiple edges and its edges with bj = 1 must define the minimum spanning tree. In case there are multiple possible solutions, print any of them.\\n\\nExamples\\n\\nInput\\n\\n4 5\\n2 1\\n3 1\\n4 0\\n1 1\\n5 0\\n\\n\\nOutput\\n\\n2 4\\n1 4\\n3 4\\n3 1\\n3 2\\n\\n\\nInput\\n\\n3 3\\n1 0\\n2 1\\n3 1\\n\\n\\nOutput\\n\\n-1\",\n  \"Ground Truth Solution\": \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nfrom heapq import *\\n\\ndef main():\\n\\t(n, m) = map(int, input().split())\\n\\ta = [list(map(int, input().split())) for _ in range(m)]\\n\\t(edges, j, b) = ([[]] * m, 1, sorted(range(m), key=lambda x: a[x][0] * 10000000000 - a[x][1]))\\n\\tc = []\\n\\tfor i in range(1, n - 1):\\n\\t\\tc.append((i + 2, i))\\n\\theapify(c)\\n\\tfor i in b:\\n\\t\\tif a[i][1]:\\n\\t\\t\\tedges[i] = [j, j + 1]\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tif not c:\\n\\t\\t\\t\\tprint(-1)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tz = heappop(c)\\n\\t\\t\\tif j < z[0]:\\n\\t\\t\\t\\tprint(-1)\\n\\t\\t\\t\\treturn\\n\\t\\t\\telse:\\n\\t\\t\\t\\tedges[i] = [z[1], z[0]]\\n\\t\\t\\t\\tif z[0] + 1 <= n:\\n\\t\\t\\t\\t\\theappush(c, (z[0] + 1, z[1]))\\n\\tfor i in edges:\\n\\t\\tprint(*i)\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem Requirements: The task is to reconstruct a graph given the number of vertices (n), the number of edges (m), and information about a Minimum Spanning Tree (MST). For each edge, we're given its weight and a boolean indicating whether it's part of the MST. The solution must either output a valid graph that satisfies the MST properties or output -1 if no such graph exists.\\n- Identifying Key Constraints: There are n-1 edges in the MST and m-n+1 edges not in the MST. The graph must be connected, have no loops, and no multiple edges. The MST edges must indeed form a minimum spanning tree.\\n- Algorithmic Strategy: The algorithm will involve assigning vertices to each edge based on the MST information. The key is to ensure that the edges marked as part of the MST actually form a tree and that it's possible to add the non-MST edges without violating the MST property. Sort the edges based on their weight with MST edges prioritized, and then systematically assign vertices to the edges.\\n- Addressing Potential Failure Conditions: It's possible that no graph satisfying the given conditions exists. For instance, if the provided MST edges do not form a connected tree, or if a non-MST edge must have a smaller weight than an MST edge to construct the graph, or some other constraints are violated. These conditions must be checked, and -1 should be printed if they occur.\",\n  \"LLM Questions\": [\n    \"How can you ensure that the edges marked as part of the MST actually form a tree structure?\",\n    \"What are the key properties of a Minimum Spanning Tree that you must preserve while constructing the graph?\",\n    \"How do you handle the edges that are not part of the MST, and how do you assign vertices to them without violating the MST property?\",\n    \"What are the possible conditions under which the construction of a valid graph is impossible, and how do you detect them?\",\n    \"How does sorting the edges by weight and MST status simplify the process of assigning vertices and detecting conflicts?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Start by assigning vertices sequentially to the MST edges, making sure that each edge connects to the existing 'tree' formed so far. If there are disconnections, the graph doesn't exist and return -1. An initial set of vertices (1, 2) are connected, then subsequent MST edges (3, 1), (4,1) are connected to the existing 'tree' which is guaranteed to be a tree structure.\",\n    \"An MST must connect all vertices in the graph and have the minimum possible total weight of edges. The edges in the MST should be chosen in such a way that adding any other edge not in the MST would increase the total weight if it were to replace an MST edge.\",\n    \"For non-MST edges, they should connect existing components of the tree. The goal is to find vertices such that the edge doesn't create a cycle within a lower-weight MST edge. Handle these edges after the MST edges have been assigned vertices. Use a data structure like a heap to manage available vertices or tree components. Connect to vertices that are already added.\",\n    \"Cases where the given edges cannot form a graph are, for example, the count of MST edges is not n-1, two vertices are isolated, or connecting them has lower weight edge than the current edge. A non-MST edge must be assigned in the algorithm when the existing vertex connectivity constraints are violated. If no vertices can be connected to form a valid graph, the result should be -1.\",\n    \"Sorting the edges allows you to prioritize the MST edges and edges with lower weights. This helps in building the graph incrementally while minimizing the risk of violating the MST property. By sorting, you guarantee that any subsequent additions of vertices/edges are always cost-effective given current status.\"\n  ]\n}\n```"