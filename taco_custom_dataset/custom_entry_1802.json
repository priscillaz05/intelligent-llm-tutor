"```json\n{\n  \"Coding Problem\": \"You are given an array $a$ consisting of $n$ integers. In one move, you can jump from the position $i$ to the position $i - a_i$ (if $1 \\le i - a_i$) or to the position $i + a_i$ (if $i + a_i \\le n$).\\n\\nFor each position $i$ from $1$ to $n$ you want to know the minimum the number of moves required to reach any position $j$ such that $a_j$ has the opposite parity from $a_i$ (i.e. if $a_i$ is odd then $a_j$ has to be even and vice versa).\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains one integer $n$ ($1 \\le n \\le 2 \\\\cdot 10^5$) \u2014 the number of elements in $a$.\\n\\nThe second line of the input contains $n$ integers $a_1, a_2, \\\\dots, a_n$ ($1 \\le a_i \\le n$), where $a_i$ is the $i$-th element of $a$.\\n\\n\\n-----Output-----\\n\\nPrint $n$ integers $d_1, d_2, \\\\dots, d_n$, where $d_i$ is the minimum the number of moves required to reach any position $j$ such that $a_j$ has the opposite parity from $a_i$ (i.e. if $a_i$ is odd then $a_j$ has to be even and vice versa) or -1 if it is impossible to reach such a position.\\n\\n\\n-----Example-----\\nInput\\n10\\n4 5 7 6 7 5 4 4 6 4\\n\\nOutput\\n1 1 1 2 -1 1 1 3 1 1\",\n  \"Ground Truth Solution\": \"from copy import deepcopy\\nfrom collections import defaultdict\\nfrom queue import Queue\\nn = int(input())\\narr = [int(x) for x in input().split()]\\nd = [-1] * n\\nparity = [x % 2 for x in arr]\\ndone = Queue()\\nlrs = defaultdict(list)\\nfor i in range(n):\\n\\tput = False\\n\\tif i - arr[i] >= 0:\\n\\t\\tif parity[i] != parity[i - arr[i]]:\\n\\t\\t\\td[i] = 1\\n\\t\\t\\tdone.put(i)\\n\\t\\t\\tput = True\\n\\t\\tlrs[i - arr[i]].append(i)\\n\\tif i + arr[i] < n:\\n\\t\\tif not put and parity[i] != parity[i + arr[i]]:\\n\\t\\t\\td[i] = 1\\n\\t\\t\\tdone.put(i)\\n\\t\\tlrs[i + arr[i]].append(i)\\nwhile not done.empty():\\n\\ti = done.get()\\n\\tfor j in lrs[i]:\\n\\t\\tif d[j] == -1:\\n\\t\\t\\td[j] = d[i] + 1\\n\\t\\t\\tdone.put(j)\\nprint(' '.join([str(x) for x in d]))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires finding the minimum number of jumps to reach a number with the opposite parity in an array. A jump can be $i - a_i$ or $i + a_i$.\\n- Data Structures and Algorithm: Use Breadth-First Search (BFS) to find the shortest path. Use a queue to keep track of the indices to visit. Use an array `d` to store the minimum jumps and initialize it with -1. Use an array `parity` to store the parity of each number.\\n- Edge Cases and Constraints: Handle edge cases where it's impossible to reach a number with opposite parity, which will be represented by -1. Ensure $1 \\\\le i - a_i$ and $i + a_i \\\\le n$.\\n- Initialization: Create a queue `done` and a defaultdict `lrs` to store the adjacent positions.\\n- Main Logic: Iterate through the array. If jumping to $i - a_i$ or $i + a_i$ results in a number with the opposite parity, set $d[i] = 1$ and add $i$ to the queue `done`. Also, append $i$ to `lrs[i - a_i]` and `lrs[i + a_i]`.\\n- BFS Traversal: While the queue `done` is not empty, get an index `i` from the queue. Iterate through the adjacent positions in `lrs[i]`. If the distance to `j` is -1, set $d[j] = d[i] + 1$ and add `j` to the queue `done`.\\n- Output: Print the array `d`.\",\n  \"LLM Questions\": [\n    \"How can I efficiently find the shortest path to a node with opposite parity?\",\n    \"How should I handle edge cases where there is no path to a node with opposite parity?\",\n    \"How can I represent the graph structure implicitly using the given jump rules?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Use Breadth-First Search (BFS) to find the shortest path. BFS explores all the neighbors at the present depth prior to moving on to the nodes at the next depth level, which guarantees the shortest path in an unweighted graph.\",\n    \"Initialize the distance array with -1. If, after the BFS, the distance to a node is still -1, it means there is no path to a node with opposite parity. Retain -1 in the final output.\",\n    \"Since we can jump from position $i$ to $i - a_i$ or $i + a_i$, we can consider these as edges in a graph. We don't need to explicitly construct the graph. Instead, compute neighbors on the fly. Store the 'reverse' connections in the defaultdict `lrs` as shown in the Ground Truth Solution.\"\n  ]\n}\n```"