"```json\n{\n  \"Coding Problem\": \"Mark has just purchased a rack of $n$ lightbulbs. The state of the lightbulbs can be described with binary string $s = s_1s_2\\\\dots s_n$, where $s_i={1}$ means that the $i$-th lightbulb is turned on, while $s_i={0}$ means that the $i$-th lightbulb is turned off.\\n\\nUnfortunately, the lightbulbs are broken, and the only operation he can perform to change the state of the lightbulbs is the following:\\n\\nSelect an index $i$ from $2,3,\\\\dots,n-1$ such that $s_{i-1}\\\\ne s_{i+1}$.\\n\\nToggle $s_i$. Namely, if $s_i$ is ${0}$, set $s_i$ to ${1}$ or vice versa.\\n\\nMark wants the state of the lightbulbs to be another binary string $t$. Help Mark determine the minimum number of operations to do so.\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains a single integer $q$ ($1\\\\leq q\\\\leq 10^4$) \u2014 the number of test cases.\\n\\nThe first line of each test case contains a single integer $n$ ($3\\\\leq n\\\\leq 2\\\\cdot 10^5$) \u2014 the number of lightbulbs.\\n\\nThe second line of each test case contains a binary string $s$ of length $n$ \u2014 the initial state of the lightbulbs.\\n\\nThe third line of each test case contains a binary string $t$ of length $n$ \u2014 the final state of the lightbulbs.\\n\\nIt is guaranteed that the sum of $n$ across all test cases does not exceed $2\\\\cdot 10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case, print a line containing the minimum number of operations Mark needs to perform to transform $s$ to $t$. If there is no such sequence of operations, print $-1$.\\n\\n\\n-----Examples-----\\n\\nInput\\n4\\n4\\n0100\\n0010\\n4\\n1010\\n0100\\n5\\n01001\\n00011\\n6\\n000101\\n010011\\nOutput\\n2\\n-1\\n-1\\n5\\n\\n\\n-----Note-----\\n\\nIn the first test case, one sequence of operations that achieves the minimum number of operations is the following.\\n\\nSelect $i=3$, changing ${01}{{0}}{0}$ to ${01}{{1}}{0}$.\\n\\nSelect $i=2$, changing ${0}{{1}}{10}$ to ${0}{{0}}{10}$.\\n\\nIn the second test case, there is no sequence of operations because one cannot change the first digit or the last digit of $s$.\\n\\nIn the third test case, even though the first digits of $s$ and $t$ are the same and the last digits of $s$ and $t$ are the same, it can be shown that there is no sequence of operations that satisfies the condition.\\n\\nIn the fourth test case, one sequence that achieves the minimum number of operations is the following:\\n\\nSelect $i=3$, changing ${00}{{0}}{101}$ to ${00}{{1}}{101}$.\\n\\nSelect $i=2$, changing ${0}{{0}}{1101}$ to ${0}{{1}}{1101}$.\\n\\nSelect $i=4$, changing ${011}{{1}}{01}$ to ${011}{{0}}{01}$.\\n\\nSelect $i=5$, changing ${0110}{{0}}{1}$ to ${0110}{{1}}{1}$.\\n\\nSelect $i=3$, changing ${01}{{1}}{011}$ to ${01}{{0}}{011}.\",\n  \"Ground Truth Solution\": \"def f(s, t, n):\\n\\tif s[0] != t[0] or s[n - 1] != t[n - 1]:\\n\\t\\treturn -1\\n\\t(i, j, edits) = (0, 0, 0)\\n\\twhile True:\\n\\t\\twhile i < n - 1 and s[i] == s[i + 1]:\\n\\t\\t\\ti += 1\\n\\t\\twhile j < n - 1 and t[j] == t[j + 1]:\\n\\t\\t\\tj += 1\\n\\t\\tif i < n - 1 and j < n - 1:\\n\\t\\t\\tedits += abs(i - j)\\n\\t\\telif i == n - 1 and j == n - 1:\\n\\t\\t\\treturn edits + abs(i - j)\\n\\t\\telse:\\n\\t\\t\\treturn -1\\n\\t\\ti += 1\\n\\t\\tj += 1\\nT = int(input())\\nwhile T:\\n\\tn = int(input())\\n\\t(s, t) = (input(), input())\\n\\tprint(f(s, t, n))\\n\\tT -= 1\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem asks for the minimum number of operations to transform a binary string `s` into another binary string `t` by toggling characters at index `i` if `s[i-1] != s[i+1]`. The first and last characters cannot be changed.\\n- Identifying Constraints: The first and last characters of `s` and `t` must be the same; otherwise, it's impossible to transform `s` to `t`. The valid operation can only be performed on characters from index 1 to n-2.\\n- Algorithmic Strategy: The key insight lies in focusing on consecutive identical characters. We can collapse each run of consecutive identical characters in `s` and `t` into a single character. The number of operations needed corresponds to the difference in indices after collapsing runs. We need to ensure that the first and last chars match, else impossible\\n- Edge Cases: if at any point one string collapsing finishes before other, it should return -1. Also if the start or end characters differ then return -1.\",\n  \"LLM Questions\": [\n    \"What are the constraints on the transformation of string `s` to string `t`?\",\n    \"What is the condition that makes it impossible to transform `s` to `t`?\",\n    \"How does the collapsing of consecutive identical characters help in determining the minimum number of operations?\",\n    \"What happens if `s` or `t` strings runs out before the other?\",\n    \"Why are the first and last characters of the strings significant, and what should you check about them?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Only characters at index `i` can be toggled if `s[i-1] != s[i+1]`. The first and last characters of the string `s` cannot be changed.\",\n    \"It is impossible to transform `s` to `t` if the first or last characters of `s` and `t` are different.\",\n    \"Collapsing runs of consecutive identical characters helps to simplify the string, allowing us to focus on the transitions between different characters and the relative positions of these transitions in `s` and `t`.\",\n    \"If one string runs out of characters while the other still has transitions, it indicates an impossible transformation scenario; hence, return -1\",\n    \"The first and last characters must be the same in both strings; otherwise, a transformation is impossible. We need to check if s[0] == t[0] and s[n-1] == t[n-1]\"\n  ]\n}\n```"