"```json\n{\n  \"Coding Problem\": \"Read problems statements in [Mandarin Chinese], [Russian], [Vietnamese] and [Bengali] as well.\\n\\nYou are given a tree of $N$ nodes rooted at node $1$. Each node $u$ initially has a positive value $a_{u}$ associated with it.\\n\\nYou randomly choose one node in the tree and change its value to zero. If any node $u$ has a value equal to $0$, a random node $v$ will be chosen in the subtree of $u$ ($u \\\\neq v$), and the values $a_{u}$ and $a_{v}$ will be swapped, hence the value of the node $v$ will become zero and the process will continue until the zero is on a leaf node. At this point, we will call the tree a final tree.\\n\\nNote: there is exactly one node with a value equal to zero in a final tree and that node is a leaf node.\\n\\nYour task is to tell how many different final trees are possible. Two final trees are different if there exists at least one node $u$, such that the value of the node $u$ in one final tree differs from the value of the node $u$ in the other final tree. Since the answer can be large, print it modulo $10^{9} +7$.\\n\\n------ Input ------\\n\\nThe first line contains an integer $T$, the number of test cases. Then the test cases follow. \\nThe first line of each test case contains an integer $N$, the number of nodes.\\nEach of the next $N-1$ lines contains two integers $u$ and $v$, denoting that there is an undirected edge between the node $u$ and the node $v$.\\nThe next line contains $N$ integers $a_{1},\\\\ldots, a_{N}$.\\n\\n------ Output ------\\nFor each test case, output on a new line, number of different final trees possible, modulo $10^{9}+7$.\\n\\n------ Constraints ------\\n$1 \u2264 T \u2264 10^{5}$\\n$1 \u2264 N \u2264 10^{5}$\\n$1 \u2264 u, v \u2264 N$\\n$1\u2264 a_{i}\u2264 10^{9}$\\nThe edges form a tree structure.\\nThe sum of $N$ over all test cases does not exceed $10^{6}$.\\n\\n------ Sample Input ------\\n\\n3\\n1\\n1\\n4\\n1 2\\n2 3\\n2 4\\n1 1 1 2\\n7\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\\n1 2 3 4 1 2 1\\n\\n------ Sample Output ------\\n\\n1\\n4\\n14\\n\\n------ Explanation ------\\nFor the first test case, the only possible final tree is when node $1$ is chosen and its value becomes 0.\\nFor the second test case, the four possible final trees are:\\n- [ 1, 1, 1, 0 ]\\n- [ 1, 1, 0, 2 ]\\n- [ 1, 2, 1, 0 ]\\n- [ 2, 1, 1, 0 ]\\n\\n( The $i$-th number in the array denotes the value of node $i$ in the final tree).\",\n  \"Ground Truth Solution\": \"from collections import deque\\n\\ndef merge(x, y):\\n\\tif len(x) > len(y):\\n\\t\\t(x, y) = (y, x)\\n\\tfor i in x:\\n\\t\\ty[i] = y[i] + x[i] if i in y else x[i]\\n\\treturn (y, y)\\n\\ndef NC_Dij(lis, start):\\n\\tret = [float('inf')] * len(lis)\\n\\tret[start] = 0\\n\\tq = deque([start])\\n\\tplis = [i for i in range(len(lis))]\\n\\twhile len(q) > 0:\\n\\t\\tnow = q.popleft()\\n\\t\\tfor nex in lis[now]:\\n\\t\\t\\tif ret[nex] > ret[now] + 1:\\n\\t\\t\\t\\tret[nex] = ret[now] + 1\\n\\t\\t\\t\\tplis[nex] = now\\n\\t\\t\\t\\tq.append(nex)\\n\\treturn (ret, plis)\\nmod = 10 ** 9 + 7\\nfor loop in range(int(input())):\\n\\tN = int(input())\\n\\tlis = [[] for i in range(N)]\\n\\tfor i in range(N - 1):\\n\\t\\t(u, v) = map(int, input().split())\\n\\t\\tu -= 1\\n\\t\\tv -= 1\\n\\t\\tlis[u].append(v)\\n\\t\\tlis[v].append(u)\\n\\t(dlis, P) = NC_Dij(lis, 0)\\n\\tchnum = [0] * N\\n\\tfor i in range(1, N):\\n\\t\\tchnum[P[i]] += 1\\n\\ta = list(map(int, input().split()))\\n\\tcds = [{} for i in range(N)]\\n\\tallsum = [0] * N\\n\\tq = deque([])\\n\\tleaf = [False] * N\\n\\tans = 0\\n\\tfor i in range(N):\\n\\t\\tif chnum[i] == 0:\\n\\t\\t\\tq.append(i)\\n\\t\\t\\tleaf[i] = True\\n\\twhile q:\\n\\t\\tv = q.popleft()\\n\\t\\tnans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\\n\\t\\tif leaf[v]:\\n\\t\\t\\tnans = 1\\n\\t\\tnans %= mod\\n\\t\\tans += nans\\n\\t\\tans %= mod\\n\\t\\tif a[v] not in cds[v]:\\n\\t\\t\\tcds[v][a[v]] = 0\\n\\t\\tcds[v][a[v]] += nans\\n\\t\\tcds[v][a[v]] %= mod\\n\\t\\tif P[v] != v:\\n\\t\\t\\tchnum[P[v]] -= 1\\n\\t\\t\\t(cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\\n\\t\\t\\tallsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\\n\\t\\t\\tif chnum[P[v]] == 0:\\n\\t\\t\\t\\tq.append(P[v])\\n\\tprint(ans)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a process on a tree where a node's value is set to zero, and this zero value is propagated to a leaf node through a series of swaps within subtrees. The goal is to count the distinct final trees possible after this process, modulo 10^9 + 7.\\n- Identifying Key Concepts: The key concepts involve tree traversal, subtree identification, and counting distinct states. The swapping mechanism ensures that the zero value always ends up at a leaf node. Distinct final trees mean at least one node has a different value compared to another final tree.\\n- Developing a Strategy: We need to simulate or track the possible final states. A dynamic programming or depth-first search (DFS) approach could be used. We keep track of the possible values at each node after the zero has propagated. The use of modulo is important to avoid integer overflow.\\n- Addressing Edge Cases: Consider edge cases like a single-node tree. Pay special attention to how the zero propagates and to the definition of a subtree.\\n- Optimizing for Efficiency: The constraint on the sum of N (up to 10^6) suggests the need for an efficient algorithm, potentially O(N log N) or better, to avoid exceeding time limits.\",\n  \"LLM Questions\": [\n    \"What are the possible initial nodes that can be set to zero, and how does this choice affect the final tree?\",\n    \"How can we efficiently identify the subtree of a given node in the tree?\",\n    \"When the value of a node becomes zero, how does the swapping mechanism ensure the zero value eventually reaches a leaf node?\",\n    \"How can we avoid overcounting the distinct final trees, especially when multiple initial zero assignments might lead to the same final configuration?\",\n    \"How can the modulo operator be used to prevent integer overflow when calculating the number of distinct final trees?\",\n    \"What data structures could be used to efficiently track the values at each node, the subtrees, and the distinct configurations?\",\n    \"How to optimize the algorithm to meet the time constraint, considering the large possible values for N?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Any node can be initially set to zero. The choice of this initial node determines the starting point for the zero-propagation process, influencing which subtrees are involved in the subsequent swaps and ultimately affecting the final tree configuration.\",\n    \"We can identify the subtree of a given node using a depth-first search (DFS) or breadth-first search (BFS) algorithm. Starting from the given node, we traverse its descendants, marking all reachable nodes as part of its subtree. This can be precomputed and stored for each node to improve efficiency.\",\n    \"The problem states that the zero value propagates through swaps within the subtree. Since the swaps are random, and the process continues until the zero is on a leaf, the process guarantees termination with the zero on a leaf, as each swap brings it closer to a leaf in that subtree.\",\n    \"We can use sets to track the unique tree configurations, where a tree configuration is represented by a hashable tuple of the values at each node. Before adding a new final tree configuration to the count, we check if it already exists in the set.\",\n    \"The modulo operator (%) is used to ensure that intermediate results and the final count remain within the bounds of the specified modulo (10^9 + 7). After each addition or multiplication, we apply the modulo operator to prevent integer overflow.\",\n    \"Data structures such as adjacency lists or matrices can represent the tree structure. Sets can store distinct tree configurations, and dictionaries can store precomputed subtree information for quick retrieval.\",\n    \"To optimize for time, we can use an efficient subtree identification algorithm (e.g., DFS or BFS) and avoid redundant computations by storing intermediate results. Memoization or dynamic programming may be useful in caching already computed results. Also, the choice of data structures impacts performance, use hash tables or sets instead of lists to improve searching and uniqueness checks.\"\n  ]\n}\n```"