"```json\n{\n  \"Coding Problem\": \"There are $n$ people in this world, conveniently numbered $1$ through $n$. They are using burles to buy goods and services. Occasionally, a person might not have enough currency to buy what he wants or needs, so he borrows money from someone else, with the idea that he will repay the loan later with interest. Let $d(a,b)$ denote the debt of $a$ towards $b$, or $0$ if there is no such debt.\\n\\nSometimes, this becomes very complex, as the person lending money can run into financial troubles before his debtor is able to repay his debt, and finds himself in the need of borrowing money. \\n\\nWhen this process runs for a long enough time, it might happen that there are so many debts that they can be consolidated. There are two ways this can be done:  Let $d(a,b) > 0$ and $d(c,d) > 0$ such that $a \\\\neq c$ or $b \\\\neq d$. We can decrease the $d(a,b)$ and $d(c,d)$ by\\u00a0$z$ and increase $d(c,b)$ and $d(a,d)$ by\\u00a0$z$, where $0 < z \\\\leq \\\\min(d(a,b),d(c,d))$.  Let $d(a,a) > 0$. We can set $d(a,a)$ to $0$. \\n\\nThe total debt is defined as the sum of all debts:\\n\\n$$\\\\Sigma_d = \\\\sum_{a,b} d(a,b)$$\\n\\nYour goal is to use the above rules in any order any number of times, to make the total debt as small as possible. Note that you don't have to minimise the number of non-zero debts, only the total debt.\\n\\n\\n-----Input-----\\n\\nThe first line contains two space separated integers $n$\\u00a0($1 \\\\leq n \\\\leq 10^5$) and $m$\\u00a0($0 \\\\leq m \\\\leq 3\\\\cdot 10^5$), representing the number of people and the number of debts, respectively.\\n\\n$m$ lines follow, each of which contains three space separated integers $u_i$, $v_i$\\u00a0($1 \\\\leq u_i, v_i \\\\leq n, u_i \\\\neq v_i$), $d_i$\\u00a0($1 \\\\leq d_i \\\\leq 10^9$), meaning that the person $u_i$ borrowed $d_i$ burles from person $v_i$.\\n\\n\\n-----Output-----\\n\\nOn the first line print an integer $m'$\\u00a0($0 \\\\leq m' \\\\leq 3\\\\cdot 10^5$), representing the number of debts after the consolidation. It can be shown that an answer always exists with this additional constraint.\\n\\nAfter that print $m'$ lines, $i$-th of which contains three space separated integers $u_i, v_i, d_i$, meaning that the person $u_i$ owes the person $v_i$ exactly $d_i$ burles. The output must satisfy $1 \\\\leq u_i, v_i \\\\leq n$, $u_i \\\\neq v_i$ and $0 < d_i \\\\leq 10^{18}$.\\n\\nFor each pair $i \\\\neq j$, it should hold that $u_i \\\\neq u_j$ or $v_i \\\\neq v_j$. In other words, each pair of people can be included at most once in the output.\\n\\n\\n-----Examples-----\\nInput\\n3 2\\n1 2 10\\n2 3 5\\n\\nOutput\\n2\\n1 2 5\\n1 3 5\\n\\nInput\\n3 3\\n1 2 10\\n2 3 15\\n3 1 10\\n\\nOutput\\n1\\n2 3 5\\n\\nInput\\n4 2\\n1 2 12\\n3 4 8\\n\\nOutput\\n2\\n1 2 12\\n3 4 8\\n\\nInput\\n3 4\\n2 3 1\\n2 3 2\\n2 3 4\\n2 3 8\\n\\nOutput\\n1\\n2 3 15\\n\\n\\n\\n-----Note-----\\n\\nIn the first example the optimal sequence of operations can be the following:  Perform an operation of the first type with $a = 1$, $b = 2$, $c = 2$, $d = 3$ and $z = 5$. The resulting debts are: $d(1, 2) = 5$, $d(2, 2) = 5$, $d(1, 3) = 5$, all other debts are $0$;  Perform an operation of the second type with $a = 2$. The resulting debts are: $d(1, 2) = 5$, $d(1, 3) = 5$, all other debts are $0$. \\n\\nIn the second example the optimal sequence of operations can be the following:  Perform an operation of the first type with $a = 1$, $b = 2$, $c = 3$, $d = 1$ and $z = 10$. The resulting debts are: $d(3, 2) = 10$, $d(2, 3) = 15$, $d(1, 1) = 10$, all other debts are $0$;  Perform an operation of the first type with $a = 2$, $b = 3$, $c = 3$, $d = 2$ and $z = 10$. The resulting debts are: $d(2, 2) = 10$, $d(3, 3) = 10$, $d(2, 3) = 5$, $d(1, 1) = 10$, all other debts are $0$;  Perform an operation of the second type with $a = 2$. The resulting debts are: $d(3, 3) = 10$, $d(2, 3) = 5$, $d(1, 1) = 10$, all other debts are $0$;  Perform an operation of the second type with $a = 3$. The resulting debts are: $d(2, 3) = 5$, $d(1, 1) = 10$, all other debts are $0$;  Perform an operation of the second type with $a = 1$. The resulting debts are: $d(2, 3) = 5$, all other debts are $0$.\",\n  \"Ground Truth Solution\": \"(n, m) = map(int, input().split())\\nd = {}\\nfor i in range(m):\\n\\t(x, y, a) = map(int, input().split())\\n\\td[x] = d.get(x, 0) - a\\n\\td[y] = d.get(y, 0) + a\\npos = []\\nneg = []\\nfor i in d:\\n\\tif d[i] < 0:\\n\\t\\tneg.append([d[i], i])\\n\\telif d[i] > 0:\\n\\t\\tpos.append([d[i], i])\\nans = []\\ni = 0\\nj = 0\\nwhile i < len(neg) and j < len(pos):\\n\\tz = min(-neg[i][0], pos[j][0])\\n\\tans.append([neg[i][1], pos[j][1], z])\\n\\tneg[i][0] += z\\n\\tpos[j][0] -= z\\n\\tif pos[j][0] == 0:\\n\\t\\tj += 1\\n\\tif neg[i][0] == 0:\\n\\t\\ti += 1\\nprint(len(ans))\\nfor i in ans:\\n\\tprint(*i)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem is about minimizing the total debt in a network of people by consolidating debts. Two operations are allowed: transferring debt between two pairs of people or eliminating self-debt. The objective is to output the minimized debts between pairs of individuals after consolidation.\\n- Data Representation: We can represent the debts using a dictionary (or hash map) to store the net balance of each person. Positive balance indicates that the person is owed money, and negative balance indicates that the person owes money.\\n- Algorithm: Iterate through the input debts and update the balance of each person. Then, separate people into two lists: those with positive balances (creditors) and those with negative balances (debtors). Iteratively match debtors and creditors to eliminate debts. Create new debts with the minimum possible value between each debtor and creditor until all balances are settled.\",\n  \"LLM Questions\": [\n    \"How can we represent the net debt of each person to easily calculate and consolidate debts?\",\n    \"What is the most efficient way to consolidate debts between creditors and debtors to minimize the total debt amount?\",\n    \"How should the remaining debts be stored and outputted after the consolidation process?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"We can use a dictionary or hash map to store the net balance for each person, where keys are person IDs and values are their net debt (positive for creditors, negative for debtors).\",\n    \"We can maintain two lists: one for creditors and one for debtors. Iteratively, we pair the maximum creditor and debtor, transferring the minimum of their absolute debts between them until all debts are settled.\",\n    \"The remaining debts can be stored as a list of tuples (debtor, creditor, debt_amount), and this list's length will be the first line in the output. Each tuple can then be outputted as a line of three space-separated integers.\"\n  ]\n}\n```"