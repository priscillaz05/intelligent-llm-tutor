"```json\n{\n  \"Coding Problem\": \"Burenka is about to watch the most interesting sporting event of the year \u2014 a fighting tournament organized by her friend Tonya.\\n\\n$n$ athletes participate in the tournament, numbered from $1$ to $n$. Burenka determined the strength of the $i$-th athlete as an integer $a_i$, where $1 \\leq a_i \\leq n$. All the strength values are different, that is, the array $a$ is a permutation of length $n$. We know that in a fight, if $a_i > a_j$, then the $i$-th participant always wins the $j$-th.\\n\\nThe tournament goes like this: initially, all $n$ athletes line up in ascending order of their ids, and then there are infinitely many fighting rounds. In each round there is exactly one fight: the first two people in line come out and fight. The winner goes back to the front of the line, and the loser goes to the back.\\n\\nBurenka decided to ask Tonya $q$ questions. In each question, Burenka asks how many victories the $i$-th participant gets in the first $k$ rounds of the competition for some given numbers $i$ and $k$. Tonya is not very good at analytics, so he asks you to help him answer all the questions.\\n\\n\\n-----Input-----\\n\\nThe first line contains one integer $t$ ($1 \\leq t \\leq 10^4$) \u2014 the number of test cases. Description of the test cases follows.\\n\\nThe first line of each test case contains two integers $n$ and $q$ ($2 \\leq n \\leq 10^5$, $1 \\leq q \\leq 10^5$) \u2014 the number of tournament participants and the number of questions.\\n\\nThe second line of each test case contains $n$ integers $a_1, a_2, \\\\ldots, a_n$ ($1 \\leq a_i \\leq n$) \u2014 the array $a$, which is a permutation.\\n\\nThe next $q$ lines of a test case contain questions. Each line contains two integers $i$ and $k$ ($1 \\leq i \\leq n$, $1 \\leq k \\leq 10^9$) \u2014 the number of the participant and the number of rounds.\\n\\nIt is guaranteed that the sum of $n$ and the sum of $q$ over all test cases do not exceed $10^5$.\\n\\n\\n-----Output-----\\n\\nFor each Burenka's question, print a single line containing one integer \u2014 the answer to the question.\\n\\n\\n-----Examples-----\\n\\nInput\\n3\\n3 1\\n3 1 2\\n1 2\\n4 2\\n1 3 4 2\\n4 5\\n3 2\\n1 2 3 5 4\\n5 1000000000\\n4 6\\nOutput\\n2\\n0\\n1\\n0\\n4\\n\\n\\n-----Note-----\\n\\nIn the first test case, the first numbered athlete has the strength of $3$, in the first round he will defeat the athlete with the number $2$ and the strength of $1$, and in the second round, the athlete with the number $3$ and the strength of $2$.\\n\\nIn the second test case, we list the strengths of the athletes fighting in the first $5$ fights: $1$ and $3$, $3$ and $4$, $4$ and $2$, $4$ and $1$, $4$ and $3$. The participant with the number $4$ in the first $5$ rounds won $0$ times (his strength is $2$). The participant with the number $3$ has a strength of $4$ and won $1$ time in the first two fights by fighting $1$ time.\",\n  \"Ground Truth Solution\": \"import sys\\ninput = sys.stdin.readline\\n\\ndef int_num():\\n\\treturn int(input())\\n\\ndef int_list():\\n\\treturn list(map(int, input().split()))\\n\\ndef insr():\\n\\ts = input()\\n\\treturn list(s[:len(s) - 1])\\n\\ndef invr():\\n\\treturn map(int, input().split())\\n\\ndef solve():\\n\\t(n, q) = int_list()\\n\\ta = int_list()\\n\\td = {}\\n\\t(max_id, max_first) = (0, 1)\\n\\t(head_id, head_num) = (0, a[0])\\n\\tfor i in range(1, n):\\n\\t\\tif a[i] == n:\\n\\t\\t\\t(max_id, max_first) = (i, i)\\n\\t\\t\\tbreak\\n\\t\\tif a[i] > head_num:\\n\\t\\t\\t(head_id, head_num) = (i, a[i])\\n\\t\\tif head_id in d:\\n\\t\\t\\t(first, cnt) = d[head_id]\\n\\t\\t\\td[head_id] = (first, cnt + 1)\\n\\t\\telse:\\n\\t\\t\\td[head_id] = (i, 1)\\n\\twhile q:\\n\\t\\t(qid, k) = int_list()\\n\\t\\tqid = qid - 1\\n\\t\\tif qid == max_id:\\n\\t\\t\\tans = 0 if k < max_id else k - max_first + 1\\n\\t\\telif qid in d:\\n\\t\\t\\t(first, cnt) = d[qid]\\n\\t\\t\\tif k < first:\\n\\t\\t\\t\\tans = 0\\n\\t\\t\\telif k > first + cnt - 1:\\n\\t\\t\\t\\tans = cnt\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans = k - first + 1\\n\\t\\telse:\\n\\t\\t\\tans = 0\\n\\t\\tprint(ans)\\n\\t\\tq -= 1\\n\\ndef main():\\n\\tt = int_num()\\n\\twhile t:\\n\\t\\tsolve()\\n\\t\\tt -= 1\\n\\treturn\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Tournament Mechanics: Understand that athletes are arranged by IDs initially, and the athlete with a higher 'a' value always wins.\\n- Identifying the Dominant Athlete: Recognize that after some rounds, the athlete with the highest strength will stay at the front and win all subsequent rounds. Find this athlete and the round when they become dominant.\\n- Storing Win Counts: Store the win counts for each athlete until the point the strongest athlete becomes permanently at the front.\\n- Handling Queries Efficiently: For each query, check if the queried athlete is the dominant one. If so, calculate wins based on when the athlete became dominant and the given number of rounds 'k'. If not, look up pre-calculated wins if within the stored rounds, otherwise, return 0.\",\n  \"LLM Questions\": [\n    \"How are the athletes initially arranged, and what determines the winner of each fight?\",\n    \"What will eventually happen to the athlete with the highest strength?\",\n    \"How can you efficiently determine the number of wins for an athlete within a given number of rounds?\",\n    \"How would you handle the queries for the athlete that eventually dominates the tournament?\",\n    \"How would you store the wins of non-dominant players within the early rounds of the tournament?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Athletes are initially arranged in ascending order by their IDs. The athlete with the higher strength ('a' value) always wins.\",\n    \"The athlete with the highest strength will eventually win and stay at the front of the line, winning all subsequent rounds.\",\n    \"Store the results of the initial rounds (before the highest strength athlete dominates). Then for each query look up the pre-calculated number of wins or calculate the number if the rounds extend beyond that initial stored state. Otherwise the answer is 0 if not found.\",\n    \"Determine the first round that the athlete became dominant and then if the round count in the query is beyond the first round that the dominant player was in first position, return the difference between round count and the initial round the dominant player was in first position, otherwise return 0.\",\n    \"I would use a dictionary to store the win counts for each athlete for each of the first rounds. The key will be the ID of the athlete and the value will be a list of win counts in order\"\n  ]\n}\n```"