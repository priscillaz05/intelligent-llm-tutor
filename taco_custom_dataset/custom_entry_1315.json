"```json\n{\n  \"Coding Problem\": \"You are given a permutation$^\\dagger$ $p$ of length $n$ and a positive integer $k \\\\le n$.\\n\\nIn one operation, you:\\n\\nChoose $k$ distinct elements $p_{i_1}, p_{i_2}, \\\\ldots, p_{i_k}$.\\n\\nRemove them and then add them sorted in increasing order to the end of the permutation.\\n\\nFor example, if $p = [2,5,1,3,4]$ and $k = 2$ and you choose $5$ and $3$ as the elements for the operation, then $[2, {5}, 1, {3}, 4] \\\\rightarrow [2, 1, 4, {3},{5}]$.\\n\\nFind the minimum number of operations needed to sort the permutation in increasing order. It can be proven that it is always possible to do so.\\n\\n$^\\dagger$ A permutation of length $n$ is an array consisting of $n$ distinct integers from $1$ to $n$ in arbitrary order. For example, $[2,3,1,5,4]$ is a permutation, but $[1,2,2]$ is not a permutation ($2$ appears twice in the array), and $[1,3,4]$ is also not a permutation ($n=3$ but there is $4$ in the array).\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $t$ ($1 \\\\le t \\\\le 10^4$) \u2014 the number of test cases. The description of test cases follows.\\n\\nThe first line of each test case contains two integers $n$ and $k$ ($2 \\\\le n \\\\le 10^5$, $1 \\\\le k \\\\le n$).\\n\\nThe second line of each test case contains $n$ integers $p_1,p_2,\\\\ldots, p_n$ ($1 \\\\le p_i \\\\le n$). It is guaranteed that $p$ is a permutation.\\n\\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case output a single integer \u2014 the minimum number of operations needed to sort the permutation. It can be proven that it is always possible to do so.\\n\\n\\n-----Examples-----\\n\\nInput\\n4\\n3 2\\n1 2 3\\n3 1\\n3 1 2\\n4 2\\n1 3 2 4\\n4 2\\n2 3 1 4\\nOutput\\n0\\n1\\n1\\n2\\n\\n\\n-----Note-----\\n\\nIn the first test case, the permutation is already sorted.\\n\\nIn the second test case, you can choose element $3$, and the permutation will become sorted as follows: $[{3}, 1, 2] \\\\rightarrow [1, 2, {3}]$.\\n\\nIn the third test case, you can choose elements $3$ and $4$, and the permutation will become sorted as follows: $[1, {3}, 2, {4}] \\\\rightarrow [1, 2, {3},{4}]$.\\n\\nIn the fourth test case, it can be shown that it is impossible to sort the permutation in $1$ operation. However, if you choose elements $2$ and $1$ in the first operation, and choose elements $3$ and $4$ in the second operation, the permutation will become sorted as follows: $[{2}, 3, {1}, 4] \\\\rightarrow [\\\\color{blue}{3}, \\\\color{blue}{4}, {1}, {2}] \\\\rightarrow [1,2, \\\\color{blue}{3}, \\\\color{blue}{4}]$.\",\n  \"Ground Truth Solution\": \"import sys\\n\\ndef in_int():\\n\\treturn int(sys.stdin.readline())\\n\\ndef in_str():\\n\\treturn sys.stdin.readline().rstrip()\\n\\ndef in_map_int():\\n\\treturn map(int, sys.stdin.readline().split())\\n\\ndef in_arr_int():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef in_arr_str():\\n\\treturn sys.stdin.readline().split()\\n\\ndef is_prime(n):\\n\\tfor i in range(2, int(n ** (1 / 2)) + 1):\\n\\t\\tif n % i == 0:\\n\\t\\t\\treturn True\\n\\treturn False\\n\\ndef bin2dec(s):\\n\\tn = 0\\n\\tfor i in range(len(s)):\\n\\t\\tn += int(s[len(s) - i - 1]) * 2 ** i\\n\\treturn n\\n\\ndef gcd(a, b):\\n\\t(a, b) = (max(a, b), min(a, b))\\n\\twhile b != 0:\\n\\t\\t(a, b) = (b, a % b)\\n\\treturn a\\n\\ndef dec2bin(n):\\n\\tif n == 0:\\n\\t\\treturn '0'\\n\\tans = ''\\n\\twhile n > 0:\\n\\t\\tans += str(n % 2)\\n\\t\\tn //= 2\\n\\treturn ans[::-1]\\n\\ndef solve(n, k, arr):\\n\\ti = 1\\n\\tfor a in arr:\\n\\t\\tif a == i:\\n\\t\\t\\ti += 1\\n\\ti -= 1\\n\\treturn (n - i + k - 1) // k\\n\\ndef main():\\n\\tt = in_int()\\n\\tfor _ in range(t):\\n\\t\\t(n, k) = in_map_int()\\n\\t\\tarr = in_arr_int()\\n\\t\\tprint(solve(n, k, arr))\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem Requirements: The problem asks for the minimum number of operations to sort a permutation by selecting k elements, removing them, sorting them, and appending them to the permutation.\\n- Identifying the Sorting Strategy: The core idea is to identify how many elements are already in their correct sorted position from the beginning of the array. The remaining unsorted elements need to be handled with operations of size k.\\n- Algorithm Selection and Optimization: An efficient approach is to count the number of leading elements that are already in their sorted position. The number of operations is then calculated based on the number of remaining unsorted elements, divided by k, rounded up.\\n- Edge Case and Boundary Condition Handling: Consider the case where the array is already sorted, which would result in 0 operations.\",\n  \"LLM Questions\": [\n    \"How do you determine if a given permutation is already sorted, and what should be the output in this scenario?\",\n    \"What is the most efficient way to count the number of elements at the beginning of the permutation that are already in their correct sorted order?\",\n    \"How can you calculate the minimum number of operations required to sort the remaining unsorted elements, given that each operation can handle k elements?\",\n    \"What are the corner cases to consider (e.g., when n is equal to k, when k is 1), and how do they affect the number of operations?\",\n    \"Can you explain the formula used to compute the number of operations, especially the ceiling division by k?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A permutation is sorted if each element p[i] is equal to i+1. If the permutation is already sorted, the output should be 0.\",\n    \"Iterate through the permutation from the beginning and increment a counter for each element that matches its expected value (i.e., p[i] == i+1). Stop when an element is out of order.\",\n    \"The number of unsorted elements is n minus the count of sorted elements from the beginning. Divide this difference by k and round up to the nearest integer to get the minimum number of operations.\",\n    \"If n equals k, one operation is always sufficient to sort the array unless it is already sorted. If k is 1, each unsorted element requires a separate operation. These can be accounted for by calculating unsorted elements as n - counter, and then performing ceiling division.\",\n    \"The formula `(n - i + k - 1) // k` where i is the number of correctly placed elements from the start, effectively calculates `ceil((n - i) / k)`.  Adding `k-1` before integer division ensures the result is rounded up.\"\n  ]\n}\n```"