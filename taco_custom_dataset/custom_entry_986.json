"```json\n{\n  \"Coding Problem\": \"Chef loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\\n\\nLet F_{d}(x) equals to the number of digits d in decimal representation of the positive integer x. Chef interests only in functions F_{4}(x) and F_{7}(x). For the given positive integer N he wants to know the total number of different pairs (L; R) such that  F_{4}(L) + F_{4}(L + 1) + ... + F_{4}(R) equals to  F_{7}(L) + F_{7}(L + 1) + ... + F_{7}(R) and 1 \u2264  L \u2264 R \u2264 N.\\n\\n------ Input ------ \\n\\nThe first line contains a single positive integer T, the number of test cases. T test cases follow. The only line of each test case contains a positive integer N .\\n\\n------ Output ------ \\n\\nFor each test case, output a single line containing the answer for the corresponding test case.\\n\\n------ Constraints ------ \\n\\n1 \u2264 T \u2264 100000\\n\\n1 \u2264 N \u2264 100000\\n\\n----- Sample Input 1 ------ \\n3\\n3\\n10\\n100\\n----- Sample Output 1 ------ \\n6\\n31\\n1266\",\n  \"Ground Truth Solution\": \"def precompute():\\n\\tn = 100000\\n\\td = {0: 1}\\n\\ts4 = [0]\\n\\ts7 = [0]\\n\\tfor i in range(1, n + 1):\\n\\t\\tv = str(i)\\n\\t\\ts4.append(s4[-1] + v.count('4'))\\n\\t\\ts7.append(s7[-1] + v.count('7'))\\n\\ts4_7 = [0]\\n\\tfor i in range(1, n + 1):\\n\\t\\ts4_7.append(s4[i] - s7[i])\\n\\tans = [0]\\n\\tfor i in range(1, n + 1):\\n\\t\\tv = s4_7[i]\\n\\t\\tif v in d:\\n\\t\\t\\tans.append(ans[-1] + d[v])\\n\\t\\t\\td[v] += 1\\n\\t\\telse:\\n\\t\\t\\tans.append(ans[-1])\\n\\t\\t\\td[v] = 1\\n\\treturn ans\\nans = precompute()\\nfor _ in range(int(input())):\\n\\tprint(ans[int(input())])\",\n  \"LLM CoT Steps Breakdown\": \"- Problem Understanding: The problem requires finding the number of pairs (L, R) within the range [1, N] such that the sum of the occurrences of the digit '4' in the numbers from L to R is equal to the sum of the occurrences of the digit '7' in the same range.\\n- Precomputation Strategy:  Since N can be up to 100,000 and we have multiple test cases (T up to 100,000), precomputing the counts of '4' and '7' for numbers up to 100,000 is crucial to avoid exceeding the time limit. This allows us to answer each test case quickly using the precomputed values.\\n- Key Insight for Optimization: Recognizing that the condition F_4(L) + ... + F_4(R) == F_7(L) + ... + F_7(R)  is equivalent to (F_4(L) - F_7(L)) + ... + (F_4(R) - F_7(R)) == 0. So, we can create an array of differences between the cumulative counts of '4' and '7'. Then we count how many subarrays have a sum of zero.\\n- Data Structures: A dictionary can be used to store cumulative sums encountered so far in the difference array.  The keys are the cumulative sums, and the values are the counts of how many times each sum appears.\\n- Implementation Details:  First, precompute the cumulative sums of the difference between F_4(i) and F_7(i) for i from 1 to 100,000.  Then, for each test case, look up the precomputed result for the given N.\",\n  \"LLM Questions\": [\n    \"How can you efficiently compute the number of occurrences of digits '4' and '7' in a number, especially considering the large number of test cases?\",\n    \"How can the condition F_4(L) + ... + F_4(R) == F_7(L) + ... + F_7(R) be simplified to make the calculation easier?\",\n    \"What data structures would be suitable for storing precomputed values to optimize the solution, and how would these structures be used?\",\n    \"How can the large number of test cases (T up to 100,000) influence the overall algorithm design and implementation?\",\n    \"Given the range constraint on N (1 to 100,000), what precomputation strategy can be applied to optimize the time complexity?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Convert the number to a string and use the `count()` method to efficiently count occurrences of '4' and '7'. Precomputing these counts for numbers up to 100,000 significantly reduces the time complexity for multiple test cases.\",\n    \"The condition can be simplified by creating a difference array where each element is F_4(i) - F_7(i). The sum from L to R will then be equal to 0. This transformation allows us to focus on finding subarrays with a sum of zero in the difference array.\",\n    \"A dictionary is ideal for storing cumulative sums encountered while traversing the difference array. The keys are the cumulative sums, and the values are the counts of occurrences of each sum. This helps to count subarrays summing to zero efficiently.\",\n    \"The large number of test cases necessitates precomputation to avoid TLE (Time Limit Exceeded). Instead of computing the answer for each test case independently, precompute and store the answer for all N up to 100,000.\",\n    \"Since N can be up to 100,000, precompute the cumulative counts of '4's and '7's for all numbers from 1 to 100,000. Then, for each query, use these precomputed values to determine the answer quickly. Also, precompute the cumulative sums of F_4(i) - F_7(i) for i from 1 to 100,000.\"\n  ]\n}\n```"