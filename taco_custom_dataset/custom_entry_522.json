"```json\n{\n  \"Coding Problem\": \"For a collection of integers $S$, define $\\\\operatorname{mex}(S)$ as the smallest non-negative integer that does not appear in $S$.\\n\\nNIT, the cleaver, decides to destroy the universe. He is not so powerful as Thanos, so he can only destroy the universe by snapping his fingers several times.\\n\\nThe universe can be represented as a 1-indexed array $a$ of length $n$. When NIT snaps his fingers, he does the following operation on the array:\\n\\nHe selects positive integers $l$ and $r$ such that $1\\\\le l\\\\le r\\\\le n$. Let $w=\\\\operatorname{mex}(\\\\{a_l,a_{l+1},\\\\dots,a_r\\\\})$. Then, for all $l\\\\le i\\\\le r$, set $a_i$ to $w$.\\n\\nWe say the universe is destroyed if and only if for all $1\\\\le i\\\\le n$, $a_i=0$ holds.\\n\\nFind the minimum number of times NIT needs to snap his fingers to destroy the universe. That is, find the minimum number of operations NIT needs to perform to make all elements in the array equal to $0$.\\n\\n\\n-----Input-----\\n\\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\\\le t \\\\le 10^4$). Description of the test cases follows.\\n\\nThe first line of each test case contains one integer $n$ ($1\\\\le n\\\\le 10^5$).\\n\\nThe second line of each test case contains $n$ integers $a_1$, $a_2$, $\\\\ldots$, $a_n$ ($0\\\\le a_i\\\\le 10^9$).\\n\\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2\\\\cdot 10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case, print one integer \u2014 the answer to the problem.\\n\\n\\n-----Examples-----\\n\\nInput\\n4\\n4\\n0 0 0 0\\n5\\n0 1 2 3 4\\n7\\n0 2 3 0 1 2 0\\n1\\n1000000000\\nOutput\\n0\\n1\\n2\\n1\\n\\n\\n-----Note-----\\n\\nIn the first test case, we do $0$ operations and all elements in the array are already equal to $0$.\\n\\nIn the second test case, one optimal way is doing the operation with $l=2$, $r=5$.\\n\\nIn the third test case, one optimal way is doing the operation twice, respectively with $l=4$, $r=4$ and $l=2$, $r=6$.\\n\\nIn the fourth test case, one optimal way is doing the operation with $l=1$, $r=1$.\",\n  \"Ground Truth Solution\": \"for s in [*open(0)][2::2]:\\n\\tprint(min(2, len(''.join((' *'[x > '0'] for x in s.split())).split())))\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The core task is to find the minimum number of operations to transform an array to all zeros, where an operation involves selecting a subarray, calculating its MEX, and setting all elements in the subarray to the MEX value.\\n- Identifying Key Insight: The MEX of a subarray will be 0 only if 0 is not present in that subarray. So, we can only convert a subarray to 0 in one operation if it doesn't already contain 0. We can group consecutive non-zero segments together and convert them to 0. Also, it never requires more than two operations.\\n- Strategy Selection: Iterate through the array and count the number of segments of non-zero elements. If no element is non-zero, the answer is 0. Otherwise, the number of operations is the number of segments of non-zero elements. However, note that it never takes more than 2 operations to make every element zero. So, the number of operations will be min(2, number of segments of non-zero elements).\\n- Handling Edge Cases: Consider the case where the array is already all zeros or contains only one element. These cases can impact the initial count of non-zero segments.\\n- Implementation Detail: Implement an iteration that considers consecutive segments of numbers that are not zero, and counts how many such non-zero segments are present.\",\n  \"LLM Questions\": [\n    \"What is the meaning of MEX in this problem, and how does it affect the choice of operations?\",\n    \"How does the presence or absence of zero in a selected range impact the outcome of an operation?\",\n    \"What is the maximum number of operations needed to convert any array to all zeros, and why?\",\n    \"How would you identify and count the segments of non-zero elements within the array efficiently?\",\n    \"What edge cases should you consider when counting these segments to avoid double-counting or incorrect calculations?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"MEX is the smallest non-negative integer not present in a set. It impacts the choice of operations because if we select a subarray with no zeros, its MEX will be zero, allowing us to set the entire subarray to zero.\",\n    \"If zero is not present in the selected range, the MEX of that range will be 0, thus making every element in the range equal to 0 after performing the snap operation. If zero is present, the MEX will be a positive integer, meaning every element in the array will be set to a non-zero positive integer.\",\n    \"The maximum number of operations needed is two. After the first operation, there may be multiple segments of non-zero elements. Since the mex will be assigned to a non-zero positive value, it would separate other potential zero values, which means, we can set the entire array to zero in no more than 2 moves.\",\n    \"Iterate through the array and track transitions between zero and non-zero elements. Each time you encounter a non-zero element after a zero (or at the start of the array), increment the segment count. Similarly, decrement when you encounter a zero after non-zero elements.\",\n    \"Ensure you only count transitions once for each segment. If the array starts with zero, you may need to handle this case separately. Be careful to not double-count segments. If it contains only zeros, then the count is 0.\"\n  ]\n}\n```"