"```json\n{\n  \"Coding Problem\": \"Roger is a robot. He has an arm that is a series of n segments connected to each other. The endpoints of the i-th segment are initially located at points (i - 1, 0) and (i, 0). The endpoint at (i - 1, 0) is colored red and the endpoint at (i, 0) is colored blue for all segments. Thus, the blue endpoint of the i-th segment is touching the red endpoint of the (i + 1)-th segment for all valid i.\\n\\nRoger can move his arm in two different ways:   He can choose some segment and some value. This is denoted as choosing the segment number i and picking some positive l. This change happens as follows: the red endpoint of segment number i and segments from 1 to i - 1 are all fixed in place. Imagine a ray from the red endpoint to the blue endpoint. The blue endpoint and segments i + 1 through n are translated l units in the direction of this ray.\\n\\n [Image] [Image] \\n\\nIn this picture, the red point labeled A and segments before A stay in place, while the blue point labeled B and segments after B gets translated.\\n\\n He can choose a segment and rotate it. This is denoted as choosing the segment number i, and an angle a. The red endpoint of the i-th segment will stay fixed in place. The blue endpoint of that segment and segments i + 1 to n will rotate clockwise by an angle of a degrees around the red endpoint.\\n\\n [Image] [Image] \\n\\nIn this picture, the red point labeled A and segments before A stay in place, while the blue point labeled B and segments after B get rotated around point A. \\n\\nRoger will move his arm m times. These transformations are a bit complicated, and Roger easily loses track of where the blue endpoint of the last segment is. Help him compute the coordinates of the blue endpoint of the last segment after applying each operation. Note that these operations are cumulative, and Roger's arm may intersect itself arbitrarily during the moves.\\n\\n\\n-----Input-----\\n\\nThe first line of the input will contain two integers n and m (1 \u2264 n, m \u2264 300 000)\u00a0\u2014 the number of segments and the number of operations to perform.\\n\\nEach of the next m lines contains three integers x_{i}, y_{i} and z_{i} describing a move. If x_{i} = 1, this line describes a move of type 1, where y_{i} denotes the segment number and z_{i} denotes the increase in the length. If x_{i} = 2, this describes a move of type 2, where y_{i} denotes the segment number, and z_{i} denotes the angle in degrees. (1 \u2264 x_{i} \u2264 2, 1 \u2264 y_{i} \u2264 n, 1 \u2264 z_{i} \u2264 359)\\n\\n\\n-----Output-----\\n\\nPrint m lines. The i-th line should contain two real values, denoting the coordinates of the blue endpoint of the last segment after applying operations 1, ..., i. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 4}.\\n\\nNamely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if $\\\\frac{|a - b|}{\\\\operatorname{max}(1, b)} \\\\leq 10^{-4}$ for all coordinates.\\n\\n\\n-----Examples-----\\nInput\\n5 4\\n1 1 3\\n2 3 90\\n2 5 48\\n1 4 1\\n\\nOutput\\n8.0000000000 0.0000000000\\n5.0000000000 -3.0000000000\\n4.2568551745 -2.6691306064\\n4.2568551745 -3.6691306064\\n\\n\\n\\n-----Note-----\\n\\nThe following pictures shows the state of the arm after each operation. The coordinates of point F are printed after applying each operation. For simplicity, we only show the blue endpoints of a segment (with the exception for the red endpoint of the first segment). For instance, the point labeled B is the blue endpoint for segment 1 and also the red endpoint for segment 2.\\n\\nInitial state:  [Image]  Extend segment 1 by 3.  [Image]  Rotate segment 3 by 90 degrees clockwise.  [Image]  Rotate segment 5 by 48 degrees clockwise.  [Image]  Extend segment 4 by 1.  [Image]\",\n  \"Ground Truth Solution\": \"from cmath import rect\\nimport sys\\nimport math\\nfrom functools import reduce\\n\\nclass SegmentTree:\\n\\n\\tdef __init__(self, L, function=lambda x, y: x + y):\\n\\t\\tself.function = function\\n\\t\\tN = self.size = len(L)\\n\\t\\tM = 1 << N.bit_length()\\n\\t\\tself.margin = 2 * M - N\\n\\t\\tself.L = [None for i in range(self.margin)] + L\\n\\t\\tfor i in range(M - 1, 0, -1):\\n\\t\\t\\t(x, y) = (self.L[i << 1], self.L[i << 1 | 1])\\n\\t\\t\\tself.L[i] = None if x is None or y is None else function(x, y)\\n\\n\\tdef modify(self, pos, value):\\n\\t\\tp = pos + self.margin\\n\\t\\tself.L[p] = value\\n\\t\\twhile p > 1:\\n\\t\\t\\t(x, y) = (self.L[p], self.L[p ^ 1])\\n\\t\\t\\tif p & 1:\\n\\t\\t\\t\\t(x, y) = (y, x)\\n\\t\\t\\tself.L[p >> 1] = None if x is None or y is None else self.function(x, y)\\n\\t\\t\\tp >>= 1\\n\\n\\tdef query(self, left, right):\\n\\t\\t(l, r) = (left + self.margin, right + self.margin)\\n\\t\\tstack = []\\n\\t\\tvoid = True\\n\\t\\twhile l < r:\\n\\t\\t\\tif l & 1:\\n\\t\\t\\t\\tif void:\\n\\t\\t\\t\\t\\tresult = self.L[l]\\n\\t\\t\\t\\t\\tvoid = False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult = self.function(result, self.L[l])\\n\\t\\t\\t\\tl += 1\\n\\t\\t\\tif r & 1:\\n\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\tstack.append(self.L[r])\\n\\t\\t\\tl >>= 1\\n\\t\\t\\tr >>= 1\\n\\t\\tinit = stack.pop() if void else result\\n\\t\\treturn reduce(self.function, reversed(stack), init)\\n\\ndef degrect(r, phi):\\n\\treturn rect(r, math.radians(phi))\\n\\ndef vsum(u, v):\\n\\treturn (u[0] + v[0] * degrect(1, u[1]), (u[1] + v[1]) % 360)\\n\\ndef solve(f):\\n\\t(n, m) = [int(x) for x in f.readline().split()]\\n\\tsegments = [[1, 0] for i in range(n)]\\n\\tarm = SegmentTree([(1, 0) for i in range(n)], vsum)\\n\\tfor line in f:\\n\\t\\t(q, i, a) = [int(x) for x in line.split()]\\n\\t\\tif q == 1:\\n\\t\\t\\tsegments[i - 1][0] += a\\n\\t\\telse:\\n\\t\\t\\tsegments[i - 1][1] -= a\\n\\t\\tarm.modify(i - 1, (degrect(segments[i - 1][0], segments[i - 1][1]), segments[i - 1][1]))\\n\\t\\tquery = arm.query(0, n)[0]\\n\\t\\tprint(query.real, query.imag)\\nsolve(sys.stdin)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a robot arm consisting of n segments. The arm can be manipulated in two ways: extending a segment or rotating a segment. The goal is to compute the coordinates of the blue endpoint of the last segment after each manipulation.\\n- Data Structures and Representation: Represent each segment by its length and angle relative to the x-axis. Keep track of the cumulative effect of each manipulation. Using complex numbers makes it easier to track the position of the end point, converting the angle into radians.\\n- Algorithm Selection: Iterate through each of the m moves. For each move, update the length or angle of the affected segment. Then, recalculate the final coordinates of the arm's endpoint by summing the vectors of all segments, considering the cumulative rotations. Use segment tree data structure to optimize the update and query operations for changes made to segments of robot arm.\\n- Computational Complexity: The segment tree is used for efficiently updating and querying the arm's configuration after each move. For the segment tree it will have O(logn) per move. Also, converting angles to radians and using complex numbers introduce additional computational overhead, but can be minimized through optimization of the segment tree.\",\n  \"LLM Questions\": [\n    \"How can the segments of the robot arm be represented such that rotations and extensions can be easily computed?\",\n    \"What data structure could be used to efficiently update and query the changes made to the segments after each move?\",\n    \"How are the final coordinates of the blue endpoint of the last segment computed after each manipulation?\",\n    \"What approach can you use to keep track of the cumulative transformations applied to the robot arm and to improve computational complexity?\",\n    \"When updating segment information in a segment tree, what would be the time complexity of this update?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Each segment can be represented as a tuple of (length, angle). The angle represents the orientation of the segment relative to the x-axis. Complex numbers can also be used to represent the segments such that transformations can be efficiently tracked and applied.\",\n    \"A segment tree can be used to efficiently update the length or angle of a segment and query the cumulative transformation applied to all segments up to the last segment. This allows the endpoint coordinates to be recalculated efficiently after each move.\",\n    \"The final coordinates are computed by iterating through each segment and summing their vector components, considering their cumulative rotations. In particular, converting length and angle to a complex number and summing up all these complex numbers gives the final position.\",\n    \"A segment tree can be used to keep track of the cumulative rotations and extensions, updating the tree after each move and querying the tree to calculate the final position of the arm's endpoint. This will improve the computational complexity compared to a naive approach of recomputing the coordinates from scratch after each move.\",\n    \"Updating segment information in a segment tree will typically have a time complexity of O(log n), where n is the number of segments. This is because updating a segment in the tree requires traversing from the leaf node (representing the segment) to the root node, updating the intermediate nodes along the path.\"\n  ]\n}\n```"