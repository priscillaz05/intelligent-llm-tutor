"```json\n{\n  \"Coding Problem\": \"A [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree) is a binary tree that is ordered. This means that if you were to convert the tree to an array using an in-order traversal, the array would be in sorted order. The benefit gained by this ordering is that when the tree is balanced, searching is a logarithmic time operation, since each node you look at that isn't the one you're searching for lets you discard half of the tree.\\n\\nIf you haven't worked with binary trees before or don't understand what a traversal is, you can learn more about that here: https://www.codewars.com/kata/binary-tree-traversal.\\n\\nIn this kata, you will write a function that will validate that a given binary tree is a binary search tree. The sort order is not predefined so it should work with either.\\n\\nThese are valid binary search trees:\\n\\n        5\\n       / \\\\\\n      2   7\\n     / \\\\   \\\\\\n    1   3   9\\n\\n\\n      7\\n     / \\\\\\n    9   2\\n\\n\\nwhile these are not:\\n\\n      1\\n     / \\\\\\n    2   3\\n\\n\\n      5\\n     / \\\\\\n    2   9\\n     \\\\\\n      7\\n\\nThere are several different approaches you can take to solve this kata. If you're not as comfortable with recursion I'd recommend practicing that.\\n\\nNote: no test case tree will contain duplicate numbers.\",\n  \"Ground Truth Solution\": \"class T:\\n\\n\\tdef __init__(self, value, left=None, right=None):\\n\\t\\tself.value = value\\n\\t\\tself.left = left\\n\\t\\tself.right = right\\n\\ndef is_bst(node):\\n\\n\\tdef extract(node):\\n\\t\\tif node is not None:\\n\\t\\t\\tyield from extract(node.left)\\n\\t\\t\\tyield node.value\\n\\t\\t\\tyield from extract(node.right)\\n\\tgen = extract(node)\\n\\ttry:\\n\\t\\t(u, v) = (next(gen), next(gen))\\n\\texcept StopIteration:\\n\\t\\treturn True\\n\\tcmp = u < v\\n\\tfor w in gen:\\n\\t\\tif cmp != (v < w):\\n\\t\\t\\treturn False\\n\\t\\tv = w\\n\\treturn True\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Binary Search Tree (BST) Properties: Recognize that a BST maintains an ordered structure where an in-order traversal yields a sorted sequence. Understand that the order (ascending or descending) is not predefined but must be consistent throughout the tree.\\n- Identifying Potential Edge Cases: Consider empty trees, single-node trees, and trees where all nodes are in ascending or descending order. Also, consider the case where the tree is not ordered.\\n- Selecting an Algorithmic Strategy: Consider using an in-order traversal to extract the values of the nodes into a sequence. Then, verify that the sequence is sorted either in ascending or descending order.\\n- Implementing Validation Logic: Implement the logic to check if the extracted sequence is sorted and ensure that the sort order is consistent throughout the tree.\",\n  \"LLM Questions\": [\n    \"What properties define a Binary Search Tree (BST) and how does an in-order traversal relate to these properties?\",\n    \"What edge cases should be considered when validating a BST, such as an empty tree or a tree with only one node?\",\n    \"How can you handle both ascending and descending order BSTs without prior knowledge of the order?\",\n    \"What steps are involved in extracting and validating the sequence of node values to determine if the tree is a valid BST?\",\n    \"How can you ensure the sort order (ascending or descending) is consistent throughout the tree?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A BST is defined by the property that for each node, all nodes in its left subtree are less than the node's value, and all nodes in its right subtree are greater. In-order traversal of a BST produces a sorted sequence of the node values.\",\n    \"Edge cases include empty trees (which are valid BSTs), single-node trees (also valid), and trees with all nodes in ascending or descending order.\",\n    \"You can infer the order by checking the first two elements in the in-order traversal. If the first element is less than the second, it's an ascending order; otherwise, it's a descending order. Once the order is determined, ensure that all subsequent elements follow the same order.\",\n    \"The steps involve performing an in-order traversal to extract the values, then iterating through the sequence to verify that it is sorted according to a consistent order (either ascending or descending).\",\n    \"After determining the sort order from the first two nodes in the in-order sequence, compare each subsequent node to ensure it maintains the same sort order throughout the traversal. Any violation indicates that the tree is not a valid BST.\"\n  ]\n}\n```"