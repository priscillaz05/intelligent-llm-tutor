"```json\n{\n  \"Coding Problem\": \"You have an array $a$ of length $n$. For every positive integer $x$ you are going to perform the following operation during the $x$-th second:\\n\\n  Select some distinct indices $i_{1}, i_{2}, \\ldots, i_{k}$ which are between $1$ and $n$ inclusive, and add $2^{x-1}$ to each corresponding position of $a$. Formally, $a_{i_{j}} := a_{i_{j}} + 2^{x-1}$ for $j = 1, 2, \\ldots, k$. Note that you are allowed to not select any indices at all. \\n\\nYou have to make $a$ nondecreasing as fast as possible. Find the smallest number $T$ such that you can make the array nondecreasing after at most $T$ seconds.\\n\\nArray $a$ is nondecreasing if and only if $a_{1} \\\\le a_{2} \\\\le \\\\ldots \\\\le a_{n}$.\\n\\nYou have to answer $t$ independent test cases.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $t$ ($1 \\\\le t \\\\le 10^{4}$)\u00a0\u2014 the number of test cases.\\n\\nThe first line of each test case contains single integer $n$ ($1 \\\\le n \\\\le 10^{5}$)\u00a0\u2014 the length of array $a$. It is guaranteed that the sum of values of $n$ over all test cases in the input does not exceed $10^{5}$.\\n\\nThe second line of each test case contains $n$ integers $a_{1}, a_{2}, \\\\ldots, a_{n}$ ($-10^{9} \\\\le a_{i} \\\\le 10^{9}$).\\n\\n\\n-----Output-----\\n\\nFor each test case, print the minimum number of seconds in which you can make $a$ nondecreasing.\\n\\n\\n-----Example-----\\nInput\\n3\\n4\\n1 7 6 5\\n5\\n1 2 3 4 5\\n2\\n0 -4\\n\\nOutput\\n2\\n0\\n3\\n\\n\\n\\n-----Note-----\\n\\nIn the first test case, if you select indices $3, 4$ at the $1$-st second and $4$ at the $2$-nd second, then $a$ will become $[1, 7, 7, 8]$. There are some other possible ways to make $a$ nondecreasing in $2$ seconds, but you can't do it faster.\\n\\nIn the second test case, $a$ is already nondecreasing, so answer is $0$.\\n\\nIn the third test case, if you do nothing at first $2$ seconds and select index $2$ at the $3$-rd second, $a$ will become $[0, 0]$.\",\n  \"Ground Truth Solution\": \"import sys\\nimport math\\n\\ndef answer(n, a):\\n\\tcurr_step = 0\\n\\tif n == 1:\\n\\t\\treturn 0\\n\\tmx = a[0]\\n\\tmxd = 0\\n\\tfor i in range(1, n):\\n\\t\\tif a[i] > mx:\\n\\t\\t\\tmx = a[i]\\n\\t\\td = mx - a[i]\\n\\t\\tif d > mxd:\\n\\t\\t\\tnsf0 = math.floor(math.log2(d)) + 1\\n\\t\\t\\tmxd = 2 ** nsf0 - 1\\n\\treturn int(math.log2(mxd + 1))\\n\\ndef main():\\n\\tt = int(sys.stdin.readline())\\n\\twhile t:\\n\\t\\tn = int(sys.stdin.readline())\\n\\t\\ta = tuple(map(int, sys.stdin.readline().split()))\\n\\t\\tprint(answer(n, a))\\n\\t\\tt -= 1\\n\\treturn\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Problem Constraints: The goal is to determine the minimum number of seconds (T) to make an array 'a' non-decreasing. In each second 'x', you can add 2^(x-1) to any subset of elements in 'a'.\\n- Identifying Potential Pitfalls: The key is to understand that adding to the elements allows to correct for any descrepencies. To minimize T you must act greedily and quickly.\\n- Selecting an Algorithmic Strategy: Iterate through the array, keeping track of the maximum value seen so far. When a value is smaller than the current max, find the difference and calculate the smallest power of 2 that would fix this difference. The number of seconds needed is related to the largest power of 2 found.\\n- Implementing In-Place Modification: It is crucial to not perform the operations themselves but to simulate their effect by finding the max difference required and determining the number of steps needed to achieve it using powers of 2.\",\n  \"LLM Questions\": [\n    \"What does it mean for an array to be non-decreasing, and how does that influence the objective?\",\n    \"How does the ability to add powers of 2 in each second simplify the process of making the array non-decreasing?\",\n    \"What is a good strategy to find the minimum T when we can add to any combination of array elements in powers of 2?\",\n    \"How can we determine the maximum difference needed to ensure that the array will be non-decreasing?\",\n    \"How do we calculate the minimum number of seconds 'T' once the maximum difference is known?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"An array is non-decreasing if each element is greater than or equal to the element before it. The objective is to make the array non-decreasing with the fewest number of operations by adding powers of 2 to elements.\",\n    \"Since we can add powers of 2 in each second, the key is to find the largest difference between the current element and the maximum value encountered so far. We want to close this gap as fast as possible.\",\n    \"A greedy strategy is to iterate from left to right, maintaining the maximum value seen so far. For each element, determine how much needs to be added to make it at least equal to the maximum. The total number of steps depends on the maximum difference encountered.\",\n    \"We iterate through the array, keep track of the maximum value so far. If an element is smaller than the max so far, we find the difference. The maximum such difference is the key.\",\n    \"If the maximum difference is 'd', then we need to find the smallest 'T' such that 2^T >= d. That implies that T = ceil(log2(d+1)), since in T steps the maximum addition we can make is the sum of all 2^i from i=0 to T-1 = 2^T-1.  Thus, 2^T-1 must be >= d so T = ceil(log2(d+1))\"\n  ]\n}\n```"