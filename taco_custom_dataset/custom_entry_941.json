"```json\n{\n  \"Coding Problem\": \"Team Red and Team Blue competed in a competitive FPS. Their match was streamed around the world. They played a series of $n$ matches.\\n\\nIn the end, it turned out Team Red won $r$ times and Team Blue won $b$ times. Team Blue was less skilled than Team Red, so $b$ was strictly less than $r$.\\n\\nYou missed the stream since you overslept, but you think that the match must have been neck and neck since so many people watched it. So you imagine a string of length $n$ where the $i$-th character denotes who won the $i$-th match  \u2014 it is R if Team Red won or B if Team Blue won. You imagine the string was such that the maximum number of times a team won in a row was as small as possible. For example, in the series of matches RBBRRRB, Team Red won $3$ times in a row, which is the maximum.\\n\\nYou must find a string satisfying the above conditions. If there are multiple answers, print any.\\n\\n\\n-----Input-----\\n\\nThe first line contains a single integer $t$ ($1 \\\\le t \\\\le 1000$)  \u2014 the number of test cases.\\n\\nEach test case has a single line containing three integers $n$, $r$, and $b$ ($3 \\\\leq n \\\\leq 100$; $1 \\\\leq b < r \\\\leq n$, $r+b=n$).\\n\\n\\n-----Output-----\\n\\nFor each test case, output a single line containing a string satisfying the given conditions. If there are multiple answers, print any.\\n\\n\\n-----Examples-----\\n\\nInput\\n3\\n7 4 3\\n6 5 1\\n19 13 6\\nOutput\\nRBRBRBR\\nRRRBRR\\nRRBRRBRRBRRBRRBRRBR\\nInput\\n6\\n3 2 1\\n10 6 4\\n11 6 5\\n10 9 1\\n10 8 2\\n11 9 2\\nOutput\\nRBR\\nRRBRBRBRBR\\nRBRBRBRBRBR\\nRRRRRBRRRR\\nRRRBRRRBRR\\nRRRBRRRBRRR\\n\\n\\n-----Note-----\\n\\nThe first test case of the first example gives the optimal answer for the example in the statement. The maximum number of times a team wins in a row in RBRBRBR is $1$. We cannot minimize it any further.\\n\\nThe answer for the second test case of the second example is RRBRBRBRBR. The maximum number of times a team wins in a row is $2$, given by RR at the beginning. We cannot minimize the answer any further.\",\n  \"Ground Truth Solution\": \"for n in [*open(0)][1:]:\\n\\t(n, r, b) = map(int, n.split())\\n\\tb += 1\\n\\tc = r // b * 'R' + 'B'\\n\\tprint((('R' + c) * (r % b) + c * n)[:n])\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Problem Requirements: The task is to construct a string of length n with r 'R's and b 'B's, where b < r. The goal is to minimize the maximum consecutive occurrences of 'R'.\\n- Identifying Key Ratios and Remainders: Calculate how many 'R's can be grouped together before inserting a 'B'. This is determined by r // (b + 1) since we want to distribute 'R's as evenly as possible among b + 1 groups. The remainder r % (b + 1) determines how many of these groups need an additional 'R'.\\n- String Construction Strategy: Start by repeating \\\"R\\\" r // (b + 1) times and appending a \\\"B\\\". This pattern is then repeated as many times as possible. If there's a remainder from r // (b+1), add an extra 'R' to the beginning of some of the repeated sequences.\\n- Handling Edge Cases: The code efficiently manages several edge cases implicitly by correctly calculating the number of 'R's per group and distributing any remainder 'R's. Ensures that the output string contains exactly n characters.\",\n  \"LLM Questions\": [\n    \"How do you determine the number of consecutive 'R's before inserting a 'B' to minimize consecutive occurrences?\",\n    \"How do you handle the remaining 'R's after dividing the total 'R's into equal groups based on the number of 'B's?\",\n    \"How does the chosen solution account for the total length 'n' of the output string?\",\n    \"What is the significance of using (b+1) in calculating the groups of 'R's?\",\n    \"How does the solution ensure the constraint b < r is always satisfied?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"To minimize consecutive occurrences of 'R', divide the total number of 'R's (r) by the number of 'B's plus 1 (b + 1). The integer division r // (b + 1) gives the number of consecutive 'R's before each 'B'.\",\n    \"The remainder r % (b + 1) tells how many groups of 'R's need an extra 'R'. These extra 'R's are added at the beginning of the string construction to minimize the maximum consecutive 'R's.\",\n    \"The code uses string slicing [ : n] at the end to ensure that the generated string is truncated to length 'n'. This handles cases where the initial string construction results in a string longer than 'n'.\",\n    \"Using (b + 1) divides 'R's into b+1 groups that 'B's will separate. This is the correct approach to minimize consecutive occurrences. The one is added to the b for the end.\",\n    \"The problem statement ensures that b < r. This condition is assumed to be true when constructing the output, so no specific check is needed within the implemented code.\"\n  ]\n}\n```"