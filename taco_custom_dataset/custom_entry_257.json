"```json\n{\n  \"Coding Problem\": \"You are given an undirected graph where each edge has one of two colors: black or red.\\n\\nYour task is to assign a real number to each node so that: \\n\\n  * for each black edge the sum of values at its endpoints is 1; \\n  * for each red edge the sum of values at its endpoints is 2; \\n  * the sum of the absolute values of all assigned numbers is the smallest possible. \\n\\n\\n\\nOtherwise, if it is not possible, report that there is no feasible assignment of the numbers.\\n\\nInput\\n\\nThe first line contains two integers N (1 \u2264 N \u2264 100 000) and M (0 \u2264 M \u2264 200 000): the number of nodes and the number of edges, respectively. The nodes are numbered by consecutive integers: 1, 2, \u2026, N.\\n\\nThe next M lines describe the edges. Each line contains three integers a, b and c denoting that there is an edge between nodes a and b (1 \u2264 a, b \u2264 N) with color c (1 denotes black, 2 denotes red).\\n\\nOutput\\n\\nIf there is a solution, the first line should contain the word \\\"YES\\\" and the second line should contain N space-separated numbers. For each i (1 \u2264 i \u2264 N), the i-th number should be the number assigned to the node i.\\n\\nOutput should be such that: \\n\\n  * the sum of the numbers at the endpoints of each edge differs from the precise value by less than 10^{-6}; \\n  * the sum of the absolute values of all assigned numbers differs from the smallest possible by less than 10^{-6}. \\n\\n\\n\\nIf there are several valid solutions, output any of them.\\n\\nIf there is no solution, the only line should contain the word \\\"NO\\\".\",\n  \"Ground Truth Solution\": \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline()\\n\\ndef RL():\\n\\treturn map(int, sys.stdin.readline().split())\\n\\ndef RLL():\\n\\treturn list(map(int, sys.stdin.readline().split())\\n\\ndef N():\\n\\treturn int(input())\\n\\ndef print_list(l):\\n\\tprint(' '.join(map(str, l)))\\n(n, m) = RL()\\ndic = [[] for _ in range(n + 1)]\\nfor _ in range(m):\\n\\t(u, v, t) = RL()\\n\\tdic[u].append((v, t))\\n\\tdic[v].append((u, t))\\nv = [None] * (n + 1)\\nf = [True] * (n + 1)\\nkey = {}\\ncolor = [0] * (n + 1)\\nflag = True\\nfor s in range(1, n + 1):\\n\\tif v[s] is not None:\\n\\t\\tcontinue\\n\\tv[s] = 0\\n\\tcolor[s] = s\\n\\tnow = [s]\\n\\tss = [0]\\n\\twhile now and flag:\\n\\t\\tp = now.pop()\\n\\t\\tfor (child, t) in dic[p]:\\n\\t\\t\\tif v[child] is not None:\\n\\t\\t\\t\\tif f[child] != f[p]:\\n\\t\\t\\t\\t\\tif v[child] + v[p] != t:\\n\\t\\t\\t\\t\\t\\tflag = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif f[child] is True:\\n\\t\\t\\t\\t\\tif s not in key:\\n\\t\\t\\t\\t\\t\\tkey[s] = (v[child] + v[p] - t) / -2\\n\\t\\t\\t\\t\\telif v[child] + v[p] + key[s] * 2 != t:\\n\\t\\t\\t\\t\\t\\tflag = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif s not in key:\\n\\t\\t\\t\\t\\tkey[s] = (v[child] + v[p] - t) / 2\\n\\t\\t\\t\\telif v[child] + v[p] - key[s] * 2 != t:\\n\\t\\t\\t\\t\\tflag = False\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\telse:\\n\\t\\t\\t\\tv[child] = t - v[p]\\n\\t\\t\\t\\tf[child] = not f[p]\\n\\t\\t\\t\\tif f[child]:\\n\\t\\t\\t\\t\\tss.append(-1 * v[child])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tss.append(v[child])\\n\\t\\t\\t\\tcolor[child] = s\\n\\t\\t\\t\\tnow.append(child)\\n\\t\\tif not flag:\\n\\t\\t\\tbreak\\n\\t\\tif s not in key:\\n\\t\\t\\tss.sort()\\n\\t\\t\\tnn = len(ss)\\n\\t\\t\\tkey[s] = (ss[nn >> 1] + ss[nn - 1 >> 1]) / 2\\nif flag:\\n\\tprint('YES')\\n\\tres = []\\n\\tfor i in range(1, n + 1):\\n\\t\\tif f[i]:\\n\\t\\t\\tres.append(v[i] + key[color[i]])\\n\\t\\telse:\\n\\t\\t\\tres.append(v[i] - key[color[i]])\\n\\tprint_list(res)\\nelse:\\n\\tprint('NO')\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires assigning values to nodes in a graph such that the sum of values for nodes connected by black edges is 1 and for red edges is 2. The goal is to minimize the sum of the absolute values of assigned numbers.\\n- Identifying Potential Issues: The problem may have constraints that make it impossible to find a feasible assignment. Cycles in the graph and conflicting edge requirements can lead to such infeasibility.\\n- Selecting an Algorithmic Strategy: Use a graph traversal algorithm (e.g., Depth-First Search) to explore the graph and determine values for each node. Recognize that connected components can be solved independently. Within each component, maintain equations based on edge colors. Use a variable offset (key) for each component to minimize the absolute values.\\n- Implementing Graph Traversal and Equation Solving: During traversal, keep track of the relative values of the nodes. When a conflict occurs (e.g., an edge violates the sum constraint), report \\\"NO\\\". If no conflict occurs, the median value within each connected component will be chosen and assigned in order to minimize the absolute values. If the median can not be reached, then report \\\"NO\\\".\\n- Handling Infeasibility: Check for inconsistencies during traversal. Inconsistencies include edge sums not matching the specified constraints or the overall system of equations being unsolvable. If any inconsistency is detected, the algorithm must output \\\"NO\\\".\",\n  \"LLM Questions\": [\n    \"How can you determine if the graph is bipartite, and how does that affect the solvability of the problem?\",\n    \"What data structures are suitable for representing the graph and the assigned values for the nodes?\",\n    \"How do you handle the condition of minimizing the sum of absolute values of the assigned numbers? What is the best strategy for this?\",\n    \"What are the key steps in checking for inconsistencies in the assigned node values based on edge colors?\",\n    \"How can you structure the code to handle large inputs (up to 100,000 nodes and 200,000 edges) efficiently?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Bipartiteness isn't directly applicable here because edges aren't alternating between two sets; instead, the edge colors dictate different sum constraints. However, detecting cycles and conflicts in edge constraints is important. Certain cycle configurations might lead to contradictory equations, making the assignment impossible.\",\n    \"An adjacency list is suitable for representing the graph, allowing efficient traversal and access to neighboring nodes. Arrays or dictionaries can store the assigned values for nodes, with an array being more memory-efficient if node IDs are contiguous.\",\n    \"To minimize the sum of absolute values, the assigned values should be centered around zero. The optimal strategy involves choosing a 'key' (or offset) for each connected component such that the median of the node values in that component is effectively shifted to zero. This balances positive and negative values, minimizing the absolute sum.\",\n    \"Inconsistencies arise when, during graph traversal, the sum of values assigned to nodes connected by an edge does not match the edge color constraint (1 for black, 2 for red). You must check this condition every time you assign or update a node's value, considering any existing values on neighboring nodes.\",\n    \"For large inputs, efficient data structures (adjacency lists), optimized traversal (DFS or BFS), and minimal memory usage are crucial. Using fast I/O techniques can significantly speed up input and output operations. Also, confirm that all operations are O(1) or O(logN) where applicable.\"\n  ]\n}\n```"