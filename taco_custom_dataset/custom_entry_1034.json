"```json\n{\n  \"Coding Problem\": \"Omkar is building a waterslide in his water park, and he needs your help to ensure that he does it as efficiently as possible.\\n\\nOmkar currently has $n$ supports arranged in a line, the $i$-th of which has height $a_i$. Omkar wants to build his waterslide from the right to the left, so his supports must be nondecreasing in height in order to support the waterslide. In $1$ operation, Omkar can do the following: take any contiguous subsegment of supports which is nondecreasing by heights and add $1$ to each of their heights. \\n\\nHelp Omkar find the minimum number of operations he needs to perform to make his supports able to support his waterslide!\\n\\nAn array $b$ is a subsegment of an array $c$ if $b$ can be obtained from $c$ by deletion of several (possibly zero or all) elements from the beginning and several (possibly zero or all) elements from the end.\\n\\nAn array $b_1, b_2, \\\\dots, b_n$ is called nondecreasing if $b_i\\\\le b_{i+1}$ for every $i$ from $1$ to $n-1$.\\n\\n\\n-----Input-----\\n\\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\\\leq t \\\\leq 100$). Description of the test cases follows.\\n\\nThe first line of each test case contains an integer $n$ ($1 \\\\leq n \\\\leq 2 \\\\cdot 10^5$)\u00a0\u2014 the number of supports Omkar has.\\n\\nThe second line of each test case contains $n$ integers $a_{1},a_{2},...,a_{n}$ $(0 \\\\leq a_{i} \\\\leq 10^9)$\u00a0\u2014 the heights of the supports.\\n\\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\\\cdot 10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations Omkar needs to perform to make his supports able to support his waterslide.\\n\\n\\n-----Example-----\\nInput\\n3\\n4\\n5 3 2 5\\n5\\n1 2 3 5 3\\n3\\n1 1 1\\n\\nOutput\\n3\\n2\\n0\\n\\n\\n-----Note-----\\n\\nThe subarray with which Omkar performs the operation is bolded.\\n\\nIn the first test case:\\n\\nFirst operation:\\n\\n$[5, 3, \\\\textbf{2}, 5] \\\\to [5, 3, \\\\textbf{3}, 5]$\\n\\nSecond operation:\\n\\n$[5, \\\\textbf{3}, \\\\textbf{3}, 5] \\\\to [5, \\\\textbf{4}, \\\\textbf{4}, 5]$\\n\\nThird operation:\\n\\n$[5, \\\\textbf{4}, \\\\textbf{4}, 5] \\\\to [5, \\\\textbf{5}, \\\\textbf{5}, 5]$\\n\\nIn the third test case, the array is already nondecreasing, so Omkar does $0$ operations.\",\n  \"Ground Truth Solution\": \"t = int(input())\\nfor i in range(t):\\n\\tn = int(input())\\n\\ta = list(map(int, input().split()))\\n\\ts = 0\\n\\tfor i in range(n - 1):\\n\\t\\tif a[i] > a[i + 1]:\\n\\t\\t\\ts += a[i] - a[i + 1]\\n\\tprint(s)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem Requirements: The task is to find the minimum number of operations required to make the input array non-decreasing. An operation involves selecting a contiguous non-decreasing subsegment and incrementing each element in the subsegment by 1.\\n- Identifying Key Insight: The number of operations is determined by the sum of the differences between consecutive elements where the element on the left is greater than the element on the right. This is because each such difference requires that many operations to 'bring' the smaller value up to the larger one.\\n- Devising Algorithm: Iterate through the array, and for each pair of consecutive elements, if the left element is greater than the right element, add their difference to the total operations count. Otherwise, continue to the next pair.\\n- Handling Edge Cases: The input array can contain positive integers or 0. When the given array is already non-decreasing, the result should be 0.\",\n  \"LLM Questions\": [\n    \"What is the core objective of the problem, and how can you mathematically represent the operations to achieve this?\",\n    \"How do you approach identifying where operations need to be performed to make the array non-decreasing?\",\n    \"Why does the sum of differences between consecutive decreasing elements give the minimum number of operations?\",\n    \"What does it mean for an array to be non-decreasing, and how would you algorithmically check for this condition?\",\n    \"Can you walk through a specific example, explaining each step of how the minimum number of operations is calculated, using the proposed algorithm?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The core objective is to make the array non-decreasing with the minimum number of operations. Each operation increments a contiguous non-decreasing subsegment by 1. Mathematically, the goal is to minimize the sum of increments applied to subsegments.\",\n    \"You can identify locations for operations by iterating through the array and checking if a[i] > a[i+1]. This indicates that at least a[i] - a[i+1] operations need to be performed to make that segment non-decreasing.\",\n    \"Each difference a[i] - a[i+1] (where a[i] > a[i+1]) requires at least that many operations to increase a[i+1] to a[i]. Since you only increment non-decreasing contiguous subsequences, these differences are independent; thus, summing them gives the minimum number of operations.\",\n    \"An array is non-decreasing if each element is less than or equal to the element that follows it (a[i] <= a[i+1] for all i). Algorithmically, iterate through the array and check this condition. If the condition holds for all pairs, the array is non-decreasing.\",\n    \"Consider the input [5, 3, 2, 5]. Iterate through the array:\\n- 5 > 3, so add 5 - 3 = 2 to the operations count.\\n- 3 > 2, so add 3 - 2 = 1 to the operations count.\\n- 2 < 5, so no operation is required.\\nThe minimum operations is 2 + 1 = 3.\"\n  ]\n}\n```"