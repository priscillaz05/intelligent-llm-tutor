"```json\n{\n  \"Coding Problem\": \"Implement a function that normalizes out of range sequence indexes (converts them to 'in range' indexes) by making them repeatedly 'loop' around the array. The function should then return the value at that index. Indexes that are not out of range should be handled normally and indexes to empty sequences should return undefined/None depending on the language.\\n\\nFor positive numbers that are out of range, they loop around starting at the beginning, so \\n\\n```python\\nnorm_index_test(seq, len(seq))     # Returns first element\\nnorm_index_test(seq, len(seq) + 1) # Returns second element\\nnorm_index_test(seq, len(seq) + 2) # Returns third element\\n# And so on...\\nnorm_index_test(seq, len(seq) * 2) # Returns first element\\n```\\n\\nFor negative numbers, they loop starting from the end, so\\n\\n```python norm_index_test(seq, len(seq))\\nnorm_index_test(seq, -1)        # Returns last element\\nnorm_index_test(seq, -2)        # Returns second to last element\\nnorm_index_test(seq, -3)        # Returns third to last element\\n# And so on...\\nnorm_index_test(seq, -len(seq)) # Returns first element\\n```\",\n  \"Ground Truth Solution\": \"def norm_index_test(a, n):\\n\\tif a:\\n\\t\\treturn a[n % len(a)]\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires normalizing potentially out-of-bounds indexes for a sequence (list or array) by making them 'loop' around. Positive out-of-range indices loop from the beginning, while negative indices loop from the end.\\n- Handling Empty Sequences: The function should return None if the input sequence is empty.\\n- Implementing the Looping Logic: The modulo operator (%) is crucial for achieving the looping effect. It provides the remainder of a division, effectively mapping any integer to a valid index within the sequence's bounds. The modulo operator handles looping for both positive and negative numbers.\\n- Returning the Element: After normalization, the element at the calculated index should be returned.\",\n  \"LLM Questions\": [\n    \"What is the core task of the function?\",\n    \"How should the function handle an empty sequence?\",\n    \"How can the modulo operator help normalize the index for both positive and negative numbers?\",\n    \"What is the purpose of normalization and why is it necessary?\",\n    \"Could the same logic implemented above work for other data structures, such as tuples or strings?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The core task is to normalize out-of-range indexes for a sequence by 'looping' them around within the valid index range and then returning the element at the normalized index.\",\n    \"If the input sequence is empty, the function should return None.\",\n    \"The modulo operator (%) provides the remainder when the index is divided by the sequence length. This remainder is a valid index within the sequence, effectively causing the index to 'loop' around. It works for positive and negative numbers as Python\u2019s modulo function accounts for sign.\",\n    \"Normalization ensures that any given index, even if out of bounds, can be mapped to a valid index within the array/sequence, allowing access to elements without errors or exceptions.\",\n    \"Yes, the same logic applies as tuples and strings are also sequences and support element access by index. The function only needs to verify that the input is a sequence to prevent exceptions.\"\n  ]\n}\n```"