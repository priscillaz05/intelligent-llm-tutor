"```json\n{\n  \"Coding Problem\": \"The map of Bertown can be represented as a set of $n$ intersections, numbered from $1$ to $n$ and connected by $m$ one-way roads. It is possible to move along the roads from any intersection to any other intersection. The length of some path from one intersection to another is the number of roads that one has to traverse along the path. The shortest path from one intersection $v$ to another intersection $u$ is the path that starts in $v$, ends in $u$ and has the minimum length among all such paths.\\n\\nPolycarp lives near the intersection $s$ and works in a building near the intersection $t$. Every day he gets from $s$ to $t$ by car. Today he has chosen the following path to his workplace: $p_1$, $p_2$, ..., $p_k$, where $p_1 = s$, $p_k = t$, and all other elements of this sequence are the intermediate intersections, listed in the order Polycarp arrived at them. Polycarp never arrived at the same intersection twice, so all elements of this sequence are pairwise distinct. Note that you know Polycarp's path beforehand (it is fixed), and it is not necessarily one of the shortest paths from $s$ to $t$.\\n\\nPolycarp's car has a complex navigation system installed in it. Let's describe how it works. When Polycarp starts his journey at the intersection $s$, the system chooses some shortest path from $s$ to $t$ and shows it to Polycarp. Let's denote the next intersection in the chosen path as $v$. If Polycarp chooses to drive along the road from $s$ to $v$, then the navigator shows him the same shortest path (obviously, starting from $v$ as soon as he arrives at this intersection). However, if Polycarp chooses to drive to another intersection $w$ instead, the navigator rebuilds the path: as soon as Polycarp arrives at $w$, the navigation system chooses some shortest path from $w$ to $t$ and shows it to Polycarp. The same process continues until Polycarp arrives at $t$: if Polycarp moves along the road recommended by the system, it maintains the shortest path it has already built; but if Polycarp chooses some other path, the system rebuilds the path by the same rules.\\n\\nHere is an example. Suppose the map of Bertown looks as follows, and Polycarp drives along the path $[1, 2, 3, 4]$ ($s = 1$, $t = 4$): \\n\\nWhen Polycarp starts at $1$, the system chooses some shortest path from $1$ to $4$. There is only one such path, it is $[1, 5, 4]$;  Polycarp chooses to drive to $2$, which is not along the path chosen by the system. When Polycarp arrives at $2$, the navigator rebuilds the path by choosing some shortest path from $2$ to $4$, for example, $[2, 6, 4]$ (note that it could choose $[2, 3, 4]$);  Polycarp chooses to drive to $3$, which is not along the path chosen by the system. When Polycarp arrives at $3$, the navigator rebuilds the path by choosing the only shortest path from $3$ to $4$, which is $[3, 4]$;  Polycarp arrives at $4$ along the road chosen by the navigator, so the system does not have to rebuild anything. \\n\\nOverall, we get $2$ rebuilds in this scenario. Note that if the system chose $[2, 3, 4]$ instead of $[2, 6, 4]$ during the second step, there would be only $1$ rebuild (since Polycarp goes along the path, so the system maintains the path $[3, 4]$ during the third step).\\n\\nThe example shows us that the number of rebuilds can differ even if the map of Bertown and the path chosen by Polycarp stays the same. Given this information (the map and Polycarp's path), can you determine the minimum and the maximum number of rebuilds that could have happened during the journey?\\n\\n\\n-----Input-----\\n\\nThe first line contains two integers $n$ and $m$ ($2 \\\\le n \\\\le m \\\\le 2 \\\\cdot 10^5$) \u2014 the number of intersections and one-way roads in Bertown, respectively.\\n\\nThen $m$ lines follow, each describing a road. Each line contains two integers $u$ and $v$ ($1 \\\\le u, v \\\\le n$, $u \\\\ne v$) denoting a road from intersection $u$ to intersection $v$. All roads in Bertown are pairwise distinct, which means that each ordered pair $(u, v)$ appears at most once in these $m$ lines (but if there is a road $(u, v)$, the road $(v, u)$ can also appear).\\n\\nThe following line contains one integer $k$ ($2 \\\\le k \\\\le n$) \u2014 the number of intersections in Polycarp's path from home to his workplace.\\n\\nThe last line contains $k$ integers $p_1$, $p_2$, ..., $p_k$ ($1 \\\\le p_i \\\\le n$, all these integers are pairwise distinct) \u2014 the intersections along Polycarp's path in the order he arrived at them. $p_1$ is the intersection where Polycarp lives ($s = p_1$), and $p_k$ is the intersection where Polycarp's workplace is situated ($t = p_k$). It is guaranteed that for every $i \\\\in [1, k - 1]$ the road from $p_i$ to $p_{i + 1}$ exists, so the path goes along the roads of Bertown. \\n\\n\\n-----Output-----\\n\\nPrint two integers: the minimum and the maximum number of rebuilds that could have happened during the journey.\\n\\n\\n-----Examples-----\\nInput\\n6 9\\n1 5\\n5 4\\n1 2\\n2 3\\n3 4\\n4 1\\n2 6\\n6 4\\n4 2\\n4\\n1 2 3 4\\n\\nOutput\\n1 2\\n\\nInput\\n7 7\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 7\\n7 1\\n7\\n1 2 3 4 5 6 7\\n\\nOutput\\n0 0\\n\\nInput\\n8 13\\n8 7\\n8 6\\n7 5\\n7 4\\n6 5\\n6 4\\n5 3\\n5 2\\n4 3\\n4 2\\n3 1\\n2 1\\n1 8\\n5\\n8 7 5 2 1\\n\\nOutput\\n0 3\",\n  \"Ground Truth Solution\": \"(n, m) = list(map(int, input().split()))\\nprev_points = [[] for _ in range(n)]\\nfor _ in range(m):\\n\\t(u, v) = list(map(int, input().split()))\\n\\tu -= 1\\n\\tv -= 1\\n\\tprev_points[v].append(u)\\nk = int(input())\\np = [int(pi) - 1 for pi in input().split()]\\nbest_ways_d = [-1] * n\\nbest_ways_nm1 = [0] * n\\nq = [(p[-1], 0)]\\nfor (u, d) in q:\\n\\tif best_ways_d[u] < 0:\\n\\t\\tbest_ways_d[u] = d\\n\\t\\td += 1\\n\\t\\tfor v in prev_points[u]:\\n\\t\\t\\tq.append((v, d))\\n\\telif best_ways_d[u] == d:\\n\\t\\tbest_ways_nm1[u] += 1\\nans1 = ans2 = 0\\nfor i in range(1, k):\\n\\t(u, v) = (p[i - 1], p[i])\\n\\tif best_ways_d[u] <= best_ways_d[v]:\\n\\t\\tans1 += 1\\n\\t\\tans2 += 1\\n\\telif best_ways_nm1[u]:\\n\\t\\tans2 += 1\\nprint(ans1, ans2)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a navigation system that recalculates shortest paths when the driver deviates from its suggested route. We need to find the minimum and maximum number of times the system might rebuild the path, given Polycarp's fixed route and the road network of Bertown.\\n- Identify Key Information: We are given the number of intersections (n), the number of one-way roads (m), the road connections, and Polycarp's path (a sequence of intersections).\\n- Devise an Algorithm: A suitable approach is to use a modified Breadth-First Search (BFS) to determine the shortest distance from the destination (t) to every other intersection. From this information, we can determine when the navigation system would rebuild based on Polycarp's chosen path. The minimum rebuilds occur when the system always chooses the path that aligns most closely with Polycarp's path, and the maximum occurs when the system chooses a path that is the least aligned with Polycarp's.\\n- Calculate Shortest Distances: We perform a reverse BFS from the destination (t) to find the shortest distances from each intersection to t.  This can be implemented efficiently with a queue.\\n- Minimum Rebuilds: The minimum number of rebuilds occurs when the navigator always chooses the shortest path such that Polycarp follows the shortest path most of the time. If dist[p[i-1]] == dist[p[i]] + 1, then the shortest path is being followed, so there is no need to rebuild. If dist[p[i-1]] <= dist[p[i]], then it implies rebuild is necessary.\\n- Maximum Rebuilds: The maximum number of rebuilds occurs when Polycarp never follows the shortest path chosen by the navigation system. If the distance to the target from intersection p[i-1] is greater than distance from p[i] + 1, then the navigator system selected different road to get to target at p[i-1]. We need to account for scenarios where multiple shortest paths exist and the system may choose a path different than what Polycarp is taking. best_ways_nm1 counts number of shortest paths.\\n- Edge Cases and Constraints: Consider the constraint where it is possible to reach any intersection from any other. Take into account the size limits for n and m. Consider the case when multiple shortest paths exist.\",\n  \"LLM Questions\": [\n    \"What is the objective of this coding problem and what are the inputs?\",\n    \"How can we determine shortest path from each of the intersections to the destination t?\",\n    \"How do you determine the minimum number of rebuilds, given that the navigator can choose the optimal path?\",\n    \"How do you determine the maximum number of rebuilds, considering the existence of multiple shortest paths?\",\n    \"What data structures could be used for efficient processing of the graph and calculating shortest paths?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"The problem is to find the minimum and maximum number of times Polycarp's car navigation system rebuilds its path from his starting point to his workplace, given the road network and his chosen route. The inputs are the number of intersections, the number of one-way roads and their connections, and the path Polycarp takes.\",\n    \"A reverse Breadth-First Search (BFS) starting from the destination 't' can be used to find the shortest distance from each intersection to 't'. We explore the graph backwards from the destination, calculating the shortest distances as we go.\",\n    \"The minimum number of rebuilds occurs when the navigation system always chooses a shortest path such that Polycarp follows it as often as possible. This happens when the distance from p[i-1] to the destination is exactly one greater than the distance from p[i] to the destination. Each time this condition is not met, a rebuild is necessary, so we count these instances.\",\n    \"The maximum number of rebuilds occurs when Polycarp deviates from the shortest path chosen by the navigator at each step. We also need to account for the possibility of multiple shortest paths; the rebuild happens as long as system rebuilds a path which Polycarp doesn't follow. The count for possible shortest path has to be maintained as well.\",\n    \"Adjacency lists or matrices can represent the road network. A queue is suitable for BFS. An array can store the shortest distances from each node to the destination. Another array can store the number of shortest paths.\"\n  ]\n}\n```"