"```json\n{\n  \"Coding Problem\": \"A string is called beautiful if no two consecutive characters are equal. For example, \\\"ababcb\\\", \\\"a\\\" and \\\"abab\\\" are beautiful strings, while \\\"aaaaaa\\\", \\\"abaa\\\" and \\\"bb\\\" are not.\\n\\nAhcl wants to construct a beautiful string. He has a string $s$, consisting of only characters 'a', 'b', 'c' and '?'. Ahcl needs to replace each character '?' with one of the three characters 'a', 'b' or 'c', such that the resulting string is beautiful. Please help him!\\n\\nMore formally, after replacing all characters '?', the condition $s_i \\\\neq s_{i+1}$ should be satisfied for all $1 \\\\leq i \\\\leq |s| - 1$, where $|s|$ is the length of the string $s$.\\n\\n\\n-----Input-----\\n\\nThe first line contains positive integer $t$ ($1 \\\\leq t \\\\leq 1000$)\u00a0\u2014 the number of test cases. Next $t$ lines contain the descriptions of test cases.\\n\\nEach line contains a non-empty string $s$ consisting of only characters 'a', 'b', 'c' and '?'.\\n\\nIt is guaranteed that in each test case a string $s$ has at least one character '?'. The sum of lengths of strings $s$ in all test cases does not exceed $10^5$.\\n\\n\\n-----Output-----\\n\\nFor each test case given in the input print the answer in the following format:\\n\\n  If it is impossible to create a beautiful string, print \\\"-1\\\" (without quotes);  Otherwise, print the resulting beautiful string after replacing all '?' characters. If there are multiple answers, you can print any of them. \\n\\n\\n-----Example-----\\nInput\\n3\\na???cb\\na??bbc\\na?b?c\\n\\nOutput\\nababcb\\n-1\\nacbac\\n\\n\\n\\n-----Note-----\\n\\nIn the first test case, all possible correct answers are \\\"ababcb\\\", \\\"abcacb\\\", \\\"abcbcb\\\", \\\"acabcb\\\" and \\\"acbacb\\\". The two answers \\\"abcbab\\\" and \\\"abaabc\\\" are incorrect, because you can replace only '?' characters and the resulting string must be beautiful.\\n\\nIn the second test case, it is impossible to create a beautiful string, because the $4$-th and $5$-th characters will be always equal.\\n\\nIn the third test case, the only answer is \\\"acbac\\\".\",\n  \"Ground Truth Solution\": \"t = int(input())\\ns = []\\nfor kfnf in range(0, t):\\n\\ta = input()\\n\\tif 'aa' in a or 'bb' in a or 'cc' in a:\\n\\t\\ts.append(-1)\\n\\telif 'a' not in a and 'b' not in a and ('c' not in a):\\n\\t\\tj = len(a)\\n\\t\\tl = j % 3\\n\\t\\ti = ''\\n\\t\\ti += int(j // 3) * 'abc'\\n\\t\\tif l <= 1:\\n\\t\\t\\ti += l * 'a'\\n\\t\\telse:\\n\\t\\t\\ti += 'ab'\\n\\t\\ts.append(i)\\n\\telse:\\n\\t\\tu = list(a)\\n\\t\\tb = len(u)\\n\\t\\tif u[0] == '?' and u[1] == '?':\\n\\t\\t\\tu[0] = 'a'\\n\\t\\telif u[0] == '?' and u[1] != '?':\\n\\t\\t\\tif u[1] == 'a' or u[1] == 'c':\\n\\t\\t\\t\\tu[0] = 'b'\\n\\t\\t\\telse:\\n\\t\\t\\t\\tu[0] = 'a'\\n\\t\\tif u[b - 1] == '?' and u[b - 2] == '?':\\n\\t\\t\\tu[b - 1] = 'a'\\n\\t\\telif u[b - 1] == '?' and u[b - 2] != '?':\\n\\t\\t\\tif u[b - 2] == 'a' or u[b - 2] == 'b':\\n\\t\\t\\t\\tu[b - 1] = 'c'\\n\\t\\t\\telse:\\n\\t\\t\\t\\tu[b - 1] = 'a'\\n\\t\\tfor i in range(1, b - 1):\\n\\t\\t\\tif u[i] == '?':\\n\\t\\t\\t\\tif u[i + 1] == '?':\\n\\t\\t\\t\\t\\tif u[i - 1] == 'a':\\n\\t\\t\\t\\t\\t\\tu[i] = 'b'\\n\\t\\t\\t\\t\\telif u[i - 1] == 'b' or u[i - 1] == 'c':\\n\\t\\t\\t\\t\\t\\tu[i] = 'a'\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tp = [u[i - 1], u[i + 1]]\\n\\t\\t\\t\\t\\tp.sort()\\n\\t\\t\\t\\t\\tif p == ['a', 'b'] or p == ['b', 'b'] or p == ['a', 'a']:\\n\\t\\t\\t\\t\\t\\tu[i] = 'c'\\n\\t\\t\\t\\t\\telif p == ['a', 'c'] or p == ['a', 'a']:\\n\\t\\t\\t\\t\\t\\tu[i] = 'b'\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tu[i] = 'a'\\n\\t\\td = ''\\n\\t\\tfor i in u:\\n\\t\\t\\td += i\\n\\t\\ts.append(d)\\nfor i in s:\\n\\tprint(i)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding Problem Constraints: The problem requires replacing all '?' characters in a given string with 'a', 'b', or 'c' such that no two adjacent characters are the same. The input string consists of 'a', 'b', 'c', and '?'. If it's impossible to create a beautiful string, print -1.\\n- Identifying Potential Pitfalls: The presence of consecutive identical characters (other than '?') immediately makes the string impossible to make beautiful. Need to consider edge cases such as when the input string is empty or only contains '?'. When replacing '?', the choice depends on the neighboring characters. When consecutive '?' characters appear, need to ensure they don't become the same.\\n- Selecting an Algorithmic Strategy: Iterate through the string. If we find consecutive identical characters (other than '?'), immediately output -1. Otherwise, iterate through the string, replacing '?' with 'a', 'b', or 'c' based on the preceding and following characters to ensure that the string is beautiful. Handle the first and last character as a special case.\\n- Implementing Replacement Logic: For each '?', check its adjacent characters. If both adjacent characters are known, choose the character that is different from both. If only one adjacent character is known, choose a character that is different from it. If both are '?', then choose 'a' or 'b' based on the previous or next known characters. Convert the string to a list for easier manipulation, and then back to a string at the end.\",\n  \"LLM Questions\": [\n    \"What does it mean for a string to be considered 'beautiful' in this context?\",\n    \"What are some conditions that would immediately make it impossible to create a beautiful string from the given input?\",\n    \"If a '?' character is encountered, how should its replacement be determined based on its neighboring characters?\",\n    \"What special considerations should be given to the first and last character of the string when replacing '?' characters?\",\n    \"What data structure can be used to efficiently manipulate the string characters during the replacement process?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A string is 'beautiful' if no two consecutive characters are equal.\",\n    \"The presence of consecutive identical characters (other than '?') in the original string will make it impossible to form a beautiful string.\",\n    \"The replacement of a '?' character must differ from its adjacent characters. If both adjacent characters are known, pick the one that is different from both. If only one is known, pick something different from that. If both are '?', default pick 'a' or 'b' based on previous or next chars.\",\n    \"The first and last characters only have one neighbor. Therefore, replace them with a character different from their single adjacent character.\",\n    \"A list of characters allows efficient modification of characters in place. The final answer needs to be converted back to a string.\"\n  ]\n}\n```"