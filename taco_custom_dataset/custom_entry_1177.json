"```json\n{\n  \"Coding Problem\": \"Chef built a binary string S that has exactly N hills and M valleys.\\n\\nA hill is any index 1 < i < |S| such that both its neighbors are strictly smaller than it, i.e, S_{i-1} < S_{i} and S_{i+1} < S_{i}.\\n\\nA valley is any index 1 < i < |S| such that both its neighbors are strictly larger than it, i.e, S_{i-1} > S_{i} and S_{i+1} > S_{i}.\\n\\nChef thinks that his string S is the shortest among all binary strings with N hills and M valleys.  You don't quite trust his words, so to verify his claim you would like to find the shortest binary string with exactly N hills and M valleys.\\n\\nIf there are multiple possible binary strings of the least length satisfying the given condition, you may print any of them.\\n\\n------ Input Format ------ \\n\\n- The first line of input will contain a single integer T, denoting the number of test cases. The description of T test cases follows.\\n- The first and only line of each test case contains two space-separated integers N and M, the required number of hills and valleys respectively.\\n\\n------ Output Format ------ \\n\\nFor each test case, output two lines.\\n- The first line contains the length of the binary string you constructed to satisfy the given conditions.\\n- The second line contains the string itself.\\n\\n------ Constraints ------ \\n\\n$1 \u2264 T \u2264 2500$\\n$1 \u2264 N \u2264 500$\\n$1 \u2264 M \u2264 500$\\n- The sum of lengths of the answer strings across all test cases does not exceed $2\\\\cdot 10^{5}$\\n\\n------ subtasks ------ \\n\\nSubtask 1 (10 points): \\n$1 \u2264 N \u2264 50$\\n$1 \u2264 M \u2264 50$\\nYou may output any string of length not exceeding $320$ containing exactly $N$ hills and $M$ valleys:  it need not be shortest by length. It is guaranteed that at least one such string with length $\u2264 320$ exists.\\n\\nSubtask 2 (90 points):\\nOriginal constraints\\nThe binary string you construct must be shortest by length.\\n\\n----- Sample Input 1 ------ \\n3\\n3 2\\n2 3\\n3 3\\n----- Sample Output 1 ------ \\n7\\n0101010\\n7\\n1010101\\n8\\n01010101\\n----- explanation 1 ------ \\nTest case $1$: The given string has hills at indices $2, 4, 6$ and valleys at indices $3, 5$. It can be verified that there is no string of length $6$ or less with $3$ hills and $2$ valleys.  Note that for subtask $1$, a binary string like $001010100$ will also be accepted as a valid output, even though it is not shortest by length. \\n\\nTest case $3$: Apart from the given string, another possible string of length $8$ that has $3$ hills and $3$ valleys is $10101010$. You may print any of them.\",\n  \"Ground Truth Solution\": \"def soln(n: int, m: int) -> int:\\n\\tif n >= m:\\n\\t\\tgreat = '1'\\n\\t\\tless = '0'\\n\\telse:\\n\\t\\tgreat = '0'\\n\\t\\tless = '1'\\n\\ts = less\\n\\tfor i in range(min(n, m)):\\n\\t\\ts += great + less\\n\\tif n == m:\\n\\t\\ts += great\\n\\t\\tprint(len(s))\\n\\t\\tprint(s)\\n\\t\\treturn\\n\\tfor i in range(abs(n - m)):\\n\\t\\ts += great + less * 2\\n\\tprint(len(s) - 1)\\n\\tprint(s[:len(s) - 1])\\nfor _ in range(int(input())):\\n\\t(n, m) = map(int, input().split())\\n\\tsoln(n, m)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The task is to construct the shortest binary string with a given number of hills (N) and valleys (M). Hills are indices where the element is larger than its neighbors, and valleys are indices where the element is smaller than its neighbors.\\n- Algorithmic Strategy: The key idea is to alternate between 0 and 1 to create hills and valleys. Start with the digit that would yield the larger number of either hills or valleys. Build a base string with min(N, M) hills/valleys. After the base string, if N == M, append one more hill/valley.  If they're unequal, add the remaining hills or valleys in a way that they do not create additional valleys/hills respectively by appending two of the other number. \\n- Edge Case Handling: Special care needs to be taken to ensure the outputted string is the shortest and follows the constraints.\",\n  \"LLM Questions\": [\n    \"What does it mean to find the 'shortest' binary string with a given number of hills and valleys?\",\n    \"How does the relative magnitudes of N and M affect the construction of the shortest string?\",\n    \"How can you efficiently construct the shortest string by alternating between 0 and 1?\",\n    \"What are the edge cases or specific conditions that might complicate the construction of the string, and how would you handle them?\",\n    \"Can you explain the purpose of string concatenation?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Finding the 'shortest' binary string implies minimizing the length of the string while still satisfying the specified hill and valley counts.\",\n    \"The magnitude of N and M determine which digit to start with ('1' if N >= M, '0' otherwise). Starting with the digit corresponding to the greater value ensures that we can most efficiently achieve the desired number of hills and valleys.\",\n    \"Construct the string by alternating between 0 and 1 or 1 and 0, forming hills and valleys. The minimum length is achieved by placing pairs of '01' or '10' such that each placement contributes to creating both a hill and valley.\",\n    \"When N equals M, adding one extra digit is necessary. Also, consider the construction after building the minimum pattern.  If N and M are not equal, extend the string by adding pairs that consist of one of the larger digit and two of the smaller digit.\",\n    \"String concatenation is essential for combining binary strings in this process to achieve the number of hills and valleys. It builds a longer binary string from smaller parts.\"\n  ]\n}\n```"