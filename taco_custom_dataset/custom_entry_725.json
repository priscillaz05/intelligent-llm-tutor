"```json\n{\n  \"Coding Problem\": \"Unicode Transformation Format \u2013 8-bit\\nAs the name suggests UTF-8 was designed to encode data in a stream of bytes.\\n\\nIt works by splitting the bits up in multiples of eight. This is achieved by inserting headers to mark in how many bytes the bits were split. If the bits need to be split in two, the header `110` is added as prefix leaving five bits of the byte for the rest of the data. Followed by a continuation byte.\\n\\nA continuation byte always start with `10` leaving six bits for data.\\nFor a three-way split: the header `1110` is added with two continuation bytes and for four: `11110` with three continuation bytes. The number of ones at the start of the first byte denotes the number of bytes the data was split in.\\n# Task\\nYour task is to write two functions:\\n1. `to_utf8_binary`: which encodes a string to a bitstring using UTF-8 encoding.\\n2. `from_utf8_binary`: which does the reverse.\\n\\n- Layout of UTF-8 byte sequences:\\n```\\n# BYTES  FIRST CODE POINT  LAST CODE POINT    BYTE 1      BYTE 2      BYTE 3      BYTE 4\\n    1                   0              127    0xxxxxxx  \\n    2                 128             2047    110xxxxx    10xxxxxx\\n    3                2048            65535    1110xxxx    10xxxxxx    10xxxxxx  \\n    4               65536          1114111    11110xxx    10xxxxxx    10xxxxxx    10xxxxxx\\n```\\n\\n# Examples\\n```\\nENCODE\\n A  -> 1000001         -> 01000001\\n \u516b -> 101000101101011 -> 1110-0101 10-000101 10-101011\\n \\nDECODE\\n 110-00010 10-100111                     -> 10100111          -> \u00a7\\n 11110-000 10-010000 10-001010 10-001100 -> 10000001010001100 -> \ud800\ude8c\\n```\\n* Spaces and hyphens just for clarity\\n- https://en.wikipedia.org/wiki/UTF-8#Encoding\",\n  \"Ground Truth Solution\": \"from textwrap import wrap\\n\\ndef to_utf8_binary(string):\\n\\treturn ''.join((format(x, 'b').rjust(8, '0') for x in bytearray(string, 'utf-8')))\\n\\ndef from_utf8_binary(bitstring):\\n\\treturn bytearray([int(t, 2) for t in wrap(bitstring, 8)]).decode()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding UTF-8 Encoding: Recognize that UTF-8 encodes characters using 1 to 4 bytes, where the first byte indicates the number of bytes used for that character. Continuation bytes always start with `10`. Understand the bit patterns for 1, 2, 3, and 4-byte sequences.\\n- Encoding a String to a Bitstring: To encode a string, convert each character to its UTF-8 byte representation. Convert each byte to its binary representation (8 bits), padding with leading zeros if necessary, and concatenate these binary strings.\\n- Decoding a Bitstring to a String: Split the bitstring into 8-bit chunks (bytes). Convert each binary chunk into an integer, and then create a bytearray from these integers. Finally, decode the bytearray using UTF-8 to obtain the string.\\n- Consider Edge Cases and Error Handling: Although not explicitly required, consider handling invalid UTF-8 sequences or non-UTF-8 bitstrings during decoding to avoid errors. For the encoding function, special characters should be correctly translated to UTF-8 byte sequences.\",\n  \"LLM Questions\": [\n    \"What are the bit patterns for the first byte in UTF-8 encoding for 1-byte, 2-byte, 3-byte, and 4-byte sequences?\",\n    \"How do you convert a character to its UTF-8 byte representation in Python?\",\n    \"How do you convert a byte to its 8-bit binary representation, padding with zeros if necessary?\",\n    \"When decoding, how do you handle a bitstring that is not a multiple of 8 in length?\",\n    \"What potential errors might occur when decoding a bitstring, and how could you handle them?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"For 1-byte: `0xxxxxxx`, 2-byte: `110xxxxx`, 3-byte: `1110xxxx`, 4-byte: `11110xxx`. The 'x' represents the data bits.\",\n    \"You can use `bytearray(string, 'utf-8')` to get the UTF-8 byte representation of the string.\",\n    \"You can use `format(byte, 'b').rjust(8, '0')` to convert a byte to an 8-bit binary string with leading zeros.\",\n    \"If the bitstring length is not a multiple of 8, it's an incomplete byte, and you should either pad it or reject it as an invalid UTF-8 sequence depending on the implementation requirements.\",\n    \"Potential errors include invalid UTF-8 sequences, incorrect byte lengths for a character, and incomplete bitstrings. Error handling might involve raising an exception, returning a default value, or skipping the invalid characters.\"\n  ]\n}\n```"