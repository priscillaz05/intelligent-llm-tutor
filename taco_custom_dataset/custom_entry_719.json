"```json\n{\n  \"Coding Problem\": \"Design a data structure that works like a LRU Cache. Here cap denotes the capacity of the cache and Q denotes the number of queries. Query can be of two types:\\n\\tSET x y: sets the value of the key x with value y \\n\\tGET x: gets the key of x if present else returns -1.\\nThe LRUCache class has two methods get() and set() which are defined as follows.\\n\\tget(key): returns the value of the key if it already exists in the cache otherwise returns -1.\\n\\tset(key, value): if the key is already present, update its value. If not present, add the key-value pair to the cache. If the cache reaches its capacity it should invalidate the least recently used item before inserting the new item.\\n\\tIn the constructor of the class the capacity of the cache should be initialized.\\n \\nExample 1:\\nInput:\\ncap = 2\\nQ = 2\\nQueries = SET 1 2 GET 1\\nOutput: 2\\nExplanation: \\nCache Size = 2\\nSET 1 2 GET 1\\nSET 1 2 : 1 -> 2\\nGET 1 : Print the value corresponding\\nto Key 1, ie 2.\\nExample 2:\\nInput:\\ncap = 2\\nQ = 8\\nQueries = SET 1 2 SET 2 3 SET 1 5\\nSET 4 5 SET 6 7 GET 4 SET 1 2 GET 3\\nOutput: 5 -1\\nExplanation: \\nCache Size = 2\\nSET 1 2 : 1 -> 2\\nSET 2 3 : 1 -> 2, 2 -> 3 (the most recently \\nused one is kept at the rightmost position) \\nSET 1 5 : 2 -> 3, 1 -> 5\\nSET 4 5 : 1 -> 5, 4 -> 5 (Cache size is 2, hence \\nwe delete the least recently used key-value pair)\\nSET 6 7 : 4 -> 5, 6 -> 7 \\nGET 4 : Prints 5 (The cache now looks like\\n6 -> 7, 4->5)\\nSET 1 2 : 4 -> 5, 1 -> 2 \\n(Cache size is 2, hence we delete the least \\nrecently used key-value pair)\\nGET 3 : No key value pair having \\nkey = 3. Hence, -1 is printed.\\nYour Task:\\nYou don't need to read input or print anything. Complete the constructor and get(), and set() methods of the class LRUcache. \\nExpected Time Complexity: O(1) for both get() and set().\\nExpected Auxiliary Space: O(1) for both get() and set(). \\n(Although, you may use extra space for cache storage and implementation purposes).\\nConstraints:\\n1 <= cap <= 10^3\\n1 <= Q <= 10^5\\n1 <= x, y <= 10^4\",\n  \"Ground Truth Solution\": \"class Node:\\n\\n\\tdef __init__(self, key=None, value=None):\\n\\t\\tself.key = key\\n\\t\\tself.value = value\\n\\t\\tself.prev = None\\n\\t\\tself.next = None\\n\\nclass LRUCache:\\n\\n\\tdef __init__(self, capacity):\\n\\t\\tself.capacity = capacity\\n\\t\\tself.cache = {}\\n\\t\\tself.head = Node()\\n\\t\\tself.tail = Node()\\n\\t\\tself.head.next = self.tail\\n\\t\\tself.tail.prev = self.head\\n\\n\\tdef get(self, key):\\n\\t\\tif key in self.cache:\\n\\t\\t\\tnode = self.cache[key]\\n\\t\\t\\tself._remove(node)\\n\\t\\t\\tself._add(node)\\n\\t\\t\\treturn node.value\\n\\t\\treturn -1\\n\\n\\tdef set(self, key, value):\\n\\t\\tif key in self.cache:\\n\\t\\t\\tnode = self.cache[key]\\n\\t\\t\\tself._remove(node)\\n\\t\\telif len(self.cache) == self.capacity:\\n\\t\\t\\tnode = self.tail.prev\\n\\t\\t\\tself._remove(node)\\n\\t\\t\\tdel self.cache[node.key]\\n\\t\\tnode = Node(key, value)\\n\\t\\tself.cache[key] = node\\n\\t\\tself._add(node)\\n\\n\\tdef _add(self, node):\\n\\t\\tnext_node = self.head.next\\n\\t\\tself.head.next = node\\n\\t\\tnode.prev = self.head\\n\\t\\tnode.next = next_node\\n\\t\\tnext_node.prev = node\\n\\n\\tdef _remove(self, node):\\n\\t\\tprev_node = node.prev\\n\\t\\tnext_node = node.next\\n\\t\\tprev_node.next = next_node\\n\\t\\tnext_node.prev = prev_node\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem Requirements: Comprehend the functionality of an LRU Cache, including its capacity, the 'SET' operation (adding/updating key-value pairs), and the 'GET' operation (retrieving values or returning -1 if not found).\\n- Identifying Core Data Structures: Determine appropriate data structures, such as a dictionary (hash map) for quick lookups and a doubly linked list to maintain the order of least recently used items. Consider the trade-offs of using built-in Python dictionaries vs. OrderedDict.\\n- Developing an Eviction Strategy: Define the logic for evicting the least recently used item when the cache is full.  This involves identifying the tail of the linked list as the LRU item and updating the dictionary to remove the mapping.\\n- Implementing the 'GET' Operation: Implement the 'GET' operation, which involves retrieving a value from the dictionary, moving the corresponding node to the head of the linked list (marking it as most recently used), and returning the value. If the key is not present, return -1.\\n- Implementing the 'SET' Operation: Outline the implementation of the 'SET' operation. This includes handling the case where the key is already present (updating its value and moving it to the head of the linked list), the case where the key is new and the cache is not full (adding a new node to the head), and the case where the key is new and the cache is full (evicting the LRU item and adding the new node to the head).\",\n  \"LLM Questions\": [\n    \"How does an LRU cache work, and what are its key features?\",\n    \"Expected Answer: An LRU cache evicts the least recently used items first when the cache is full. Key features include fast retrieval (O(1) time complexity) and a limited capacity.\",\n    \"What data structures are best suited for implementing an LRU cache, and why?\",\n    \"Expected Answer: A hash map (dictionary) for O(1) get/set operations and a doubly linked list to keep track of the order of element access. The hash map provides quick lookup, and the linked list facilitates efficient removal of the least recently used element.\",\n    \"How do you handle the eviction of the least recently used item when the cache reaches its capacity?\",\n    \"Expected Answer: Identify the tail of the doubly linked list as the LRU item. Remove the corresponding node from the linked list and delete the key-value pair from the hash map.\",\n    \"In the 'GET' operation, what steps do you take to move an accessed item to the front of the LRU cache?\",\n    \"Expected Answer: If the key exists, retrieve the node from the hash map. Remove it from its current position in the linked list and move it to the head, updating the pointers of neighboring nodes.\",\n    \"What steps are involved in the 'SET' operation when the key is already present in the cache?\",\n    \"Expected Answer: Update the value of the existing node in the hash map. Move the node to the head of the linked list to mark it as most recently used.\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"An LRU cache evicts the least recently used items first when the cache is full. Key features include fast retrieval (O(1) time complexity) and a limited capacity.\",\n    \"A hash map (dictionary) for O(1) get/set operations and a doubly linked list to keep track of the order of element access. The hash map provides quick lookup, and the linked list facilitates efficient removal of the least recently used element.\",\n    \"Identify the tail of the doubly linked list as the LRU item. Remove the corresponding node from the linked list and delete the key-value pair from the hash map.\",\n    \"If the key exists, retrieve the node from the hash map. Remove it from its current position in the linked list and move it to the head, updating the pointers of neighboring nodes.\",\n    \"Update the value of the existing node in the hash map. Move the node to the head of the linked list to mark it as most recently used.\"\n  ]\n}\n```"