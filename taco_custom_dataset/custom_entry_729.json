"```json\n{\n  \"Coding Problem\": \"Shashank loves trees and math. He has a rooted tree, $\\\\mathbf{T}$, consisting of $N$ nodes uniquely labeled with integers in the inclusive range $[1,N]$. The node labeled as $1$ is the root node of tree $\\\\mathbf{T}$, and each node in $\\\\mathbf{T}$ is associated with some positive integer value (all values are initially $\\\\mbox{0}$). \\n\\nLet's define $\\\\mathbf{F_k}$ as the $k^{th}$ Fibonacci number. Shashank wants to perform $2$ types of operations over his tree, $\\\\mathbf{T}$:\\n\\n$\\\\mbox{U}$ $\\\\mbox{X}$ $\\\\boldsymbol{\\\\mbox{k}}$\\n\\nUpdate the subtree rooted at node $\\\\mbox{X}$ such that the node at level $0$ in subtree $\\\\mbox{X}$ (i.e., node $\\\\mbox{X}$) will have $\\\\mathbf{F_k}$ added to it, all the nodes at level $\\\\mbox{I}$ will have $\\\\boldsymbol{F}_{k+1}$ added to them, and so on. More formally, all the nodes at a distance $\\\\mbox{D}$ from node $\\\\mbox{X}$ in the subtree of node $\\\\mbox{X}$ will have the $(k+D)^{\\\\mathrm{th}}$ Fibonacci number added to them.\\n$Q$ $\\\\mbox{X}$ $\\\\mathbf{Y}$\\n\\nFind the sum of all values associated with the nodes on the unique path from $\\\\mbox{X}$ to $\\\\mathbf{Y}$. Print your sum modulo $10^9+7$ on a new line.\\n\\nGiven the configuration for tree $\\\\mathbf{T}$ and a list of $\\\\mbox{M}$ operations, perform all the operations efficiently.\\n\\nNote: $F_1=F_2=1$.\\n\\nInput Format\\n\\nThe first line contains $2$ space-separated integers, $N$ (the number of nodes in tree $\\\\mathbf{T}$) and $\\\\mbox{M}$ (the number of operations to be processed), respectively. \\n\\nEach line $\\\\boldsymbol{i}$ of the $N-1$ subsequent lines contains an integer, $\\\\mbox{P}$, denoting the parent of the $(i+1)^{th}$ node. \\n\\nEach of the $\\\\mbox{M}$ subsequent lines contains one of the two types of operations mentioned in the Problem Statement above.\\n\\nConstraints\\n\\n$1\\\\leq N,M\\\\leq10^5$\\n$1\\\\leq X,Y\\\\leq N$\\n$1\\\\leq k\\\\leq10^{15}$\\n\\nOutput Format\\n\\nFor each operation of type $2$ (i.e., $Q$), print the required answer modulo $10^9+7$ on a new line.\\n\\nSample Input\\n5 10\\n1\\n1\\n2\\n2\\nQ 1 5\\nU 1 1\\nQ 1 1\\nQ 1 2\\nQ 1 3\\nQ 1 4\\nQ 1 5\\nU 2 2\\nQ 2 3\\nQ 4 5\\n\\nSample Output\\n0\\n1\\n2\\n2\\n4\\n4\\n4\\n10\\n\\nExplanation\\n\\nIntially, the tree looks like this:\\n\\nAfter update operation $1\\\\:\\\\:1$, it looks like this:\\n\\nAfter update operation $\\\\textbf{2}\\\\\\\\\\\\textbf{2}$, it looks like this:\",\n  \"Ground Truth Solution\": \"mod = 10 ** 9 + 7\\ncache = {0: (0, 1), 1: (1, 1)}\\n\\ndef fib_pair(n):\\n\\tif n in cache:\\n\\t\\treturn cache[n]\\n\\thn = n // 2\\n\\t(f, fp) = fib_pair(hn)\\n\\tif n & 1:\\n\\t\\tres = ((fp * fp + f * f) % mod, (2 * f + fp) * fp % mod)\\n\\telse:\\n\\t\\tfm = fp - f\\n\\t\\tif fm < 0:\\n\\t\\t\\tfm += mod\\n\\t\\tres = ((2 * fm + f) * f % mod, (fp * fp + f * f) % mod)\\n\\tif n < 1000000:\\n\\t\\tcache[n] = res\\n\\treturn res\\n(n, m) = map(int, input().strip().split())\\nparents = (n + 1) * [0]\\nchildren = [[] for _ in range(n + 1)]\\nfor i in range(2, n + 1):\\n\\tj = int(input())\\n\\tparents[i] = j\\n\\tchildren[j].append(i)\\ndepths = (n + 1) * [0]\\nstack = [(1, 1)]\\nwhile stack:\\n\\t(i, d) = stack.pop()\\n\\tdepths[i] = d\\n\\tfor j in children[i]:\\n\\t\\tstack.append((j, d + 1))\\nnrs = (n + 1) * [0]\\nfor _ in range(m):\\n\\t(q, si, sj) = input().strip().split()\\n\\tif q == 'U':\\n\\t\\t(x, k) = (int(si), int(sj))\\n\\t\\tfibs = list(fib_pair(k))\\n\\t\\tstack = [(x, 0)]\\n\\t\\twhile stack:\\n\\t\\t\\t(y, l) = stack.pop()\\n\\t\\t\\tif l >= len(fibs):\\n\\t\\t\\t\\tfibs.append((fibs[-1] + fibs[-2]) % mod)\\n\\t\\t\\tnrs[y] += fibs[l]\\n\\t\\t\\tfor z in children[y]:\\n\\t\\t\\t\\tstack.append((z, l + 1))\\n\\telse:\\n\\t\\t(i, j) = (int(si), int(sj))\\n\\t\\tif depths[i] < depths[j]:\\n\\t\\t\\t(i, j) = (j, i)\\n\\t\\tfsum = 0\\n\\t\\twhile depths[j] < depths[i]:\\n\\t\\t\\tfsum += nrs[i]\\n\\t\\t\\ti = parents[i]\\n\\t\\twhile i != j:\\n\\t\\t\\tfsum += nrs[i] + nrs[j]\\n\\t\\t\\tj = parents[j]\\n\\t\\t\\ti = parents[i]\\n\\t\\tfsum += nrs[i]\\n\\t\\tprint(fsum % mod)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: Recognize the need to perform two types of operations on a rooted tree: updating subtree values based on Fibonacci numbers and querying the sum of node values along a path.\\n- Efficient Fibonacci Calculation: Identify that Fibonacci numbers need to be computed efficiently due to potentially large values of 'k'. Consider memoization or matrix exponentiation to avoid redundant calculations.\\n- Tree Traversal: Choose appropriate tree traversal methods (e.g., Depth-First Search) for updating subtree nodes and finding the path between two nodes.\\n- Modular Arithmetic: Acknowledge that all calculations must be performed modulo $10^9 + 7$ to prevent integer overflow.\\n- Data Structures: Decide on suitable data structures for storing tree structure (e.g., adjacency lists, parent array), node values, and precomputed depths.\\n- Optimizations: Aim to optimize the update operation by precomputing depths and efficiently calculating Fibonacci numbers. Efficiently find the path between two nodes by finding the lowest common ancestor (LCA).\",\n  \"LLM Questions\": [\n    \"How can you efficiently compute Fibonacci numbers for large values of k, given the constraint $1 \\\\leq k \\\\leq 10^{15}$?\",\n    \"How would you represent the tree structure to efficiently perform subtree updates and path queries?\",\n    \"What is the best way to calculate the distance (depth) from a given node X in its subtree, and how can you utilize this information during the update operation?\",\n    \"How can you efficiently find the unique path between two nodes X and Y in the tree?\",\n    \"How do you ensure that all calculations remain within the modulo $10^9 + 7$ to avoid integer overflow, especially during Fibonacci computations and path sum calculations?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Efficient Fibonacci calculation can be done using techniques like memoization (caching previously computed values) or matrix exponentiation. Memoization stores calculated Fibonacci numbers, reducing redundant computations, and matrix exponentiation allows Fibonacci numbers to be calculated in logarithmic time.\",\n    \"The tree structure can be represented using an adjacency list to store the children of each node, and a parent array to store the parent of each node.  Storing precomputed depths for each node can help speed up path queries and subtree updates.\",\n    \"The distance from a given node X in its subtree can be calculated using Depth-First Search (DFS) or Breadth-First Search (BFS). During the update operation, each node at distance D from X has $F_{k+D}$ added to it.\",\n    \"The unique path between two nodes X and Y can be found by first finding the lowest common ancestor (LCA) of X and Y. Then, the path consists of the path from X to the LCA and the path from Y to the LCA, excluding the LCA itself if X != Y.\",\n    \"To ensure calculations remain within the modulo, apply the modulo operator ($% (10^9 + 7)$) after every arithmetic operation (addition, multiplication, subtraction). For Fibonacci numbers, perform the modulo operation within the calculation process.\"\n  ]\n}\n```"