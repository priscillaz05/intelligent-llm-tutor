"```json\n{\n  \"Coding Problem\": \"Rng has a connected undirected graph with N vertices. Currently, there are M edges in the graph, and the i-th edge connects Vertices A_i and B_i.\\n\\nRng will add new edges to the graph by repeating the following operation:\\n\\n* Operation: Choose u and v (u \\\\neq v) such that Vertex v can be reached by traversing exactly three edges from Vertex u, and add an edge connecting Vertices u and v. It is not allowed to add an edge if there is already an edge connecting Vertices u and v.\\n\\n\\n\\nFind the maximum possible number of edges that can be added.\\n\\nConstraints\\n\\n* 2 \\\\leq N \\\\leq 10^5\\n* 1 \\\\leq M \\\\leq 10^5\\n* 1 \\\\leq A_i,B_i \\\\leq N\\n* The graph has no self-loops or multiple edges.\\n* The graph is connected.\\n\\nInput\\n\\nInput is given from Standard Input in the following format:\\n\\n\\nN M\\nA_1 B_1\\nA_2 B_2\\n:\\nA_M B_M\\n\\n\\nOutput\\n\\nFind the maximum possible number of edges that can be added.\\n\\nExamples\\n\\nInput\\n\\n6 5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n\\n\\nOutput\\n\\n4\\n\\n\\nInput\\n\\n5 5\\n1 2\\n2 3\\n3 1\\n5 4\\n5 1\\n\\n\\nOutput\\n\\n5\",\n  \"Ground Truth Solution\": \"import sys, queue, math, copy, itertools, bisect, collections, heapq\\n\\ndef main():\\n\\tsys.setrecursionlimit(10 ** 7)\\n\\tINF = 10 ** 18\\n\\tMOD = 10 ** 9 + 7\\n\\tLI = lambda : [int(x) for x in sys.stdin.readline().split()]\\n\\t_LI = lambda : [int(x) - 1 for x in sys.stdin.readline().split()]\\n\\tNI = lambda : int(sys.stdin.readline())\\n\\tSI = lambda : sys.stdin.readline().rstrip()\\n\\t(N, M) = LI()\\n\\tnode = [-1] * N\\n\\tedge = [[] for _ in range(N)]\\n\\tfor _ in range(M):\\n\\t\\t(a, b) = _LI()\\n\\t\\tedge[a].append(b)\\n\\t\\tedge[b].append(a)\\n\\tnode[0] = 0\\n\\tq = collections.deque()\\n\\tq.append((0, 0))\\n\\td = [0] * 2\\n\\twhile q:\\n\\t\\t(u, c) = q.popleft()\\n\\t\\tfor v in edge[u]:\\n\\t\\t\\tif c == node[v]:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tif node[v] < 0:\\n\\t\\t\\t\\tnode[v] = 1 - c\\n\\t\\t\\t\\tq.append((v, node[v]))\\n\\t\\telse:\\n\\t\\t\\tcontinue\\n\\t\\td[1] = N - 1\\n\\t\\tnode = [0] * N\\n\\t\\tbreak\\n\\telse:\\n\\t\\td[0] = node.count(0)\\n\\t\\td[1] = node.count(1)\\n\\tans = 0\\n\\tfor i in range(N):\\n\\t\\tans += d[1 - node[i]] - len(edge[i])\\n\\tprint(ans // 2)\\nmain()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem describes a graph and an operation to add new edges. The goal is to find the maximum number of edges that can be added using the specified operation.\\n- Identifying Key Constraints: Note the constraints on N and M (up to 10^5), and the fact the graph is connected and has no self-loops or multiple edges.\\n- Algorithmic Strategy:  The core idea revolves around identifying if the graph is bipartite. If the graph is bipartite, then all vertices reachable in three steps will be in the same partition. The number of potential edges between partitions is related to the size of the partitions. If the graph is not bipartite, we can connect any two nodes in 3 steps (or an odd number of steps) so it becomes a complete graph. Determine if the graph is bipartite using a coloring approach. If it is bipartite then calculate the maximum possible edges between two sets else compute the maximum edges that can be present in a complete graph.\\n- Implementation Details: Use Depth First Search (DFS) or Breadth First Search (BFS) to color the graph. If a conflict in coloring is found, the graph is not bipartite. If it is bipartite determine the count of each color. The number of potential new edges will be equal to the product of count of both color minus the existing edge between them.\\n-Optimizations: Consider edge cases where the graph is a complete graph or there are no possible new edges to add based on initial graph structure.\",\n  \"LLM Questions\": [\n    \"What does it mean for the graph to be bipartite and how can we identify a bipartite graph?\",\n    \"How can BFS or DFS be used to determine if the graph is bipartite by assigning colors to nodes?\",\n    \"If the graph is bipartite, how is the maximum number of possible edges computed, and how does this relate to the two partitions?\",\n    \"If the graph is not bipartite, what is the maximum number of possible edges that can be added?\",\n    \"How can you handle the constraints to avoid exceeding time limits?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets. Bipartiteness can be detected by trying to color the graph with two colors; if a conflict arises (adjacent nodes have the same color), then the graph is not bipartite.\",\n    \"BFS or DFS can be used to color the graph by assigning one of two colors to each node. Start with an arbitrary node and assign it a color. Then, traverse its neighbors and assign them the opposite color. If, during traversal, you find a neighbor that already has the same color, the graph is not bipartite.\",\n    \"If the graph is bipartite, the maximum number of possible edges is the product of the sizes of the two partitions. From this subtract the number of existing edges between those partitions to get edges to be added.\",\n    \"If the graph is not bipartite, you cannot guarantee reaching every node at 3 steps so consider that we can add edges between any nodes. In that case, it will become a complete graph so the total number of edges would be N*(N-1)/2 and subtracting initial edge counts will give the number of edges added.\",\n    \"Using BFS or DFS to check for bipartiteness is essential. Use appropriate data structures, such as adjacency lists, to store the graph. Modulo operations can also be helpful to optimize edge counts.\"\n  ]\n}\n```"