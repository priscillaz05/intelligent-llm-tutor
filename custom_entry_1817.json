"```json\n{\n  \"Coding Problem\": \"Kefa wants to celebrate his first big salary by going to restaurant. However, he needs company. \\n\\nKefa has n friends, each friend will agree to go to the restaurant if Kefa asks. Each friend is characterized by the amount of money he has and the friendship factor in respect to Kefa. The parrot doesn't want any friend to feel poor compared to somebody else in the company (Kefa doesn't count). A friend feels poor if in the company there is someone who has at least d units of money more than he does. Also, Kefa wants the total friendship factor of the members of the company to be maximum. Help him invite an optimal company!\\n\\n\\n-----Input-----\\n\\nThe first line of the input contains two space-separated integers, n and d (1 \u2264 n \u2264 10^5, $1 \\\\leq d \\\\leq 10^{9}$) \u2014 the number of Kefa's friends and the minimum difference between the amount of money in order to feel poor, respectively.\\n\\nNext n lines contain the descriptions of Kefa's friends, the (i + 1)-th line contains the description of the i-th friend of type m_{i}, s_{i} (0 \u2264 m_{i}, s_{i} \u2264 10^9) \u2014 the amount of money and the friendship factor, respectively. \\n\\n\\n-----Output-----\\n\\nPrint the maximum total friendship factir that can be reached.\\n\\n\\n-----Examples-----\\nInput\\n4 5\\n75 5\\n0 100\\n150 20\\n75 1\\n\\nOutput\\n100\\n\\nInput\\n5 100\\n0 7\\n11 32\\n99 10\\n46 8\\n87 54\\n\\nOutput\\n111\\n\\n\\n\\n-----Note-----\\n\\nIn the first sample test the most profitable strategy is to form a company from only the second friend. At all other variants the total degree of friendship will be worse.\\n\\nIn the second sample test we can take all the friends.\",\n  \"Ground Truth Solution\": \"(n, d) = map(int, input().split())\\nl_p = list()\\nfor _ in range(n):\\n\\tl_p.append(list(map(int, input().split())))\\nl_p.sort()\\n(l, h) = (0, 0)\\nf = 0\\nf_m = 0\\nwhile h < len(l_p):\\n\\tif l_p[h][0] - l_p[l][0] >= d:\\n\\t\\tf -= l_p[l][1]\\n\\t\\tl += 1\\n\\telse:\\n\\t\\tf += l_p[h][1]\\n\\t\\th += 1\\n\\tf_m = max(f_m, f)\\nprint(f_m)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The goal is to maximize the total friendship factor of the friends Kefa invites, under the constraint that no friend feels poor compared to others. A friend feels poor if another invited friend has at least 'd' more money than them.\\n- Data Structures and Sorting: The problem can be efficiently solved by first sorting the friends based on their money. This allows us to use a sliding window approach to find the optimal set of friends.\\n- Sliding Window Approach: Use two pointers, 'left' and 'right', to define a sliding window. Expand the window to the right, adding the friendship factor of the new friend. If the difference between the richest and poorest friend in the window is greater than or equal to 'd', then shrink the window from the left, removing the friendship factor of the poorest friend.\\n- Maximizing Friendship Factor: Keep track of the maximum friendship factor encountered during the sliding window traversal. The final result will be the maximum friendship factor achieved.\",\n  \"LLM Questions\": [\n    \"How does sorting the friends by money simplify the problem?\",\n    \"What is the significance of the 'd' value in the problem statement?\",\n    \"Can you explain the sliding window approach and how it helps in finding the optimal solution?\",\n    \"How do you keep track of the maximum friendship factor during the sliding window traversal?\",\n    \"What are the edge cases to consider, and how would they affect the solution?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Sorting the friends by money allows us to efficiently check if a friend will feel poor compared to others using a sliding window approach.\",\n    \"'d' represents the minimum difference in money that makes a friend feel poor. This constraint needs to be maintained while choosing the optimal company.\",\n    \"The sliding window approach involves maintaining two pointers, 'left' and 'right', to define a subset of friends. We expand the window to the right and shrink it from the left, ensuring that no friend feels poor and maximizing the total friendship factor.\",\n    \"The maximum friendship factor is tracked by maintaining a variable that stores the highest total friendship factor encountered so far during the sliding window traversal. It's updated whenever the current window's friendship factor exceeds the previously stored maximum.\",\n    \"Edge cases include when the number of friends is small or when 'd' is very large. If the number of friends is small, we can iterate through all possible subsets of friends. If 'd' is very large, it may be optimal to invite only one friend with a high friendship factor.\"\n  ]\n}\n```"