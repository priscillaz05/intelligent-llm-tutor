"```json\n{\n  \"Coding Problem\": \"Alice likes to shop online. The main reason is that she gets a lot of discounts! There are M online shops from where she purchases her items. The prices of the same item vary in both the shops. She needs to buy N items in all. And each she can buy each item in any one of the shops. All the shops offer certain discounts. If she buys the i^{th} item in one shop, she gets a discount coupon for the i+1^{th} item in the same shop. But if she purchases the i+1^{th} item from a different shop, she cannot use the discount coupon.\\nFor example, if she buys the i^{th} item in Shop j and gets a discount of X rupees. Let the price of i+1^{th} item be Y rupees in shop j and Z rupees in shop k. If she purchases the i+1^{th} item from shop j she can use the discount coupon and hence, will have to pay Y-X rupees. If she purchases the i+1^{th} item from shop k she cannot use the discount coupon and hence, will have to pay Z rupees.\\nNote: If the discount given is more than price of the item in the shop, i.e. if Y-X < 0, the item is given free but she does NOT get any money back.\\nAlice wants to spend as less as possible and wants your help. She starts buying from item 1 and goes on till item N in that order. Your task is simple. Tell her the least amount to spend to get all the N items.\\n\\n------ Input: ------ \\n\\nFirst line of input contains a single integer T, the number of test cases.\\n\\nEach test case starts with a line consisting of two space separated integers N & M.\\nThe next N lines consist of M space separated integers each. The j^{th} number on the i^{th} line denotes the price of i^{th} item in the j^{th} shop.\\n\\nThe next N lines consist of M space separated integers each. The j^{th} number on the i^{th} line denotes the value of discount coupon given after purchasing i^{th} item in the j^{th} shop.\\n\\n------ Output: ------ \\n\\nFor each test case, output on a separate line the least amount that has to be spent to get all the N items.\\n\\n------ Constraints: ------ \\n\\n1 \u2264 T \u2264 10\\n2 \u2264 N, M \u2264 100000\\n0 \u2264 Prices, Discounts \u2264 1000000\\n1 \u2264 T * N * M \u2264 1000000\\n\\n------ Scoring: ------ \\n\\nYou will be awarded 40 points for solving the problem correctly for M = 2.\\n\\nAnother 20 points for solving the problem correctly for M \u2264 100.\\n\\nRemaining 40 points will be awarded for solving the problem correctly for M > 100.\\n\\n----- Sample Input 1 ------ \\n2\\n2 2\\n3 4\\n1 2\\n1 0\\n0 1\\n2 4\\n1 2 3 4\\n4 3 2 1\\n2 3 2 1\\n1 2 1 1\\n----- Sample Output 1 ------ \\n3\\n2\",\n  \"Ground Truth Solution\": \"for i in range(int(input())):\\n\\t(N, M) = list(map(int, input().split(' ')))\\n\\tC = [list(map(int, input().split(' '))) for _ in range(N)]\\n\\tD = [list(map(int, input().split(' '))) for _ in range(N)]\\n\\tdp = [[0] * M for _ in range(N)]\\n\\tfor j in range(M):\\n\\t\\tdp[0][j] = C[0][j]\\n\\tmin_value = min(dp[0])\\n\\tfor i in range(1, N):\\n\\t\\tfor j in range(M):\\n\\t\\t\\tdp[i][j] = min(min_value + C[i][j], dp[i - 1][j] + max(0, C[i][j] - D[i - 1][j]))\\n\\t\\tmin_value = min(dp[i])\\n\\tprint(min_value)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The problem requires finding the minimum cost for Alice to buy N items from M shops. She can buy each item from any shop, but she gets a discount for the next item only if she buys it from the same shop.\\n- Identifying the Optimal Substructure: The optimal solution for buying N items can be derived from the optimal solutions for buying the first i items. This suggests a dynamic programming approach.\\n- Defining the DP State: Define dp[i][j] as the minimum cost to buy the first i+1 items, ending with buying the (i+1)-th item from shop j.\\n- Formulating the Recurrence Relation: The cost dp[i][j] can be derived in two ways: either Alice bought the i-th item from shop j, or she bought it from a different shop. If she bought it from the same shop, the cost is dp[i-1][j] + max(0, C[i][j] - D[i-1][j]), where C[i][j] is the price of the (i+1)-th item in shop j, and D[i-1][j] is the discount received after buying the i-th item from shop j. If she bought the i-th item from a different shop, the cost is min(dp[i-1][k] for k != j) + C[i][j]. Taking the minimum of these two costs gives dp[i][j].\\n- Optimizing the Solution: Instead of calculating min(dp[i-1][k] for k != j) in each iteration, precompute the minimum value of dp[i-1] and use it. This will reduce the complexity of the solution.\",\n  \"LLM Questions\": [\n    \"How can we represent the minimum cost of purchasing items up to a certain index using dynamic programming?\",\n    \"How do we account for the discount that Alice gets when buying consecutive items from the same shop?\",\n    \"How can we optimize the calculation of the minimum cost when switching to a different shop for the next item?\",\n    \"What are the base cases for our dynamic programming solution?\",\n    \"How do we handle the case when the discount exceeds the price of the item?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"We can use a 2D array, dp[i][j], where i represents the index of the item (from 0 to N-1) and j represents the shop (from 0 to M-1). dp[i][j] stores the minimum cost to buy the first i+1 items, ending with buying the (i+1)-th item from shop j.\",\n    \"When Alice buys the i-th and (i+1)-th items from the same shop j, the cost of the (i+1)-th item is C[i][j] - D[i-1][j], where C[i][j] is the price of the (i+1)-th item in shop j and D[i-1][j] is the discount from the i-th item in shop j. We must take the maximum with 0 because the item can be free, but Alice doesn't get money back.\",\n    \"We can precompute the minimum cost among all shops for the previous item, min(dp[i-1][k] for all k). Then, when calculating dp[i][j], we use this precomputed minimum cost plus the price of the current item in shop j. This avoids iterating through all shops for each item.\",\n    \"The base cases are for the first item (i=0). dp[0][j] is simply the price of the first item in shop j, C[0][j].\",\n    \"If the discount exceeds the price of the item (C[i][j] - D[i-1][j] < 0), the item is free, meaning we should use a cost of 0.  We can ensure this by using max(0, C[i][j] - D[i-1][j]).\"\n  ]\n}\n```"