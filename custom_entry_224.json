"```json\n{\n  \"Coding Problem\": \"Read problem statements in [Hindi], [Bengali], [Mandarin Chinese], [Russian], and [Vietnamese] as well.\\n\\nChef has always dreamed of becoming an employee of the \\\"Hack and Manipulate Group\\\". Their work is simple \u2015 attacking networks. They gave Chef the following task to assess his programming skills, but Chef is too busy cooking \\\"Vegetable Gourmet\\\". Can you solve the task for him?\\n\\nA network consists of $N$ nodes (numbered $1$ through $N$) and $M$ bidirectional connections between pairs of these nodes. A *robust network* is a network that contains a cycle. Shutting down a node means removing that node (and all direct connections it is part of) from the network.\\n\\nYou may shut down at most one node. If the network was robust before it was shut down and is not robust afterwards, this node is called the *point of failure*.\\n\\nIs the initial network robust? If it is robust, does it have a point of failure? If it does, find the point of failure with the smallest number.\\n\\n------  Input ------\\nThe first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\\nThe first line of each test case contains two space-separated integers $N$ and $M$.\\nEach of the following $M$ lines contains two space-separated integers $u$ and $v$ denoting that nodes $u$ and $v$ are directly connected.\\n\\n------  Output ------\\nFor each test case, print a single line containing one integer \u2015 the smallest number of a point of failure, or $-1$ if the network does not have a point of failure.\\n\\n------  Constraints ------\\n$1 \u2264 T \u2264 10$\\n$1 \u2264 N \u2264 10^{5}$\\n$0 \u2264 M \u2264 10^{5}$\\n$1 \u2264 u, v \u2264 N$\\n\\n------  Subtasks ------\\nSubtask #1 (10 points):\\n$N \u2264 100$\\n$N - 1 \u2264 M \u2264 N + 1$\\nthe given graph is connected\\n\\nSubtask #2 (10 points): $1 \u2264 N \u2264 100$\\n\\nSubtask #3 (30 points): $1 \u2264 N \u2264 1,000$\\n\\nSubtask #4 (50 points): original constraints\\n\\n----- Sample Input 1 ------ \\n5\\n\\n5 5\\n\\n5 1\\n\\n5 2\\n\\n1 2\\n\\n2 3\\n\\n2 4\\n\\n5 6\\n\\n4 5\\n\\n4 1\\n\\n4 2\\n\\n4 3\\n\\n5 1\\n\\n5 2\\n\\n5 5\\n\\n3 4\\n\\n3 5\\n\\n3 1\\n\\n3 2\\n\\n4 2\\n\\n4 1\\n\\n3 4\\n\\n6 6\\n\\n1 2\\n\\n2 3\\n\\n3 1\\n\\n4 5\\n\\n5 6\\n\\n6 4\\n----- Sample Output 1 ------ \\n1\\n\\n4\\n\\n2\\n\\n-1\\n\\n-1\",\n  \"Ground Truth Solution\": \"from collections import defaultdict\\n\\nclass UndirectedGraph:\\n\\n\\tdef __init__(self, node_num):\\n\\t\\tself.node_num = node_num\\n\\t\\tself.graph = defaultdict(list)\\n\\n\\tdef add_edge(self, v, w):\\n\\t\\tself.graph[v].append(w)\\n\\t\\tself.graph[w].append(v)\\n\\n\\tdef _find(self, v, visited, deleted):\\n\\t\\tstack = [v]\\n\\t\\tparent = defaultdict(int)\\n\\t\\twhile stack:\\n\\t\\t\\tv = stack.pop()\\n\\t\\t\\tfor next_v in self.graph[v]:\\n\\t\\t\\t\\tif next_v == parent[v]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif visited[next_v]:\\n\\t\\t\\t\\t\\tpath = [v]\\n\\t\\t\\t\\t\\twhile next_v != v:\\n\\t\\t\\t\\t\\t\\tv = parent[v]\\n\\t\\t\\t\\t\\t\\tpath.append(v)\\n\\t\\t\\t\\t\\treturn path\\n\\t\\t\\t\\tif next_v not in deleted:\\n\\t\\t\\t\\t\\tparent[next_v] = v\\n\\t\\t\\t\\t\\tstack.append(next_v)\\n\\t\\t\\tvisited[v] = True\\n\\t\\treturn None\\n\\n\\tdef find_cycle(self, del_nodes):\\n\\t\\tvisited = [False] * (self.node_num + 1)\\n\\t\\tdeleted = set(del_nodes)\\n\\t\\tfor i in self.graph:\\n\\t\\t\\tif not visited[i] and i not in deleted:\\n\\t\\t\\t\\tcycle = self._find(i, visited, deleted)\\n\\t\\t\\t\\tif cycle:\\n\\t\\t\\t\\t\\treturn cycle\\n\\t\\treturn []\\ntry:\\n\\ttest_num = int(input())\\n\\n\\tdef get_input():\\n\\t\\treturn list(map(int, input().split()))\\n\\tfor _ in range(test_num):\\n\\t\\t(n, m) = get_input()\\n\\t\\tedges = [get_input() for _ in range(m)]\\n\\t\\tg = UndirectedGraph(n)\\n\\t\\tfor (i, j) in edges:\\n\\t\\t\\tg.add_edge(i, j)\\n\\t\\t(cycle, fail_node) = (g.find_cycle([]), -1)\\n\\t\\tif cycle and (not g.find_cycle(cycle)):\\n\\t\\t\\tcycle.sort()\\n\\t\\t\\tfor i in cycle:\\n\\t\\t\\t\\tif not g.find_cycle([i]):\\n\\t\\t\\t\\t\\tfail_node = i\\n\\t\\t\\t\\t\\tbreak\\n\\t\\tprint(fail_node)\\nexcept EOFError:\\n\\tpass\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: A network of nodes and bidirectional connections is \\\"robust\\\" if it contains a cycle. A \\\"point of failure\\\" is a node that, when removed, turns a previously robust network into a non-robust one. The goal is to identify the smallest numbered node that serves as a point of failure.\\n- Identifying Robustness: The core concept to address is cycle detection. The problem specifies a robust network must have a cycle.\\n- Algorithm Selection: The core algorithm should involve cycle detection. We can consider Depth-First Search (DFS) or Breadth-First Search (BFS) approaches. To determine the point of failure, we'll need to check for cycles after removing each node within a cycle in the initial network.\\n- Implementation Strategy: First, check if the graph has cycles. Then, for each node in a cycle, create a modified graph (or virtually modify the graph) by removing the node and any connecting edges. After each removal, check for cycles again. If a node's removal makes the graph acyclic, that node is a potential point of failure. Select the node with the smallest number from those points of failure.\",\n  \"LLM Questions\": [\n    \"What constitutes a 'robust network' in the context of this problem, and how can you determine if a given network is robust?\",\n    \"What defines a 'point of failure' in the network, and under what condition is a node considered a point of failure?\",\n    \"What strategies or algorithms can efficiently determine the presence of cycles in a given network?\",\n    \"If the initial network is not robust, what should the program output?\",\n    \"How do you handle the case where multiple nodes are potential points of failure, and which one should be selected?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"A robust network is defined as one containing at least one cycle. To determine if a network is robust, you need to apply a cycle detection algorithm, such as DFS-based cycle detection.\",\n    \"A point of failure is a node that, when removed from the network, causes the previously robust network to become non-robust (acyclic). A node is a point of failure if its removal breaks all cycles in the original graph.\",\n    \"Common cycle detection algorithms include Depth-First Search (DFS) which maintains a visited and recursion stack to detect back edges, indicating a cycle. Another approach is using topological sort: if a topological sort is not possible (due to a cycle), then the graph contains a cycle.\",\n    \"If the initial network is not robust (i.e., it does not contain a cycle), then there cannot be a point of failure, and the program should output -1.\",\n    \"If multiple nodes can be identified as points of failure, the problem requires selecting the point of failure with the smallest node number. The implementation should keep track of potential points of failure and return the smallest one.\"\n  ]\n}\n```"