"```json\n{\n  \"Coding Problem\": \"Ksenia has an array $a$ consisting of $n$ positive integers $a_1, a_2, \\\\ldots, a_n$. \\n\\nIn one operation she can do the following:   choose three distinct indices $i$, $j$, $k$, and then  change all of $a_i, a_j, a_k$ to $a_i \\\\oplus a_j \\\\oplus a_k$ simultaneously, where $\\\\oplus$ denotes the bitwise XOR operation. \\n\\nShe wants to make all $a_i$ equal in at most $n$ operations, or to determine that it is impossible to do so. She wouldn't ask for your help, but please, help her!\\n\\n\\n-----Input-----\\n\\nThe first line contains one integer $n$ ($3 \\\\leq n \\\\leq 10^5$)\u00a0\u2014 the length of $a.\\n\\nThe second line contains $n$ integers, $a_1, a_2, \\\\ldots, a_n$ ($1 \\\\leq a_i \\\\leq 10^9$)\u00a0\u2014 elements of $a.\\n\\n\\n-----Output-----\\n\\nPrint YES or NO in the first line depending on whether it is possible to make all elements equal in at most $n$ operations.\\n\\nIf it is possible, print an integer $m$ ($0 \\\\leq m \\\\leq n$), which denotes the number of operations you do.\\n\\nIn each of the next $m$ lines, print three distinct integers $i, j, k$, representing one operation. \\n\\nIf there are many such operation sequences possible, print any. Note that you do not have to minimize the number of operations.\\n\\n\\n-----Examples-----\\nInput\\n5\\n4 2 1 7 2\\n\\nOutput\\nYES\\n1\\n1 3 4\\nInput\\n4\\n10 4 49 22\\n\\nOutput\\nNO\\n\\n\\n\\n-----Note-----\\n\\nIn the first example, the array becomes $[4 \\\\oplus 1 \\\\oplus 7, 2, 4 \\\\oplus 1 \\\\oplus 7, 4 \\\\oplus 1 \\\\oplus 7, 2] = [2, 2, 2, 2, 2]$.\",\n  \"Ground Truth Solution\": \"import os\\nimport sys\\nfrom io import BytesIO, IOBase\\nimport heapq as h\\nfrom bisect import bisect_left, bisect_right\\nimport time\\nfrom types import GeneratorType\\nBUFSIZE = 8192\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\timport os\\n\\t\\tself.os = os\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = self.os.read(self._fd, max(self.os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tself.os.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\nfrom collections import defaultdict as dd, deque as dq, Counter as dc\\nimport math, string\\n\\ndef getInts():\\n\\treturn [int(s) for s in input().split()]\\n\\ndef getInt():\\n\\treturn int(input())\\n\\ndef getStrs():\\n\\treturn [s for s in input().split()]\\n\\ndef getStr():\\n\\treturn input()\\n\\ndef listStr():\\n\\treturn list(input())\\n\\ndef getMat(n):\\n\\treturn [getInts() for _ in range(n)]\\nMOD = 10 ** 9 + 7\\n\\ndef solve():\\n\\tN = getInt()\\n\\tA = getInts()\\n\\tif N % 2 == 1:\\n\\t\\tprint('YES')\\n\\t\\tprint(N - 2)\\n\\t\\tfor j in range(1, N - 1, 2):\\n\\t\\t\\tprint(j, j + 1, j + 2)\\n\\t\\tfor j in range(N - 4, 0, -2):\\n\\t\\t\\tprint(j, j + 1, j + 2)\\n\\t\\treturn\\n\\tx = A[0] ^ A[1] ^ A[2]\\n\\ty = 0\\n\\tfor j in range(3, N):\\n\\t\\ty ^= A[j]\\n\\tif x != y:\\n\\t\\tprint('NO')\\n\\t\\treturn\\n\\tprint('YES')\\n\\tprint(1 + (N - 5 if N > 4 else 0))\\n\\tprint(1, 2, 3)\\n\\tfor j in range(4, N - 1, 2):\\n\\t\\tprint(j, j + 1, j + 2)\\n\\tfor j in range(N - 4, 3, -2):\\n\\t\\tprint(j, j + 1, j + 2)\\n\\treturn\\nsolve()\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The goal is to make all elements of the array equal using XOR operations on triplets of indices. The number of operations should be at most $n$.\\n- Identifying Key Conditions: An important observation is that if $n$ is odd, we can always make all elements equal. If $n$ is even, we need to check if the XOR sum of all elements is 0. If it's not, it's impossible. If it is, we can make them equal.\\n- Devising a Strategy for Odd $n$: If $n$ is odd, we can perform the operation on indices 1, 2, 3, then 3, 4, 5, and so on, until the end of the array. Then, we can perform operations backward from the end of the array. This makes all elements equal to the XOR sum of the first three elements after the first round.\\n- Devising a Strategy for Even $n$: If $n$ is even and the XOR sum is 0, we can perform an initial operation on the first three elements and then apply the same strategy used in the odd $n$ case for the remaining $n-3+1$ or $n-2$ elements.\",\n  \"LLM Questions\": [\n    \"When is it always possible to make all elements equal, and under what condition is it impossible?\",\n    \"How can we efficiently determine whether it is possible to make all elements equal when n is even?\",\n    \"If n is odd, what sequence of operations can we perform to make all elements equal?\",\n    \"If n is even and the condition for a solution is met, what adjustments need to be made to the operations from the odd case?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"It is always possible if n is odd. If n is even, it is possible if the XOR sum of all elements is 0; otherwise, it's impossible.\",\n    \"We can calculate the XOR sum of all elements and check if it equals 0.\",\n    \"We can iterate through the array using steps of 2, applying XOR to triplets (1, 2, 3), (3, 4, 5), and so on, and then do the same in reverse order.\",\n    \"If n is even and the XOR sum of the array is 0, then we start with an operation on indices 1, 2, and 3 and proceed as in the odd n case for the subarray from index 4 to n. Since the first 3 elements changed, then we apply the same technique for elements from index 4 up to n.\"\n  ]\n}\n```"