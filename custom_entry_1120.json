"```json\n{\n  \"Coding Problem\": \"You are given a sequence a_1, a_2, ..., a_{n} of one-dimensional segments numbered 1 through n. Your task is to find two distinct indices i and j such that segment a_{i} lies within segment a_{j}.\\n\\nSegment [l_1, r_1] lies within segment [l_2, r_2] iff l_1 \u2265 l_2 and r_1 \u2264 r_2.\\n\\nPrint indices i and j. If there are multiple answers, print any of them. If no answer exists, print -1 -1.\\n\\n\\n-----Input-----\\n\\nThe first line contains one integer n (1 \u2264 n \u2264 3\u00b710^5) \u2014 the number of segments.\\n\\nEach of the next n lines contains two integers l_{i} and r_{i} (1 \u2264 l_{i} \u2264 r_{i} \u2264 10^9) \u2014 the i-th segment.\\n\\n\\n-----Output-----\\n\\nPrint two distinct indices i and j such that segment a_{i} lies within segment a_{j}. If there are multiple answers, print any of them. If no answer exists, print -1 -1.\\n\\n\\n-----Examples-----\\nInput\\n5\\n1 10\\n2 9\\n3 9\\n2 3\\n2 9\\n\\nOutput\\n2 1\\n\\nInput\\n3\\n1 5\\n2 6\\n6 20\\n\\nOutput\\n-1 -1\\n\\n\\n-----Note-----\\n\\nIn the first example the following pairs are considered correct:  (2, 1), (3, 1), (4, 1), (5, 1) \u2014 not even touching borders;  (3, 2), (4, 2), (3, 5), (4, 5) \u2014 touch one border;  (5, 2), (2, 5) \u2014 match exactly.\",\n  \"Ground Truth Solution\": \"from collections import Counter\\nimport os\\nimport sys\\nfrom io import BytesIO, IOBase\\nBUFSIZE = 8192\\nimport math\\n\\nclass FastIO(IOBase):\\n\\tnewlines = 0\\n\\n\\tdef __init__(self, file):\\n\\t\\tself._fd = file.fileno()\\n\\t\\tself.buffer = BytesIO()\\n\\t\\tself.writable = 'x' in file.mode or 'r' not in file.mode\\n\\t\\tself.write = self.buffer.write if self.writable else None\\n\\n\\tdef read(self):\\n\\t\\twhile True:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tif not b:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines = 0\\n\\t\\treturn self.buffer.read()\\n\\n\\tdef readline(self):\\n\\t\\twhile self.newlines == 0:\\n\\t\\t\\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\\n\\t\\t\\tself.newlines = b.count(b'\\\\n') + (not b)\\n\\t\\t\\tptr = self.buffer.tell()\\n\\t\\t\\t(self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr))\\n\\t\\tself.newlines -= 1\\n\\t\\treturn self.buffer.readline()\\n\\n\\tdef flush(self):\\n\\t\\tif self.writable:\\n\\t\\t\\tos.write(self._fd, self.buffer.getvalue())\\n\\t\\t\\t(self.buffer.truncate(0), self.buffer.seek(0))\\n\\nclass IOWrapper(IOBase):\\n\\n\\tdef __init__(self, file):\\n\\t\\tself.buffer = FastIO(file)\\n\\t\\tself.flush = self.buffer.flush\\n\\t\\tself.writable = self.buffer.writable\\n\\t\\tself.write = lambda s: self.buffer.write(s.encode('ascii'))\\n\\t\\tself.read = lambda : self.buffer.read().decode('ascii')\\n\\t\\tself.readline = lambda : self.buffer.readline().decode('ascii')\\n(sys.stdin, sys.stdout) = (IOWrapper(sys.stdin), IOWrapper(sys.stdout))\\ninput = lambda : sys.stdin.readline().rstrip('\\\\r\\\\n')\\n\\ndef divs(n, start=2):\\n\\tdivisors = []\\n\\tfor i in range(start, int(math.sqrt(n) + 1)):\\n\\t\\tif n % i == 0:\\n\\t\\t\\tif n / i == i:\\n\\t\\t\\t\\tdivisors.append(i)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdivisors.extend([i, n // i])\\n\\treturn divisors\\nimport sys\\ninf = float('inf')\\nmod = 1000000007\\n\\ndef array():\\n\\treturn list(map(int, sys.stdin.readline().split()))\\n\\ndef intt():\\n\\treturn map(int, sys.stdin.readline().split())\\nfrom bisect import bisect_left\\nimport sys\\nn = int(sys.stdin.readline())\\nls = []\\nfor i in range(n):\\n\\t(u, v) = map(int, sys.stdin.readline().split())\\n\\tls.append((u, v, i))\\nls.sort(key=lambda x: (x[0], -1 * x[1]))\\nmax_r = ls[0][1]\\nind = ls[0][2]\\nfor i in range(1, n):\\n\\tif ls[i][1] <= max_r:\\n\\t\\tprint(ls[i][2] + 1, ind + 1)\\n\\t\\texit()\\n\\tif ls[i][1] > max_r:\\n\\t\\tmax_r = ls[i][1]\\n\\t\\tind = ls[i][2]\\nprint(-1, -1)\",\n  \"LLM CoT Steps Breakdown\": \"- Understanding the Problem: The core task involves identifying two distinct segments, i and j, where segment i is completely contained within segment j. This means the left boundary of i must be greater than or equal to the left boundary of j, and the right boundary of i must be less than or equal to the right boundary of j.\\n- Algorithmic Strategy: An efficient approach is to sort the segments based on their left boundaries in ascending order and, in case of ties, sort them by their right boundaries in descending order. This sorting strategy ensures that if a segment a[i] is contained within a segment a[j], then a[j] will appear earlier in the sorted list.\\n- Implementation Details: After sorting, iterate through the sorted segments and maintain the right boundary of the segment encountered so far with the minimum left boundary. If you encounter a segment where its right boundary is less than or equal to the minimum right boundary seen so far, it means you've found a segment contained within a previous segment. Return the indices of these two segments.\\n- Edge Cases and Constraints: Handle the edge case where no such pair exists by returning -1 -1. Ensure correct index handling to align with the problem's 1-based indexing requirement.\",\n  \"LLM Questions\": [\n    \"How do you define 'segment a_i lies within segment a_j' mathematically?\",\n    \"What is the most efficient way to compare all possible pairs of segments to find a containing pair?\",\n    \"If multiple pairs satisfy the condition, does the problem statement require returning a specific pair or any valid pair?\",\n    \"How should the segments be sorted to facilitate efficiently finding a containing pair?\",\n    \"What are the critical edge cases that need to be explicitly handled in the implementation?\"\n  ],\n  \"Expected Answers to LLM Questions\": [\n    \"Segment [l_i, r_i] lies within segment [l_j, r_j] if l_i >= l_j and r_i <= r_j.\",\n    \"Sorting the segments based on their left boundaries allows for efficient comparison without needing to check every pair individually. Sorting them by their left boundaries in ascending order and, in case of ties, sorting them by their right boundaries in descending order.\",\n    \"The problem statement specifies that any valid pair can be returned if multiple pairs exist.\",\n    \"The segments should be sorted by their left boundaries in ascending order. If there is a tie, sort the segment by their right boundaries in descending order. This allows you to maintain the lowest left boundary seen so far, and if the current segment's right boundary is less than or equal to the lowest right boundary, then the current segment is contained.\",\n    \"The critical edge case is when no pair of segments satisfies the condition, in which case -1 -1 should be returned. The array must also have at least 2 elements to check for containment.\"\n  ]\n}\n```"